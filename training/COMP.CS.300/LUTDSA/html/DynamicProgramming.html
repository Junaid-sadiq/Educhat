
<!DOCTYPE html>




<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>5.6. Dynamic Programming &mdash; BM40A1500 Data Structures and Algorithms</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/normalize.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/JSAV.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/odsaMOD-min.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/jquery.ui.min.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/odsaStyle-min.css" type="text/css" />
    
  <script type="text/javascript">
    var DOCUMENTATION_OPTIONS = {
      URL_ROOT:    './',
      VERSION:     '0.4.1',
      COLLAPSE_INDEX: false,
      FILE_SUFFIX: '.html',
      HAS_SOURCE:  true
    };
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      },
      "HTML-CSS": {
        scale: "80"
      }
    });
  </script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="index" title="BM40A1500 Data Structures and Algorithms" href="index.html" />
    <link rel="next" title="7. Introduction to Probabilistic Algorithms" href="Probabilistic.html" />
    <link rel="prev" title="5. Backtracking, and Branch and Bound" href="Backtracking.html" />

  </head>

  <body>


      <div class="header">
        
  
      <script type="text/javascript" src="../../../lib/jquery.min.js"></script>
      <script type="text/javascript" src="../../../lib/jquery.migrate.min.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.9.0/localforage.min.js"></script>
    <script type="text/javascript" src="../../../lib/jquery.ui.min.js"></script>
    <script type="text/javascript" src="../../../lib/jquery.transit.js"></script>
    <script type="text/javascript" src="../../../lib/raphael.js"></script>
    <script type="text/javascript" src="../../../lib/JSAV-min.js"></script>
    <script type="text/javascript" src="_static/config.js"></script>
    <script type="text/javascript" src="../../../lib/timeme-min.js"></script>
    <script type="text/javascript" src="../../../lib/odsaUtils-min.js"></script>
    <script type="text/javascript" src="../../../lib/odsaMOD-min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.13.0/d3.min.js"></script>
    <script type="text/javascript" src="https://d3js.org/d3-selection-multi.v1.min.js"></script>
    <script type="text/javascript" src="../../../lib/dataStructures.js"></script>
    <script type="text/javascript" src="../../../lib/conceptMap.js"></script>

        
<a id="username-link" style="float:right;color:red;margin:10px 20px auto; display: none" class="username-link" href="Gradebook.html"></a>
<a id="login-link" style="float:right;color:red;margin:10px 20px auto" class="login-link" href="#"><Macro 'login'></a>
<div id="login-box" class="login-popup">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close" /></a>
  <form method="post" class="signin" action="https://#">
    <fieldset class="textbox">
      <label class="username">
        <span>Username</span>
        <input id="username" value="" type="text" autocomplete="on" placeholder="Username" tabindex="1">
      </label>
      <label class="password">
        <span>Password</span>
        <input id="password" value="" type="password" placeholder="Password" tabindex="2">
        <span><a id="forgot" href="#">Forgot your password?</a></span>
      </label>

      <p>
        <input type="submit" id="login-submit-button" value="Sign in" tabindex="3" />
      </p>
      <p>
        <input type="button" id="register-button" value="Register" tabindex="4" />
      </p>
    </fieldset>
  </form>
</div>

        
<a id="registration-link" style="float:right;color:red;margin:10px 20px auto" class="registration-link" href="#">Register</a>
<div id="registration-box" class="registration-popup ">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close Window" /></a>
  <form method="post" class="signin" action="https://#">
    <fieldset class="textbox">
      <div id="register_error" class="error"></div>
      <label class="username">
        <span>Username:</span>
        <input type="text" id="user" placeholder="Username" />
      </label>

      <label class="password">
        <span>Password</span>
        <input id="pass" type="password" placeholder="Password" />
      </label>

      <label class="password">
        <span>Confirm Password</span>
        <input id="rpass" type="password" placeholder="Confirm Password" />
      </label>

      <label class="email">
        <span>Email:</span>
        <input type="text" id="email" placeholder="Email">
      </label>

      <p>
        <input type="submit" id="register-submit-button" value="Register &rarr;"/>
      </p>
    </fieldset>
  </form>
</div>
<img class="leftlogo" src="_static/OpenDSALogoT64.png" alt="Logo"/><div class="title-wrapper">
          <div class="title-inbetween" style="display: table-cell; vertical-align: middle;">
            <div class="title-content">
              <h1 class="heading" ><a href="index.html">
                <span>BM40A1500 Data Structures and Algorithms</span></a></h1>
              <h2 class="heading" ><span>Chapter 5 Algorithm Design Principles</span></h2>
            </div>
          </div>
        </div>
      </div>
      <div class="topnav">
        <p>
            <a style="float:left;color:blue;" href="../source/DynamicProgramming.rst.rst"
              target="_blank" rel="nofollow">Show Source | </a>&#160;&#160;
            <a class="abt" style="float:left;color:blue;" href="#" rel="nofollow">| About</a>&#160;&#160;

          
        «&#160;&#160;<a id="prevmod" href="Backtracking.html">5.<span class="section-number">5. </span>Backtracking, and Branch and Bound</a>
        &#160;&#160;::&#160;&#160;
        <a  class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a  id="nextmod" href="Probabilistic.html">5.<span class="section-number">7. </span>Introduction to Probabilistic Algorithms</a>&#160;&#160;»


        </p>
      </div>
       
      <div class="content">
        
  <script>ODSA.SETTINGS.MODULE_SECTIONS = ['computing-fibonacci-numbers', 'the-knapsack-problem', 'chained-matrix-multiplication'];</script><script>ODSA.SETTINGS.DISP_MOD_COMP = true;ODSA.SETTINGS.MODULE_NAME = "DynamicProgramming";ODSA.SETTINGS.MODULE_LONG_NAME = "Dynamic Programming";ODSA.SETTINGS.MODULE_CHAPTER = "Algorithm Design Principles"; ODSA.SETTINGS.BUILD_DATE = "2024-08-13 08:46:36"; ODSA.SETTINGS.BUILD_CMAP = false;JSAV_OPTIONS['lang']='en';JSAV_EXERCISE_OPTIONS['code']='python';</script><link href="../../..//AV/SeniorAlgAnal/FibTreeCON.css" rel="stylesheet" type="text/css" />
<link href="../../..//AV/SeniorAlgAnal/FibGraphCON.css" rel="stylesheet" type="text/css" />
<link href="../../..//AV/SeniorAlgAnal/KnapTreeCON.css" rel="stylesheet" type="text/css" />
<link href="../../..//AV/SeniorAlgAnal/KnapGraphCON.css" rel="stylesheet" type="text/css" />
<link href="../../..//AV/SeniorAlgAnal/MatMulCON.css" rel="stylesheet" type="text/css" />
<div class="section" id="dynamic-programming">
<h1>5.<span class="section-number">6. </span>Dynamic Programming<a class="headerlink" href="#dynamic-programming" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>5.<span class="section-number">6.1. </span>Dynamic Programming<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Dynamic programming is an algorithm design technique that can improve
the efficiency of any inherently recursive algorithm that repeatedly
re-solves the same subproblems.
Using dynamic programming requires two steps:</p>
<ol class="arabic simple">
<li><p>You find a recursive solution to a problem where subproblems are
redundantly solved many times.</p></li>
<li><p>Optimize the recursive algorithm to eliminate re-solving
subproblems.
The resulting algorithm may be recursive or iterative.
The iterative form is commonly referred to by the term dynamic
programming.</p></li>
</ol>
<p>We will see first how to remove redundancy with a simple problem,
computing Fibonacci numbers.
Then we introduce the knapsack problem, and show how it can be
solved efficiently with dynamic programming.</p>
</div>
<div class="section" id="computing-fibonacci-numbers">
<h2>5.<span class="section-number">6.2. </span>Computing Fibonacci Numbers<a class="headerlink" href="#computing-fibonacci-numbers" title="Permalink to this headline">¶</a></h2>
<p>Consider the recursive function for computing the <span class="math notranslate nohighlight">\(n\)</span>’th
Fibonacci number.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Recursively generates and returns the n&#39;th Fibonacci number</span>
<span class="k">def</span> <span class="nf">fibr</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>            <span class="c1"># Base case</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">fibr</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibr</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>    <span class="c1"># Recursive call</span>
</pre></div>
</div>
<p>The cost of this recursive algorithm (in terms of function calls) is
the size of the <span class="math notranslate nohighlight">\(n\)</span>’th Fibonacci number itself, which is
exponential on <span class="math notranslate nohighlight">\(n\)</span> (approximately <span class="math notranslate nohighlight">\(1.62^n\)</span> ).
Why is this so expensive?
Primarily because two recursive calls are made by the
function, and the work that they do is largely redundant.
That is, each of the two calls is recomputing most of the series, as
is each sub-call, and so on.
Thus, the smaller values of the function are being recomputed a huge
number of times.
If we could eliminate this redundancy, the cost would be greatly
reduced.
The approach that we will use can also improve any algorithm that
spends most of its time recomputing common subproblems.</p>
<p>The following slideshow explains the redundancy problem.</p>
<div id="FibTreeCON" class="ssAV" data-points="0.0" data-threshold="1.0" data-type="ss" data-required="False" data-short-name="FibTreeCON" data-long-name="FibTreeCON" data-exer-id="" alt="FibTreeCON" tabIndex="-1">
 <span class="jsavcounter"></span>
 <a class="jsavsettings" href="#">Settings</a>
 <div class="jsavcontrols"></div>
 <p class="jsavoutput jsavline"></p>
 <div class="jsavcanvas"></div>
 <div class="prof_indicators">
  <img id="FibTreeCON_check_mark" class="prof_check_mark" src="_static/Images/green_check.png" alt="Proficient" />
  <span id="FibTreeCON_cm_saving_msg" class="cm_saving_msg">Saving...</span>
  <span id="FibTreeCON_cm_error_msg" class="cm_error_msg">
   <img id="FibTreeCON_cm_warning_icon" class="cm_warning_icon" src="_static/Images/warning.png" alt="Error Saving" /><br />
   Server Error<br />
   <a href="#" class="resubmit_link">Resubmit</a>
  </span>
 </div>
</div>
<p></p>
<p>Looking at the final tree, we see that there are only seven unique
subproblems to solve (for Fibonacci values 0 through 6).
The graphical representation below is called a dependency graph, and
shows the dependencies for the subproblems.</p>
<div class="divdgm">
<div id="FibGraphCON">
</div>
</div>
<p>Note that the dependency graph was laid out on in a one dimensional
table of size seven, corresponding to the unique subproblems invoked
by the algorithm.
This table can simply store the value of each subproblem.
In this way, redundant calls can be avoided because the value of a
subproblem which was previously computed can be read from its
corresponding cell in the table without the need to recompute it
again.</p>
<p>The table can be used to derive two alternative, but efficient,
algorithms.
One way to accomplish this goal is to keep a table of values, and
first check the table to see if the computation can be avoided.
This technique is called <span class="xref std std-term">memoization</span>.
Here is a straightforward example of doing so.
Note that it mirrors the original version of the Fibonacci recursive
algorithm.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fibrt</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="c1"># Assume Values has at least n slots,</span>
    <span class="c1"># and all slots are initialized to 0</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>                              <span class="c1"># Base case</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">Values</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">Values</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">fibrt</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibrt</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># Recursive call</span>
    <span class="k">return</span> <span class="n">Values</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>    
</pre></div>
</div>
<p>This version of the algorithm will not compute a value more than once,
so its cost is linear.
The corresponding recursion tree is shown below.
Note that the first occurrence of each recursive call invokes
two recursive calls.
However, subsequent occurrences of such a call do
not produce additional calls because they just read the contents of
its corresponding cell.</p>
<p>A second technique is called <span class="xref std std-term">tabulation</span>.
The dependency graph must be analyzed to infer an alternative
computation order for the subproblems.
The only restriction is that a subproblem can only be
computed when the subproblems it depends on have been computed.
In addition, the value of each subproblem must be stored in the table.
In the case of computing a value in the Fibonacci series,
we reverse the order to calculate the series from the starting point,
and implement this  by a simple loop.
Unfortunately, since it does not have any similarity to the original
recursive algorithm, there is no mechanical way to get from the
original recursive form to the dynamic programming form.</p>
<p>An additional optimization can be made.
Of course, we didn’t actually need to use a table storing all of the
values, since future computations do not need access to all prior
subproblems.
Instead, we could build the value by working from 0 and 1 up to
<span class="math notranslate nohighlight">\(n\)</span> rather than backwards from <span class="math notranslate nohighlight">\(n\)</span> down to 0 and 1.
Going up from the bottom we only need to store the previous two values
of the function, as is done by our iterative version.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fibi</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">curr</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">past</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>      <span class="c1"># curr holds current Fib value </span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>         <span class="c1"># Compute next value</span>
        <span class="n">past</span> <span class="o">=</span> <span class="n">prev</span>                 <span class="c1"># past holds fibi(i-2)</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span>                 <span class="c1"># prev holfd fibi(i-1)</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">past</span> <span class="o">+</span> <span class="n">prev</span>          <span class="c1"># curr now holds fibi(i)</span>
    <span class="k">return</span> <span class="n">curr</span>
</pre></div>
</div>
<p>Recomputing of subproblems comes up in many algorithms.
It is not so common that we can store only a few prior results as we
did for <code class="docutils literal notranslate"><span class="pre">fibi</span></code>.
Thus, there are many times where storing a complete table of
subresults will be useful.</p>
<p>The approach shown above to designing an algorithm that works by
storing a table of results for subproblems is called
<a class="reference internal" href="Glossary.html#term-dynamic-programming"><span class="xref std std-term">dynamic programming</span></a> when it is applied to optimization
algorithms.
The name is somewhat arcane, because it doesn’t bear much obvious
similarity to the process that is taking place when storing subproblems
in a table.
However, it comes originally from the field of dynamic control
systems, which got its start before what we think of as computer
programming.
The act of storing precomputed values in a table for later reuse is
referred to as “programming” in that field.
Dynamic programming algorithms are usually implemented with the
tabulation technique described above.
Thus, <code class="docutils literal notranslate"><span class="pre">fibi</span></code> better represents the most common form of dynamic
programming than does <code class="docutils literal notranslate"><span class="pre">fibrt</span></code>, even though it doesn’t use the
complete table.</p>
</div>
<div class="section" id="the-knapsack-problem">
<h2>5.<span class="section-number">6.3. </span>The Knapsack Problem<a class="headerlink" href="#the-knapsack-problem" title="Permalink to this headline">¶</a></h2>
<p>We will next consider a problem that appears with many variations in a
variety of commercial settings.
Many businesses need to package items with the greatest efficiency.
One way to describe this basic idea is in terms of packing items into
a knapsack, and so we will refer to this as the
<a class="reference internal" href="Glossary.html#term-knapsack-problem"><span class="xref std std-term">Knapsack Problem</span></a>.
We will first define a particular formulation of the knapsack problem,
and then we will discuss an algorithm to solve it based on dynamic
programming.
There are many other versions for the problem.
Some versions ask for the greatest amount that will fit, others
introduce values to the items along with size.
We will look at a fairly easy to understand variation.</p>
<p>Assume that we have a knapsack with a certain amount of space that we
will define using integer value <span class="math notranslate nohighlight">\(K\)</span>.
We also have <span class="math notranslate nohighlight">\(n\)</span> items each with a certain size such that
that item <span class="math notranslate nohighlight">\(i\)</span> has integer size <span class="math notranslate nohighlight">\(k_i\)</span>.
The problem is to find a subset of the <span class="math notranslate nohighlight">\(n\)</span> items whose sizes
exactly sum to <span class="math notranslate nohighlight">\(K\)</span>, if one exists.
For example, if our knapsack has capacity <span class="math notranslate nohighlight">\(K = 5\)</span> and the two
items are of size <span class="math notranslate nohighlight">\(k_1 = 2\)</span> and <span class="math notranslate nohighlight">\(k_2 = 4\)</span>,
then no such subset exists.
But if we add a third item of size <span class="math notranslate nohighlight">\(k_3 = 1\)</span>,
then we can fill the knapsack exactly with the second and third
items.
We can define the problem more formally as:
Find <span class="math notranslate nohighlight">\(S \subset \{1, 2, ..., n\}\)</span> such that</p>
<div class="math notranslate nohighlight">
\[\sum_{i \in S} k_i = K.\]</div>
<div class="topic">
<p class="topic-title">Example 5.6.1 </p>
<p>Assume that we are given a knapsack of size <span class="math notranslate nohighlight">\(K = 163\)</span> and
10 items of sizes 4, 9, 15, 19, 27, 44, 54, 68, 73, 101.
Can we find a subset of the items that exactly fills the knapsack?
You should take a few minutes and try to do this before reading on
and looking at the answer.</p>
<p>One solution to the problem is: 19, 27, 44, 73.</p>
</div>
<div class="topic">
<p class="topic-title">Example 5.6.2 </p>
<p>Having solved the previous example for knapsack of size 163, how
hard is it now to solve for a knapsack of size 164?
Try it.</p>
<p>Unfortunately, knowing the answer for 163 is of almost no use at
all when solving for 164.
One solution is: 9, 54, 101.</p>
</div>
<p>If you tried solving these examples, you probably found yourself doing
a lot of trial-and-error and a lot of backtracking.
To come up with an algorithm, we want an organized way to go through
the possible subsets.
Is there a way to make the problem smaller, so that we can apply
recursion?
We essentially have two parts to the input: The knapsack size
<span class="math notranslate nohighlight">\(K\)</span> and the <span class="math notranslate nohighlight">\(n\)</span> items.
It probably will not do us much good to try and break the knapsack
into pieces and solve the sub-pieces (since we already saw that
knowing the answer for a knapsack of size 163 did nothing to help us
solve the problem for a knapsack of size 164).</p>
<p>So, what can we say about solving the problem with or without the
<span class="math notranslate nohighlight">\(n\)</span>’th item?
This seems to lead to a way to break down the problem.
If the <span class="math notranslate nohighlight">\(n\)</span>’th item is not needed for a solution (that is, if we
can solve the problem with the first <span class="math notranslate nohighlight">\(n-1\)</span> items) then we can
also solve the problem when the <span class="math notranslate nohighlight">\(n\)</span>’th item is available
(we just ignore it).
On the other hand, if we do include the <span class="math notranslate nohighlight">\(n\)</span>’th item as a member
of the solution subset, then we now would need to solve the problem
with the first <span class="math notranslate nohighlight">\(n-1\)</span> items and a knapsack of size
<span class="math notranslate nohighlight">\(K - k_n\)</span> (since the <span class="math notranslate nohighlight">\(n\)</span>’th
item is taking up <span class="math notranslate nohighlight">\(k_n\)</span> space in the knapsack).</p>
<p>To organize this process, we can define the problem in terms of
two parameters: the knapsack size <span class="math notranslate nohighlight">\(K\)</span> and the number of items
<span class="math notranslate nohighlight">\(n\)</span>.
Denote a given instance of the problem as <span class="math notranslate nohighlight">\(P(n, K)\)</span>.
Now we can say that <span class="math notranslate nohighlight">\(P(n, K)\)</span> has a solution if and only if
there exists a solution for either <span class="math notranslate nohighlight">\(P(n-1, K)\)</span> or
<span class="math notranslate nohighlight">\(P(n-1, K-k_n)\)</span>.
That is, we can solve <span class="math notranslate nohighlight">\(P(n, K)\)</span> only if we can solve one of the
sub problems where we use or do not use the <span class="math notranslate nohighlight">\(n\)</span> th item.
Of course, the ordering of the items is arbitrary.
We just need to give them some order to keep things straight.</p>
<p>Continuing this idea, to solve any subproblem of size <span class="math notranslate nohighlight">\(n-1\)</span>,
we need only to solve two subproblems of size <span class="math notranslate nohighlight">\(n-2\)</span>.
And so on, until we are down to only one item that either fills the
knapsack or not.</p>
<p>Continuing this idea, to solve any subproblem of size <span class="math notranslate nohighlight">\(n-1\)</span>,
we need only to solve two subproblems of size <span class="math notranslate nohighlight">\(n-2\)</span>.
And so on, until we are down to only one item that either fits the
knapsack or not.
Assuming that <span class="math notranslate nohighlight">\(P(i, S)\)</span> represents the problem for object i and
after, and with size s still free in the knapsack, the following
algorithm expresses the ideas.</p>
<div class="line-block">
<div class="line"><strong>if</strong> <span class="math notranslate nohighlight">\(P(n-1, K)\)</span> has a solution,</div>
<div class="line-block">
<div class="line"><strong>then</strong> <span class="math notranslate nohighlight">\(P(n, K)\)</span> has a solution</div>
<div class="line"><strong>else if</strong> <span class="math notranslate nohighlight">\(P(n-1, K-k_n)\)</span> has a solution</div>
<div class="line-block">
<div class="line"><strong>then</strong> <span class="math notranslate nohighlight">\(P(n, K)\)</span> has a solution</div>
<div class="line"><strong>else</strong> <span class="math notranslate nohighlight">\(P(n, K)\)</span> has no solution.</div>
</div>
</div>
</div>
<p>Although this algorithm is correct, it naturally leads to a cost
expressed by the recurrence relation
<span class="math notranslate nohighlight">\(\mathbf{T}(n) = 2\mathbf{T}(n-1) + c = \Theta(2^n)\)</span>.
That can be pretty expensive!</p>
<p>But… we should quickly realize that there are only <span class="math notranslate nohighlight">\(n(K+1)\)</span>
subproblems to solve!
Clearly, there is the possibility that many subproblems are being
solved repeatedly.
This is a natural opportunity to apply dynamic programming.
If we draw the recursion tree of this naive recursive algorithm and
derive its corresponding dependency graph, we notice that all the
recursive calls can be laid out on
an array of size <span class="math notranslate nohighlight">\(n \times K+1\)</span> to contain the
solutions for all subproblems
<span class="math notranslate nohighlight">\(P(i, k), 0 \leq i \leq n-1, 0 \leq k \leq K\)</span>.</p>
<div class="topic">
<p class="topic-title">Example 5.6.3 </p>
<p>Consider the instance of the Knapsack Problem for <span class="math notranslate nohighlight">\(K=10\)</span> and five items
with sizes 9, 2, 7, 4, 1.
The recursion tree generated by the recursive algorithm follows, where
each node contains the index of the object under consideration (from 0
to 4) and the size available of the knapsack.</p>
<div id="KnapTreeCON" class="ssAV" data-points="0" data-threshold="1.0" data-type="ss" data-required="False" data-short-name="KnapTreeCON" data-long-name="KnapTreeCON" data-exer-id="" alt="KnapTreeCON" tabIndex="-1">
 <span class="jsavcounter"></span>
 <a class="jsavsettings" href="#">Settings</a>
 <div class="jsavcontrols"></div>
 <p class="jsavoutput jsavline"></p>
 <div class="jsavcanvas"></div>
 <div class="prof_indicators">
  <img id="KnapTreeCON_check_mark" class="prof_check_mark" src="_static/Images/green_check.png" alt="Proficient" />
  <span id="KnapTreeCON_cm_saving_msg" class="cm_saving_msg">Saving...</span>
  <span id="KnapTreeCON_cm_error_msg" class="cm_error_msg">
   <img id="KnapTreeCON_cm_warning_icon" class="cm_warning_icon" src="_static/Images/warning.png" alt="Error Saving" /><br />
   Server Error<br />
   <a href="#" class="resubmit_link">Resubmit</a>
  </span>
 </div>
</div>
<p></p>
<p>The dependency graph for this problem instance, laid out in a table of
size <span class="math notranslate nohighlight">\(n × K + 1\)</span>, follows:</p>
</div>
<div class="divdgm">
<div id="KnapGraphCON">
</div>
</div>
<p>As mentioned above, there are two approaches to actually solving the
problem.
One is memoization, that is, to start with our problem of size
<span class="math notranslate nohighlight">\(P(n, K)\)</span> and make recursive calls to solve the subproblems,
each time checking the array
to see if a subproblem has been solved, and filling in the
corresponding cell in the array whenever we get a new subproblem
solution.
The other is tabulation.
Conceivably we could adopt one of several computation orders,
although the most “natural” is to start filling the array for row 0
(which indicates a successful solution only for a knapsack of size
<span class="math notranslate nohighlight">\(k_0\)</span>).
We then fill in the succeeding rows
from <span class="math notranslate nohighlight">\(i=1\)</span> to <span class="math notranslate nohighlight">\(n\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">knapsack</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
    <span class="n">table</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">))]</span>
    <span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;O&quot;</span>           <span class="c1"># OMIT</span>
    <span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;I&quot;</span>    <span class="c1"># INCLUDE</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)):</span>
        <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;O&quot;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">k</span> <span class="o">-</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>        
                <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="s2">&quot;I&quot;</span>
            <span class="k">if</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="s2">&quot;O&quot;</span>
    <span class="k">return</span> <span class="n">table</span>
</pre></div>
</div>
<p>In other words, a new slot in the array gets its solution by looking
at most at two slots in the preceding row.
Since filling each slot in the array takes constant time, the total
cost of the algorithm is <span class="math notranslate nohighlight">\(\Theta(nK)\)</span>.</p>
<div class="topic">
<p class="topic-title">Example 5.6.4 </p>
<p>Consider again the instance of the Knapsack Problem for K=10 and
five items with sizes 9, 2, 7, 4, 1.
A tabulation algorithm will fill a table of size n×K+1 starting
from object i=0 up to object i=4, filling all the cells in the
table in a top-down fashion.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{l|ccccccccccc}
&amp;0&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10\\
\hline
k_0\!=\!9&amp;O&amp;-&amp;-&amp;-&amp;-&amp;-&amp;-&amp;-&amp;-&amp;I&amp;\\
k_1\!=\!2&amp;O&amp;-&amp;I&amp;-&amp;-&amp;-&amp;-&amp;-&amp;-&amp;O&amp;-\\
k_2\!=\!7&amp;O&amp;-&amp;O&amp;-&amp;-&amp;-&amp;-&amp;I&amp;-&amp;I/O&amp;-\\
k_3\!=\!4&amp;O&amp;-&amp;O&amp;-&amp;I&amp;-&amp;I&amp;O&amp;-&amp;O&amp;-\\
k_4\!=\!1&amp;O&amp;I&amp;O&amp;I&amp;O&amp;I&amp;O&amp;I/O&amp;I&amp;O&amp;I
\end{array}\end{split}\]</div>
<div class="line-block">
<div class="line">Key:</div>
<div class="line-block">
<div class="line">-:  No solution for <span class="math notranslate nohighlight">\(P(i, k)\)</span>.</div>
<div class="line">O: Solution(s) for <span class="math notranslate nohighlight">\(P(i, k)\)</span> with <span class="math notranslate nohighlight">\(i\)</span> omitted.</div>
<div class="line">I: Solution(s) for <span class="math notranslate nohighlight">\(P(i, k)\)</span> with <span class="math notranslate nohighlight">\(i\)</span> included.</div>
<div class="line">I/O: Solutions for <span class="math notranslate nohighlight">\(P(i, k)\)</span> with <span class="math notranslate nohighlight">\(i\)</span> included AND omitted.</div>
</div>
</div>
<p>For example, <span class="math notranslate nohighlight">\(P(2, 9)\)</span> stores value I/O.
It contains O because <span class="math notranslate nohighlight">\(P(1, 9)\)</span> has a solution (so, this item
is not needed along that path).
It contains I because <span class="math notranslate nohighlight">\(P(1,2) = P(1, 9-7)\)</span> has a solution
(so, this item is needed along that path).
Since <span class="math notranslate nohighlight">\(P(4, 10)\)</span> is marked with I, it has a solution.
We can determine what that solution actually is by recognizing that
it includes <span class="math notranslate nohighlight">\(k_4\)</span> (of size 1), which then leads us to look at
the solution for <span class="math notranslate nohighlight">\(P(3, 9)\)</span>.
This in turn has a solution that omits <span class="math notranslate nohighlight">\(k_3\)</span> (of size 4),
leading us to <span class="math notranslate nohighlight">\(P(2, 9)\)</span>.
At this point, we can either use item <span class="math notranslate nohighlight">\(k_2\)</span> or not.
We can find a solution by taking one valid path through the table.
We can find all solutions by following all branches when there is a
choice.</p>
<p>Note that the table is first filled with the values of the
different subproblems, and later we inferred the sequence of
decisions that allows computing an optimal solution from the values
stored in the table.
This last phase of the algorithm precludes the possibility of
actually reducing the size of the table.
Otherwise, the table for the knapsack problem could have been
reduced to a one dimensional array.</p>
</div>
</div>
<div class="section" id="chained-matrix-multiplication">
<h2>5.<span class="section-number">6.4. </span>Chained Matrix Multiplication<a class="headerlink" href="#chained-matrix-multiplication" title="Permalink to this headline">¶</a></h2>
<p>Many engineering problems require multiplying a lot of matrices.
Sometimes really large matrices.
It turns out to make a big difference in which order we do the
computation.</p>
<p>First, let’s recall the basics.
If we have two matrices (on of <span class="math notranslate nohighlight">\(r\)</span> rows and
<span class="math notranslate nohighlight">\(s\)</span> columns, and the other of <span class="math notranslate nohighlight">\(s\)</span> rows and <span class="math notranslate nohighlight">\(t\)</span>
columns), then the result will be a matrix of
<span class="math notranslate nohighlight">\(r\)</span> rows and <span class="math notranslate nohighlight">\(t\)</span> columns.
What we really care about is that the cost of the matrix
multiplication is dominated by the number of terms that have to be
multipled together.
Here, it would be a total cost of <span class="math notranslate nohighlight">\(r \times s \times t\)</span>
multiplications (plus some additions that we will ignore since the
time is dominated by the multiplications).</p>
<p>The other thing to realize is this: Of course it matters whether we
multiply <span class="math notranslate nohighlight">\(A \times B\)</span> or <span class="math notranslate nohighlight">\(B \times A\)</span>.
But let’s assume that we already have determined the order that they go
in (that it should be <span class="math notranslate nohighlight">\(A \times B\)</span>
But we still have choices to make if there are many matrices to
multiply together
The thing that we need to consider is this:
If we want to multiply three matrices, and we know the order, we still
have a choice of how to group them.
In other words, we can multiply three matrices as either
<span class="math notranslate nohighlight">\(A(BC)\)</span> or <span class="math notranslate nohighlight">\((AB)C\)</span>, and the answer will be the same in the
end.
However, as we see below, it can matter a lot which way we do this in
terms of the cost of getting that answer.</p>
<div id="MatMulCON" class="ssAV" data-points="0.0" data-threshold="1.0" data-type="ss" data-required="False" data-short-name="MatMulCON" data-long-name="MatMulCON" data-exer-id="" alt="MatMulCON" tabIndex="-1">
 <span class="jsavcounter"></span>
 <a class="jsavsettings" href="#">Settings</a>
 <div class="jsavcontrols"></div>
 <p class="jsavoutput jsavline"></p>
 <div class="jsavcanvas"></div>
 <div class="prof_indicators">
  <img id="MatMulCON_check_mark" class="prof_check_mark" src="_static/Images/green_check.png" alt="Proficient" />
  <span id="MatMulCON_cm_saving_msg" class="cm_saving_msg">Saving...</span>
  <span id="MatMulCON_cm_error_msg" class="cm_error_msg">
   <img id="MatMulCON_cm_warning_icon" class="cm_warning_icon" src="_static/Images/warning.png" alt="Error Saving" /><br />
   Server Error<br />
   <a href="#" class="resubmit_link">Resubmit</a>
  </span>
 </div>
</div>
<p></p>
<p>To solve this problem efficiently (of how to group the order of the
multiplications), we should notice that there are a lot of duplicate
nodes in the recursion tree.
But there are only a relatively limited number of actual subproblems
to solve.
For instance, we repeatedly need to decide the best order to multiply
ABC.
And to solve that, we repeatedly compute AB’s cost, and BC’s cost.
One way to speed this up is simply to remember the answers whenever we
compute them.
This is called memoization.
Whenever we ask the question again, we simply use the stored result.
This implies that we have a good way to remember where to store them,
that is, how to organize the subproblems to easily check if the
problem has already been solved.</p>
<p>So, how do we organize the subproblems when there are <span class="math notranslate nohighlight">\(n\)</span>
matrices to multiply, labeled 1 to <span class="math notranslate nohighlight">\(n\)</span>?
One way is to use a table of size <span class="math notranslate nohighlight">\(n \times n\)</span>.
In this table, the entry at <span class="math notranslate nohighlight">\([i, j]\)</span> is the cost for the best
solution of multiplying matrices <span class="math notranslate nohighlight">\(i\)</span> to <span class="math notranslate nohighlight">\(j\)</span>.
So, the upper left corner (entry <span class="math notranslate nohighlight">\([1, n]\)</span>) is the full solution.
Entries on the main diagonal are simply a single matrix (no
multiplication).
Only the upper left triangle has entries (since there is no meaning to
the cost for multiplying matrix 5 through matrix 3, only for
multiplying matrix 3 through matrix 5).</p>
<p>Now, when we need to compute a series of matrices from <span class="math notranslate nohighlight">\(i\)</span> to
<span class="math notranslate nohighlight">\(j\)</span>, we just look in position <span class="math notranslate nohighlight">\([i, j]\)</span> in the table. If
there is an answer there, we use it.
Otherwise, we do the computation, and note it in the table.</p>
<script type="text/javascript" src="../../..//AV/SeniorAlgAnal/FibTreeCON.js"></script>
<script type="text/javascript" src="../../..//AV/SeniorAlgAnal/FibGraphCON.js"></script>
<script type="text/javascript" src="../../..//AV/SeniorAlgAnal/KnapTreeCON.js"></script>
<script type="text/javascript" src="../../..//AV/SeniorAlgAnal/KnapGraphCON.js"></script>
<script type="text/javascript" src="../../..//AV/SeniorAlgAnal/MatMulCON.js"></script>
</div>
</div>


      </div>
      <div class="bottomnav">
      <p><span class="email_div" style="display:inline;"><a id="contact_us" class="contact" style="float:left;color:blue;" rel="nofollow" href="mailto:">Contact Us |</a><a style="float:left;color:blue;" rel="nofollow" href="../../../lib/Privacy.html" target="_blank">| Privacy |</a> <a style="float:left;color:blue;" rel="nofollow" href="../../../lib/license.html" target="_blank">| License</a></span>&#160;&#160;
      
        «&#160;&#160;<a id="prevmod1" href="Backtracking.html">5.<span class="section-number">5. </span>Backtracking, and Branch and Bound</a>
        &#160;&#160;::&#160;&#160;
        <a  class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a  id="nextmod1" href="Probabilistic.html">5.<span class="section-number">7. </span>Introduction to Probabilistic Algorithms</a>&#160;&#160;»

</p>
      </div>
      <img style="float:right;" src="_static/nsf1.gif" height="62" width="62" alt="nsf"/>


    <div class="footer">
      <p>
        <span class="email_div" style="display:inline;">
          <a id="contact_us" class="contact" style="float:left;color:blue;" rel="nofollow" href="mailto:">Contact Us |</a>
          <a id="bugreport-link" style="float:left;color:blue;" class="bugreport-link" href="#">| Report a bug</a>
        </span>
      </p>
        &copy; Copyright 2011-2023 by OpenDSA Project Contributors and distributed under an MIT license.
      Last updated on Aug 13, 2024.
      Created using <a target="_blank" href="http://sphinx.pocoo.org/">Sphinx</a> 4.4.0.
    </div>
    
<div id="bugreport-box" class="bugreport-popup ">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close Window" /></a>
  <form method="post" class="report" action="https://#">
    <fieldset class="textbox">
      <div id="bug_error" class="error"></div>
      <label>
        <span>Summary*:</span>
        <input type="text" id="b_title" placeholder="Summary" />
      </label>

      <label class="os">
        <span>Operating system*:</span>
        <select id="b_os">
          <option value="windows">Windows</option>
          <option value="macos">Mac OS</option>
          <option value="linux">Linux</option>
          <option value="ios">iOS</option>
          <option value="android">Android</option>
          <option value="other">Other</option>
        </select>
      </label>

      <label class="browser">
        <span>Browser*:</span>
        <select id="b_browser">
          <option value="chrome">Chrome</option>
          <option value="safari">Safari</option>
          <option value="internetexplorer">Internet Explorer</option>
          <option value="opera">Opera</option>
          <option value="other">Other</option>
        </select>
      </label>

      <label class="description">
        <span>Description*:</span><br>
        <textarea id="b_description" rows="5" cols="25" placeholder="***BUG** Please enter: (1) a consice description of the problem. (2) steps to reproduce bug. (3) the version of your browser and operating system."></textarea>
      </label>

      <label class="screenshot">
        <span>Attach a screenshot (optional):</span>
        <input type="file" id="b_screenshot" accept="image/*" placeholder="Attach a screenshot (optional)">
      </label>

      <p>
        <input type="submit" id="bug-submit-button" value="Submit &rarr;"/>
      </p>
    </fieldset>
  </form>
</div>

  </body>
</html>