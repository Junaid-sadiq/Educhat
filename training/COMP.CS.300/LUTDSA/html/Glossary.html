
<!DOCTYPE html>




<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>8.1. Glossary &mdash; BM40A1500 Data Structures and Algorithms</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/normalize.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/JSAV.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/odsaMOD-min.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/jquery.ui.min.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/odsaStyle-min.css" type="text/css" />
    
  <script type="text/javascript">
    var DOCUMENTATION_OPTIONS = {
      URL_ROOT:    './',
      VERSION:     '0.4.1',
      COLLAPSE_INDEX: false,
      FILE_SUFFIX: '.html',
      HAS_SOURCE:  true
    };
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      },
      "HTML-CSS": {
        scale: "80"
      }
    });
  </script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="index" title="BM40A1500 Data Structures and Algorithms" href="index.html" />
    <link rel="prev" title="6. Coping with NP-Complete Problems" href="NPCoping.html" />

  </head>

  <body>


      <div class="header">
        
  
      <script type="text/javascript" src="../../../lib/jquery.min.js"></script>
      <script type="text/javascript" src="../../../lib/jquery.migrate.min.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.9.0/localforage.min.js"></script>
    <script type="text/javascript" src="../../../lib/jquery.ui.min.js"></script>
    <script type="text/javascript" src="../../../lib/jquery.transit.js"></script>
    <script type="text/javascript" src="../../../lib/raphael.js"></script>
    <script type="text/javascript" src="../../../lib/JSAV-min.js"></script>
    <script type="text/javascript" src="_static/config.js"></script>
    <script type="text/javascript" src="../../../lib/timeme-min.js"></script>
    <script type="text/javascript" src="../../../lib/odsaUtils-min.js"></script>
    <script type="text/javascript" src="../../../lib/odsaMOD-min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.13.0/d3.min.js"></script>
    <script type="text/javascript" src="https://d3js.org/d3-selection-multi.v1.min.js"></script>
    <script type="text/javascript" src="../../../lib/dataStructures.js"></script>
    <script type="text/javascript" src="../../../lib/conceptMap.js"></script>

        
<a id="username-link" style="float:right;color:red;margin:10px 20px auto; display: none" class="username-link" href="Gradebook.html"></a>
<a id="login-link" style="float:right;color:red;margin:10px 20px auto" class="login-link" href="#"><Macro 'login'></a>
<div id="login-box" class="login-popup">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close" /></a>
  <form method="post" class="signin" action="https://#">
    <fieldset class="textbox">
      <label class="username">
        <span>Username</span>
        <input id="username" value="" type="text" autocomplete="on" placeholder="Username" tabindex="1">
      </label>
      <label class="password">
        <span>Password</span>
        <input id="password" value="" type="password" placeholder="Password" tabindex="2">
        <span><a id="forgot" href="#">Forgot your password?</a></span>
      </label>

      <p>
        <input type="submit" id="login-submit-button" value="Sign in" tabindex="3" />
      </p>
      <p>
        <input type="button" id="register-button" value="Register" tabindex="4" />
      </p>
    </fieldset>
  </form>
</div>

        
<a id="registration-link" style="float:right;color:red;margin:10px 20px auto" class="registration-link" href="#">Register</a>
<div id="registration-box" class="registration-popup ">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close Window" /></a>
  <form method="post" class="signin" action="https://#">
    <fieldset class="textbox">
      <div id="register_error" class="error"></div>
      <label class="username">
        <span>Username:</span>
        <input type="text" id="user" placeholder="Username" />
      </label>

      <label class="password">
        <span>Password</span>
        <input id="pass" type="password" placeholder="Password" />
      </label>

      <label class="password">
        <span>Confirm Password</span>
        <input id="rpass" type="password" placeholder="Confirm Password" />
      </label>

      <label class="email">
        <span>Email:</span>
        <input type="text" id="email" placeholder="Email">
      </label>

      <p>
        <input type="submit" id="register-submit-button" value="Register &rarr;"/>
      </p>
    </fieldset>
  </form>
</div>
<img class="leftlogo" src="_static/OpenDSALogoT64.png" alt="Logo"/><div class="title-wrapper">
          <div class="title-inbetween" style="display: table-cell; vertical-align: middle;">
            <div class="title-content">
              <h1 class="heading" ><a href="index.html">
                <span>BM40A1500 Data Structures and Algorithms</span></a></h1>
              <h2 class="heading" ><span>Chapter 8 Appendix</span></h2>
            </div>
          </div>
        </div>
      </div>
      <div class="topnav">
        <p>
            <a style="float:left;color:blue;" href="../source/Glossary.rst.rst"
              target="_blank" rel="nofollow">Show Source | </a>&#160;&#160;
            <a class="abt" style="float:left;color:blue;" href="#" rel="nofollow">| About</a>&#160;&#160;

          
        «&#160;&#160;<a id="prevmod" href="NPCoping.html">7.<span class="section-number">6. </span>Coping with NP-Complete Problems</a>
        &#160;&#160;::&#160;&#160;
        <a  class="uplink" href="index.html">Contents</a>


        </p>
      </div>
       
      <div class="content">
        
  <script>ODSA.SETTINGS.MODULE_SECTIONS = [];</script><script>ODSA.SETTINGS.DISP_MOD_COMP = true;ODSA.SETTINGS.MODULE_NAME = "Glossary";ODSA.SETTINGS.MODULE_LONG_NAME = "Glossary";ODSA.SETTINGS.MODULE_CHAPTER = "Appendix"; ODSA.SETTINGS.BUILD_DATE = "2024-08-13 08:46:36"; ODSA.SETTINGS.BUILD_CMAP = false;JSAV_OPTIONS['lang']='en';JSAV_EXERCISE_OPTIONS['code']='python';</script><div class="section" id="id1">
<h1>8.<span class="section-number">1. </span>Glossary<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<dl class="glossary">
<dt id="term-2-3-tree">2-3 tree<a class="headerlink" href="#term-2-3-tree" title="Permalink to this term">¶</a></dt><dd><p>A specialized form of the <a class="reference internal" href="#term-1"><span class="xref std std-term">B-tree</span></a> where each internal
node has either 2 children or 3 children.
Key values are ordered to maintain the
<a class="reference internal" href="#term-binary-search-tree-property"><span class="xref std std-term">binary search tree property</span></a>.
The 2-3 tree is always height balanced, and its insert, search,
and remove operations all have <span class="math notranslate nohighlight">\(\Theta(\log n)\)</span> cost.</p>
</dd>
<dt id="term-80-20-rule">80/20 rule<a class="headerlink" href="#term-80-20-rule" title="Permalink to this term">¶</a></dt><dd><p>Given a typical application where there is a collection of
records and a series of search operations for records,
the 80/20 rule is an empirical observation that
80% of the record accessess typically go to 20% of the records.
The exact values varies between data collections, and is related
to the concept of <a class="reference internal" href="#term-locality-of-reference"><span class="xref std std-term">locality of reference</span></a>.</p>
</dd>
<dt id="term-abstract-data-type">abstract data type<a class="headerlink" href="#term-abstract-data-type" title="Permalink to this term">¶</a></dt><dd><p>Abbreviated <a class="reference internal" href="#term-ADT"><span class="xref std std-term">ADT</span></a>. The specification of a <a class="reference internal" href="#term-data-type"><span class="xref std std-term">data type</span></a>
within some language, independent of an implementation.
The <a class="reference internal" href="#term-interface"><span class="xref std std-term">interface</span></a> for the ADT is defined in terms of a <a class="reference internal" href="#term-type"><span class="xref std std-term">type</span></a>
and a set of operations on that type.
The behavior of each operation is determined by its inputs and
outputs.
An ADT does not specify <em>how</em> the data type is implemented.
These implementation details are hidden from the user of the ADT
and protected from outside access, a concept referred to as
<a class="reference internal" href="#term-encapsulation"><span class="xref std std-term">encapsulation</span></a>.</p>
</dd>
<dt id="term-accept">accept<a class="headerlink" href="#term-accept" title="Permalink to this term">¶</a></dt><dd><p>When a <a class="reference internal" href="#term-Finite-Automata"><span class="xref std std-term">finite automata</span></a> executes on a string and
terminates in an <a class="reference internal" href="#term-accepting-state"><span class="xref std std-term">accepting state</span></a>, it is said to accept
the string.
The finite automata is said to accept the language that consists
of all strings for which the finite automata completes execution
in an accepting state.</p>
</dd>
<dt id="term-accepting-state">accepting state<a class="headerlink" href="#term-accepting-state" title="Permalink to this term">¶</a></dt><dd><p>Part of the definition of a <a class="reference internal" href="#term-Finite-Automata"><span class="xref std std-term">finite automata</span></a> is to
designate some <a class="reference internal" href="#term-state"><span class="xref std std-term">states</span></a> as accepting states.
If the finite automata executes on an input string and completes
the computation in an accepting state, then the machine is said
to <a class="reference internal" href="#term-accept"><span class="xref std std-term">accept</span></a> the string.</p>
</dd>
<dt id="term-acceptor">acceptor<a class="headerlink" href="#term-acceptor" title="Permalink to this term">¶</a></dt><dd><p>In formal languages, any machine whose primary purpose is to
determine whether a string is accepted (is recognized to be in a
language) or rejected. This is in contrast to a machine that
computes some value.</p>
</dd>
<dt id="term-activation-record">activation record<a class="headerlink" href="#term-activation-record" title="Permalink to this term">¶</a></dt><dd><p>The entity that is stored on the <a class="reference internal" href="#term-runtime-stack"><span class="xref std std-term">runtime stack</span></a> during
program execution.
It stores any active <a class="reference internal" href="#term-local-variable"><span class="xref std std-term">local variable</span></a> and the return
address from which a new subroutine is being called, so that
this information can be recovered when the subroutine
terminates.</p>
</dd>
<dt id="term-acyclic-graph">acyclic graph<a class="headerlink" href="#term-acyclic-graph" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> terminology, a graph that contains no
<a class="reference internal" href="#term-cycle"><span class="xref std std-term">cycles</span></a>.</p>
</dd>
<dt id="term-address">address<a class="headerlink" href="#term-address" title="Permalink to this term">¶</a></dt><dd><p>A location in memory.</p>
</dd>
<dt id="term-adjacency-list">adjacency list<a class="headerlink" href="#term-adjacency-list" title="Permalink to this term">¶</a></dt><dd><p>An implementation for a <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> that uses an (array-based)
<a class="reference internal" href="#term-list"><span class="xref std std-term">list</span></a> to represent the <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertices</span></a> of the
graph, and each vertex is in turn represented by a
(linked) list of the vertices that are
<a class="reference internal" href="#term-neighbor"><span class="xref std std-term">neighbors</span></a>.</p>
</dd>
<dt id="term-adjacency-matrix">adjacency matrix<a class="headerlink" href="#term-adjacency-matrix" title="Permalink to this term">¶</a></dt><dd><p>An implementation for a <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> that uses a 2-dimensional
<a class="reference internal" href="#term-array"><span class="xref std std-term">array</span></a> where each row and each column corresponds to a
<a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertex</span></a> in the <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a>. A given row and column in
the matrix corresponds to an edge from the <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertex</span></a>
corresponding to the row to the vertex corresponding to the
column.</p>
</dd>
<dt id="term-adjacent">adjacent<a class="headerlink" href="#term-adjacent" title="Permalink to this term">¶</a></dt><dd><p>Two <a class="reference internal" href="#term-node"><span class="xref std std-term">nodes</span></a> of a <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a> or two
<a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertices</span></a> of a <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> are said to be
adjacent if they have an <a class="reference internal" href="#term-edge"><span class="xref std std-term">edge</span></a> connecting them.
If the edge is directed from <span class="math notranslate nohighlight">\(a\)</span> to <span class="math notranslate nohighlight">\(b\)</span>,
then we say that <span class="math notranslate nohighlight">\(a\)</span> is adjacent to <span class="math notranslate nohighlight">\(b\)</span>,
and <span class="math notranslate nohighlight">\(b\)</span> is adjacent from <span class="math notranslate nohighlight">\(a\)</span>.</p>
</dd>
<dt id="term-ADT">ADT<a class="headerlink" href="#term-ADT" title="Permalink to this term">¶</a></dt><dd><p>Abbreviation for <a class="reference internal" href="#term-abstract-data-type"><span class="xref std std-term">abstract data type</span></a>.</p>
</dd>
<dt id="term-adversary">adversary<a class="headerlink" href="#term-adversary" title="Permalink to this term">¶</a></dt><dd><p>A fictional construct introduced for use in an
<a class="reference internal" href="#term-adversary-argument"><span class="xref std std-term">adversary argument</span></a>.</p>
</dd>
<dt id="term-adversary-argument">adversary argument<a class="headerlink" href="#term-adversary-argument" title="Permalink to this term">¶</a></dt><dd><p>A type of <a class="reference internal" href="#term-lower-bounds-proof"><span class="xref std std-term">lower bounds proof</span></a> for a problem where a
(fictional) “adversary” is assumed to control access to an
algorithm’s input, and which yields information about that input
in such a way
that will drive the cost for any proposed algorithm to solve the
problem as high as possible.
So long as the adversary never gives an answer that conflicts
with any previous answer, it is permitted to do whatever
necessary to make the algorithm require as much cost as
possible.</p>
</dd>
<dt id="term-aggregate-type">aggregate type<a class="headerlink" href="#term-aggregate-type" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-data-type"><span class="xref std std-term">data type</span></a> whose <a class="reference internal" href="#term-member"><span class="xref std std-term">members</span></a> have subparts.
For example, a typical database record.
Another term for this is <a class="reference internal" href="#term-composite-type"><span class="xref std std-term">composite type</span></a>.</p>
</dd>
<dt id="term-algorithm">algorithm<a class="headerlink" href="#term-algorithm" title="Permalink to this term">¶</a></dt><dd><p>A method or a process followed to solve a <a class="reference internal" href="#term-problem"><span class="xref std std-term">problem</span></a>.</p>
</dd>
<dt id="term-algorithm-analysis">algorithm analysis<a class="headerlink" href="#term-algorithm-analysis" title="Permalink to this term">¶</a></dt><dd><p>A less formal version of the term
<a class="reference internal" href="#term-asymptotic-algorithm-analysis"><span class="xref std std-term">asymptotic algorithm analysis</span></a>, generally used as a
synonym for <a class="reference internal" href="#term-asymptotic-analysis"><span class="xref std std-term">asymptotic analysis</span></a>.</p>
</dd>
<dt id="term-alias">alias<a class="headerlink" href="#term-alias" title="Permalink to this term">¶</a></dt><dd><p>Another name for something. In programming, this usually refers
to two <a class="reference internal" href="#term-reference"><span class="xref std std-term">references</span></a> that refer to the same
object.</p>
</dd>
<dt id="term-all-pairs-shortest-paths-problem">all-pairs shortest paths problem<a class="headerlink" href="#term-all-pairs-shortest-paths-problem" title="Permalink to this term">¶</a></dt><dd><p>Given a <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> with <a class="reference internal" href="#term-weight"><span class="xref std std-term">weights</span></a> or
distances on the <a class="reference internal" href="#term-edge"><span class="xref std std-term">edges</span></a>,
find the shortest paths between every pair of
vertices in the graph.
One approach to solving this problem is
<a class="reference internal" href="#term-Floyd-s-algorithm"><span class="xref std std-term">Floyd’s algorithm</span></a>, which uses the
<a class="reference internal" href="#term-dynamic-programming"><span class="xref std std-term">dynamic programming</span></a> algorithmic technique.</p>
</dd>
<dt id="term-allocated">allocated<a class="headerlink" href="#term-allocated" title="Permalink to this term">¶</a></dt><dt id="term-allocation">allocation<a class="headerlink" href="#term-allocation" title="Permalink to this term">¶</a></dt><dd><p>Reserving memory for an object in the Heap memory.</p>
</dd>
<dt id="term-alphabet">alphabet<a class="headerlink" href="#term-alphabet" title="Permalink to this term">¶</a></dt><dd><p>The characters or symbols that strings in a given language may
be composed of.</p>
</dd>
<dt id="term-alphabet-trie">alphabet trie<a class="headerlink" href="#term-alphabet-trie" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-trie"><span class="xref std std-term">trie</span></a> data structure for storing variable-length
strings.
Level <span class="math notranslate nohighlight">\(i\)</span> of the tree corresponds to the letter in
position <span class="math notranslate nohighlight">\(i\)</span> of the string.
The root will have potential branches on each intial letter of
string.
Thus, all strings starting with “a” will be stored in the “a”
branch of the tree.
At the second level, such strings will be separated by branching
on the second letter.</p>
</dd>
<dt id="term-amortized-analysis">amortized analysis<a class="headerlink" href="#term-amortized-analysis" title="Permalink to this term">¶</a></dt><dd><p>An <a class="reference internal" href="#term-algorithm-analysis"><span class="xref std std-term">algorithm analysis</span></a> techique that looks at the total
cost for a series of operations and amortizes this total cost
over the full series.
This is as opposed to considering every individual operation to
independently have the <a class="reference internal" href="#term-worst-case"><span class="xref std std-term">worst case</span></a> cost, which might lead
to an overestimate for the total cost of the series.</p>
</dd>
<dt id="term-amortized-cost">amortized cost<a class="headerlink" href="#term-amortized-cost" title="Permalink to this term">¶</a></dt><dd><p>The total cost for a series of operations to be used in an
<a class="reference internal" href="#term-amortized-analysis"><span class="xref std std-term">amortized analysis</span></a>.</p>
</dd>
<dt id="term-ancestor">ancestor<a class="headerlink" href="#term-ancestor" title="Permalink to this term">¶</a></dt><dd><p>In a tree, for a given node <span class="math notranslate nohighlight">\(A\)</span>, any node on a
<a class="reference internal" href="#term-path"><span class="xref std std-term">path</span></a> from <span class="math notranslate nohighlight">\(A\)</span> up to the root is an ancestor of
<span class="math notranslate nohighlight">\(A\)</span>.</p>
</dd>
<dt id="term-antisymmetric">antisymmetric<a class="headerlink" href="#term-antisymmetric" title="Permalink to this term">¶</a></dt><dd><p>In set notation, relation <span class="math notranslate nohighlight">\(R\)</span> is antisymmetric if whenever
<span class="math notranslate nohighlight">\(aRb\)</span> and <span class="math notranslate nohighlight">\(bRa\)</span>, then <span class="math notranslate nohighlight">\(a = b\)</span>, for all
<span class="math notranslate nohighlight">\(a, b \in \mathbf{S}\)</span>.</p>
</dd>
<dt id="term-approximation-algorithm">approximation algorithm<a class="headerlink" href="#term-approximation-algorithm" title="Permalink to this term">¶</a></dt><dd><p>An algorthm for an <a class="reference internal" href="#term-optimization-problem"><span class="xref std std-term">optimization problem</span></a> that finds a
good, but not necessarily cheapest, solution.</p>
</dd>
<dt id="term-arm">arm<a class="headerlink" href="#term-arm" title="Permalink to this term">¶</a></dt><dd><p>In the context of an <a class="reference internal" href="#term-I-O-head"><span class="xref std std-term">I/O head</span></a>, this attaches the sensor
on the I/O head to the <a class="reference internal" href="#term-boom"><span class="xref std std-term">boom</span></a>.</p>
</dd>
<dt id="term-array">array<a class="headerlink" href="#term-array" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-data-type"><span class="xref std std-term">data type</span></a> that is used to store elements in consecutive memory
locations and refers to them by an index.</p>
</dd>
<dt id="term-array-based-list">array-based list<a class="headerlink" href="#term-array-based-list" title="Permalink to this term">¶</a></dt><dd><p>An implementation for the <a class="reference internal" href="#term-list"><span class="xref std std-term">list</span></a> ADT that uses an <a class="reference internal" href="#term-array"><span class="xref std std-term">array</span></a> to
store the list elements. Typical implementations fix the array
size at creation of the list, and the <a class="reference internal" href="#term-overhead"><span class="xref std std-term">overhead</span></a>
is the number of array positions that are presently unused.</p>
</dd>
<dt id="term-array-based-queue">array-based queue<a class="headerlink" href="#term-array-based-queue" title="Permalink to this term">¶</a></dt><dd><p>Analogous to an <a class="reference internal" href="#term-array-based-list"><span class="xref std std-term">array-based list</span></a>, this uses an <a class="reference internal" href="#term-array"><span class="xref std std-term">array</span></a> to
store the elements when implementing the <a class="reference internal" href="#term-queue"><span class="xref std std-term">queue</span></a> ADT.</p>
</dd>
<dt id="term-array-based-stack">array-based stack<a class="headerlink" href="#term-array-based-stack" title="Permalink to this term">¶</a></dt><dd><p>Analogous to an <a class="reference internal" href="#term-array-based-list"><span class="xref std std-term">array-based list</span></a>, this uses an <a class="reference internal" href="#term-array"><span class="xref std std-term">array</span></a> to
store the elements when implementing the <a class="reference internal" href="#term-stack"><span class="xref std std-term">stack</span></a> ADT.</p>
</dd>
<dt id="term-ASCII-character-coding">ASCII character coding<a class="headerlink" href="#term-ASCII-character-coding" title="Permalink to this term">¶</a></dt><dd><p>American Standard Code for Information Interchange.
A commonly used method for encoding characters using a binary code.
Standard ASCII uses an 8-bit code to represent upper and lower
case letters, digits, some punctuation, and some number of
non-printing characters (such as carrage return).
Now largely replaced by UTF-8 encoding.</p>
</dd>
<dt id="term-assembly-code">assembly code<a class="headerlink" href="#term-assembly-code" title="Permalink to this term">¶</a></dt><dd><p>A form of  <a class="reference internal" href="#term-intermediate-code"><span class="xref std std-term">intermediate code</span></a> created by a <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a> that
is easy to convert into the final form that the computer can
execute.
An assembly language is typically a direct mapping of one or a
few instructions that the CPU can execute into a mnemonic form
that is relatively easy for a human to read.</p>
</dd>
<dt id="term-asymptotic-algorithm-analysis">asymptotic algorithm analysis<a class="headerlink" href="#term-asymptotic-algorithm-analysis" title="Permalink to this term">¶</a></dt><dd><p>A more formal term for <a class="reference internal" href="#term-asymptotic-analysis"><span class="xref std std-term">asymptotic analysis</span></a>.</p>
</dd>
<dt id="term-asymptotic-analysis">asymptotic analysis<a class="headerlink" href="#term-asymptotic-analysis" title="Permalink to this term">¶</a></dt><dd><p>A method for estimating the efficiency of an algorithm or
computer program by identifying its <a class="reference internal" href="#term-growth-rate"><span class="xref std std-term">growth rate</span></a>.
Asymptotic analysis also gives a way to
define the inherent difficulty of a <a class="reference internal" href="#term-problem"><span class="xref std std-term">problem</span></a>.
We frequently use the term <a class="reference internal" href="#term-algorithm-analysis"><span class="xref std std-term">algorithm analysis</span></a> to mean
the same thing.</p>
</dd>
<dt id="term-attribute">attribute<a class="headerlink" href="#term-attribute" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming</span></a>,
a synonym for <a class="reference internal" href="#term-data-member"><span class="xref std std-term">data members</span></a>.</p>
</dd>
<dt id="term-automata">automata<a class="headerlink" href="#term-automata" title="Permalink to this term">¶</a></dt><dd><p>Synonym for <a class="reference internal" href="#term-Finite-State-Machine"><span class="xref std std-term">finite state machine</span></a>.</p>
</dd>
<dt id="term-automatic-variable">automatic variable<a class="headerlink" href="#term-automatic-variable" title="Permalink to this term">¶</a></dt><dd><p>A synonym for <a class="reference internal" href="#term-local-variable"><span class="xref std std-term">local variable</span></a>.
When program flow enters and leaves the variable’s scope,
automatic variables will be allocated and de-allocated
automatically.</p>
</dd>
<dt id="term-average-case">average case<a class="headerlink" href="#term-average-case" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-algorithm-analysis"><span class="xref std std-term">algorithm analysis</span></a>, the average of the costs for all
<a class="reference internal" href="#term-problem-instance"><span class="xref std std-term">problem instances</span></a> of a given input
size <span class="math notranslate nohighlight">\(n\)</span>. If not all problem
instances have equal probability of occurring, then average case
must be calculated using a weighted average.</p>
</dd>
<dt id="term-average-seek-time">average seek time<a class="headerlink" href="#term-average-seek-time" title="Permalink to this term">¶</a></dt><dd><p>Expected (average) time to perform a <a class="reference internal" href="#term-seek"><span class="xref std std-term">seek</span></a> operation on a
<a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a>, assuming that the seek is between two
randomly selected tracks.
This is one of two metrics commonly provided by disk drive
vendors for disk drive performance, with the other being
<a class="reference internal" href="#term-track-to-track-seek-time"><span class="xref std std-term">track-to-track seek time</span></a>.</p>
</dd>
<dt id="term-AVL-Tree">AVL Tree<a class="headerlink" href="#term-AVL-Tree" title="Permalink to this term">¶</a></dt><dd><p>A variant implementation for the <a class="reference internal" href="#term-BST"><span class="xref std std-term">BST</span></a>, which differs from
the standard BST in that it uses modified insert and remove
methods in order to keep the tree
<a class="reference internal" href="#term-balanced-tree"><span class="xref std std-term">balanced</span></a>.
Similar to a <a class="reference internal" href="#term-Splay-Tree"><span class="xref std std-term">Splay Tree</span></a> in that it uses the concept of
<a class="reference internal" href="#term-rotation"><span class="xref std std-term">rotations</span></a> in the insert and remove operations.</p>
</dd>
<dt id="term-0">B$^*$-tree<a class="headerlink" href="#term-0" title="Permalink to this term">¶</a></dt><dd><p>A variant on the <a class="reference internal" href="#term-B-tree"><span class="xref std std-term">B$^+$-tree</span></a>.
The <span class="math notranslate nohighlight">\(\mathrm{B}^*\)</span> tree is identical to the <span class="math notranslate nohighlight">\(\mathrm{B}^+\)</span>
tree, except for the rules used to split and merge nodes.
Instead of splitting a node in half when it overflows, the
<span class="math notranslate nohighlight">\(\mathrm{B}^*\)</span> tree
gives some records to its neighboring sibling, if possible.
If the sibling is also full, then these two nodes split into three.
Similarly, when a node underflows, it is combined with its two
siblings, and the total reduced to two nodes.
Thus, the nodes are always at least two thirds full.</p>
</dd>
<dt id="term-B-tree">B$^+$-tree<a class="headerlink" href="#term-B-tree" title="Permalink to this term">¶</a></dt><dd><p>The most commonly implemented form of <a class="reference internal" href="#term-1"><span class="xref std std-term">B-tree</span></a>.
A B$^+$-tree does not store data at the
<a class="reference internal" href="#term-internal-node"><span class="xref std std-term">internal nodes</span></a>, but
instead only stores <a class="reference internal" href="#term-search-key"><span class="xref std std-term">search key</span></a> values as direction
finders for the purpose of searching through the tree.
Only the <a class="reference internal" href="#term-leaf-node"><span class="xref std std-term">leaf nodes</span></a> store a
<a class="reference internal" href="#term-reference"><span class="xref std std-term">reference</span></a> to the actual data records.</p>
</dd>
<dt id="term-1">B-tree<a class="headerlink" href="#term-1" title="Permalink to this term">¶</a></dt><dd><p>A method for <a class="reference internal" href="#term-indexing"><span class="xref std std-term">indexing</span></a> a large collection of records.
A B-tree is a <a class="reference internal" href="#term-balanced-tree"><span class="xref std std-term">balanced tree</span></a> that typically has high
branching factor (commonly as much as 100
<a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a> per <a class="reference internal" href="#term-internal-node"><span class="xref std std-term">internal node</span></a>),
causing the tree to be very shallow.
When stored on disk, the node size is selected to be same as the
desired unit of I/O (so some multiple of the disk <a class="reference internal" href="#term-sector"><span class="xref std std-term">sector</span></a>
size).
This makes it easy to gain access to the record associated with
a given <a class="reference internal" href="#term-search-key"><span class="xref std std-term">search key</span></a> stored in the tree with few
<a class="reference internal" href="#term-disk-access"><span class="xref std std-term">disk accesses</span></a>.
The most commonly implemented variant of the B-tree is the
<a class="reference internal" href="#term-B-tree"><span class="xref std std-term">B$^+$-tree</span></a>.</p>
</dd>
<dt id="term-backing-storage">backing storage<a class="headerlink" href="#term-backing-storage" title="Permalink to this term">¶</a></dt><dd><p>In the context of a <a class="reference internal" href="#term-caching"><span class="xref std std-term">caching</span></a> system or
<a class="reference internal" href="#term-buffer-pool"><span class="xref std std-term">buffer pool</span></a>, backing storage is the relatively large but
slower source of data that needs to be cached.
For example, in a <a class="reference internal" href="#term-virtual-memory"><span class="xref std std-term">virtual memory</span></a>, the disk drive would
be the backing storage.
In the context of a web browser, the Internet might be
considered the backing storage.</p>
</dd>
<dt id="term-backtracking">backtracking<a class="headerlink" href="#term-backtracking" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-heuristic"><span class="xref std std-term">heuristic</span></a> for brute-force search of a solution space.
It is essentially a <a class="reference internal" href="#term-depth-first-search"><span class="xref std std-term">depth-first search</span></a> of the solution
space.
This can be improved using a <a class="reference internal" href="#term-branch-and-bounds-algorithm"><span class="xref std std-term">branch-and-bounds algorithm</span></a>.</p>
</dd>
<dt id="term-bad-reference">bad reference<a class="headerlink" href="#term-bad-reference" title="Permalink to this term">¶</a></dt><dd><p>A reference is referred to as a bad reference if it is allocated
but not initialized.</p>
</dd>
<dt id="term-bag">bag<a class="headerlink" href="#term-bag" title="Permalink to this term">¶</a></dt><dd><p>In set notation, a bag is a collection of elements with no order
(like a set), but which allows for duplicate-valued elements
(unlike a set).</p>
</dd>
<dt id="term-balanced-tree">balanced tree<a class="headerlink" href="#term-balanced-tree" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a> where the <a class="reference internal" href="#term-subtree"><span class="xref std std-term">subtrees</span></a> meet some
criteria for being balanced.
Two possibilities are that the tree is
<a class="reference internal" href="#term-height-balanced"><span class="xref std std-term">height balanced</span></a>, or that the tree has a roughly equal
number of <a class="reference internal" href="#term-node"><span class="xref std std-term">nodes</span></a> in each subtree.</p>
</dd>
<dt id="term-base">base<a class="headerlink" href="#term-base" title="Permalink to this term">¶</a></dt><dd><p>Synonym for <a class="reference internal" href="#term-radix"><span class="xref std std-term">radix</span></a>.</p>
</dd>
<dt id="term-base-case">base case<a class="headerlink" href="#term-base-case" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursion</span></a> or <a class="reference internal" href="#term-proof-by-induction"><span class="xref std std-term">proof by induction</span></a>, the base case
is the termination condition.
This is a simple input or value that can be solved (or proved in
the case of induction) without resorting to a recursive call
(or the <a class="reference internal" href="#term-induction-hypothesis"><span class="xref std std-term">induction hypothesis</span></a>).</p>
</dd>
<dt id="term-base-class">base class<a class="headerlink" href="#term-base-class" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming</span></a>,
a class from which another class <a class="reference internal" href="#term-inherit"><span class="xref std std-term">inherits</span></a>.
The class that inherits is called a <a class="reference internal" href="#term-subclass"><span class="xref std std-term">subclass</span></a>.</p>
</dd>
<dt id="term-base-type">base type<a class="headerlink" href="#term-base-type" title="Permalink to this term">¶</a></dt><dd><p>The <a class="reference internal" href="#term-data-type"><span class="xref std std-term">data type</span></a> for the elements in a set.
For example, the set might consist of the integer values 3, 5,
and 7.
In this example, the base type is integers.</p>
</dd>
<dt id="term-basic-operation">basic operation<a class="headerlink" href="#term-basic-operation" title="Permalink to this term">¶</a></dt><dd><p>Examples of basic operations include inserting a data
item into the data structure, deleting a <a class="reference internal" href="#term-data-item"><span class="xref std std-term">data item</span></a> from the
data structure, and finding a specified <a class="reference internal" href="#term-data-item"><span class="xref std std-term">data item</span></a>.</p>
</dd>
<dt id="term-best-case">best case<a class="headerlink" href="#term-best-case" title="Permalink to this term">¶</a></dt><dd><p>In algorithm analysis, the <a class="reference internal" href="#term-problem-instance"><span class="xref std std-term">problem instance</span></a> from among
all problem instances for a given input size <span class="math notranslate nohighlight">\(n\)</span> that has
least cost. Note that the best case is <strong>not</strong> when <span class="math notranslate nohighlight">\(n\)</span> is
small, since we are referring to the best from a class of inputs
(i.e, we want the best of those inputs of size <span class="math notranslate nohighlight">\(n\)</span>).</p>
</dd>
<dt id="term-best-fit">best fit<a class="headerlink" href="#term-best-fit" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-memory-manager"><span class="xref std std-term">memory manager</span></a>, best fit is a <a class="reference internal" href="#term-heuristic"><span class="xref std std-term">heuristic</span></a>
for deciding which <a class="reference internal" href="#term-free-block"><span class="xref std std-term">free block</span></a> to use when allocating
memory from a <a class="reference internal" href="#term-memory-pool"><span class="xref std std-term">memory pool</span></a>.
Best fit will always allocate from the smallest
<a class="reference internal" href="#term-free-block"><span class="xref std std-term">free block</span></a> that is large enough to service the memory
request.
The rationale is that this will be the method that best
preserves large blocks needed for unusually large requests.
The disadvantage is that it tends to
cause <a class="reference internal" href="#term-external-fragmentation"><span class="xref std std-term">external fragmentation</span></a> in the form of small,
unuseable memory blocks.</p>
</dd>
<dt id="term-BFS">BFS<a class="headerlink" href="#term-BFS" title="Permalink to this term">¶</a></dt><dd><p>Abbreviation for <a class="reference internal" href="#term-breadth-first-search"><span class="xref std std-term">breadth-first search</span></a>.</p>
</dd>
<dt id="term-big-Oh-notation">big-Oh notation<a class="headerlink" href="#term-big-Oh-notation" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-algorithm-analysis"><span class="xref std std-term">algorithm analysis</span></a>, a shorthand notation for
describing the <a class="reference internal" href="#term-upper-bound"><span class="xref std std-term">upper bound</span></a> for an <a class="reference internal" href="#term-algorithm"><span class="xref std std-term">algorithm</span></a> or
<a class="reference internal" href="#term-problem"><span class="xref std std-term">problem</span></a>.</p>
</dd>
<dt id="term-binary-insert-sort">binary insert sort<a class="headerlink" href="#term-binary-insert-sort" title="Permalink to this term">¶</a></dt><dd><p>A variation on <a class="reference internal" href="#term-Insertion-Sort"><span class="xref std std-term">insertion sort</span></a> where the position of the
value being inserted is located by binary search, and then put
into place. In normal usage this is not an improvement on
standard insertion sort because of the expense of moving many
items in the <a class="reference internal" href="#term-array"><span class="xref std std-term">array</span></a>. But it is directly useful if the cost of
comparison is high compared to that of moving an element, or
is theoretically useful if we only care to count the cost of
comparisons.</p>
</dd>
<dt id="term-binary-relation">binary relation<a class="headerlink" href="#term-binary-relation" title="Permalink to this term">¶</a></dt><dd><p>In set theory, a <a class="reference internal" href="#term-relation"><span class="xref std std-term">relation</span></a> defined by a collection of
binary <a class="reference internal" href="#term-tuple"><span class="xref std std-term">tuples</span></a>.</p>
</dd>
<dt id="term-binary-search">binary search<a class="headerlink" href="#term-binary-search" title="Permalink to this term">¶</a></dt><dd><p>A standard <a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursive</span></a> algorithm for finding
the <a class="reference internal" href="#term-record"><span class="xref std std-term">record</span></a> with a given <a class="reference internal" href="#term-search-key"><span class="xref std std-term">search key</span></a> value within
a sorted list.
It runs in <span class="math notranslate nohighlight">\(O(\log n)\)</span> time.
At each step, look at the middle of the current sublist, and throw
away the half of the records whose keys are either too small or
too large.</p>
</dd>
<dt id="term-binary-search-tree">binary search tree<a class="headerlink" href="#term-binary-search-tree" title="Permalink to this term">¶</a></dt><dd><p>A binary tree that imposes the following constraint on its node
values: The <a class="reference internal" href="#term-search-key"><span class="xref std std-term">search key</span></a> value for any node <span class="math notranslate nohighlight">\(A\)</span> must
be greater than the (key) values for all nodes in the left
<a class="reference internal" href="#term-subtree"><span class="xref std std-term">subtree</span></a> of <span class="math notranslate nohighlight">\(A\)</span>, and less than the key values for
all nodes in the right subtree of <span class="math notranslate nohighlight">\(A\)</span>.
Some convention must be adopted if
multiple nodes with the same key value are permitted,
typically these are required to be in the right subtree.</p>
</dd>
<dt id="term-binary-search-tree-property">binary search tree property<a class="headerlink" href="#term-binary-search-tree-property" title="Permalink to this term">¶</a></dt><dd><p>The defining relationship between the <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> values for
<a class="reference internal" href="#term-node"><span class="xref std std-term">nodes</span></a> in a <a class="reference internal" href="#term-BST"><span class="xref std std-term">BST</span></a>.
All nodes stored in the left subtree of a node whose key value
is <span class="math notranslate nohighlight">\(K\)</span> have key values less than or equal to <span class="math notranslate nohighlight">\(K\)</span>.
All nodes stored in the right subtree of a node whose key value
is <span class="math notranslate nohighlight">\(K\)</span> have key values greater than <span class="math notranslate nohighlight">\(K\)</span>.</p>
</dd>
<dt id="term-binary-tree">binary tree<a class="headerlink" href="#term-binary-tree" title="Permalink to this term">¶</a></dt><dd><p>A finite set of nodes which is either empty, or else has a root
node together two binary trees, called the left and right
<a class="reference internal" href="#term-subtree"><span class="xref std std-term">subtrees</span></a>, which are <a class="reference internal" href="#term-disjoint"><span class="xref std std-term">disjoint</span></a> from each
other and from the <a class="reference internal" href="#term-root"><span class="xref std std-term">root</span></a>.</p>
</dd>
<dt id="term-binary-trie">binary trie<a class="headerlink" href="#term-binary-trie" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-binary-tree"><span class="xref std std-term">binary tree</span></a> whose structure is that of a <a class="reference internal" href="#term-trie"><span class="xref std std-term">trie</span></a>.
Generally this is an implementation for a <a class="reference internal" href="#term-search-tree"><span class="xref std std-term">search tree</span></a>.
This means that the <a class="reference internal" href="#term-search-key"><span class="xref std std-term">search key</span></a> values are thought of a
binary digits, with the digit in the position corresponding to
this a node’s <a class="reference internal" href="#term-level"><span class="xref std std-term">level</span></a> in the tree indicating a left branch
if it is “0”, or a right branch if it is “1”.
Examples include the <a class="reference internal" href="#term-Huffman-coding-tree"><span class="xref std std-term">Huffman coding tree</span></a> and the
<a class="reference internal" href="#term-bintree"><span class="xref std std-term">Bintree</span></a>.</p>
</dd>
<dt id="term-binning">binning<a class="headerlink" href="#term-binning" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, binning is a type of <a class="reference internal" href="#term-hash-function"><span class="xref std std-term">hash function</span></a>.
Say we are given keys in the range 0 to 999, and have a hash
table of size 10.
In this case, a possible hash function might simply divide the
key value by 100.
Thus, all keys in the range 0 to 99 would hash to slot 0, keys
100 to 199 would hash to slot 1, and so on.
In other words, this hash function “bins” the first 100 keys to
the first slot, the next 100 keys to the second slot, and so
on.
This approach tends to make the hash function dependent on the
distribution of the high-order bits of the keys.</p>
</dd>
<dt id="term-Binsort">Binsort<a class="headerlink" href="#term-Binsort" title="Permalink to this term">¶</a></dt><dd><p>A sort that works by taking each record and placing it into a
bin based on its value. The bins are then gathered up in order
to sort the list. It is generally not practical in this form,
but it is the conceptual underpinning of the <a class="reference internal" href="#term-radix-sort"><span class="xref std std-term">radix sort</span></a>.</p>
</dd>
<dt id="term-bintree">bintree<a class="headerlink" href="#term-bintree" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-spatial-data-structure"><span class="xref std std-term">spatial data structure</span></a> in the form of binary
<a class="reference internal" href="#term-trie"><span class="xref std std-term">trie</span></a>, typically used to store point data in two or more
dimensions.
Similar to a <a class="reference internal" href="#term-PR-quadtree"><span class="xref std std-term">PR quadtree</span></a> except that at each level, it
splits one dimension in half.
Since many leaf nodes of the PR quadtree will contain no data
points, implementation often makes use of the <a class="reference internal" href="#term-flyweight"><span class="xref std std-term">flyweight</span></a>
<a class="reference internal" href="#term-design-pattern"><span class="xref std std-term">design pattern</span></a>.</p>
</dd>
<dt id="term-bitmap">bitmap<a class="headerlink" href="#term-bitmap" title="Permalink to this term">¶</a></dt><dt id="term-bit-vector">bit vector<a class="headerlink" href="#term-bit-vector" title="Permalink to this term">¶</a></dt><dd><p>An <a class="reference internal" href="#term-array"><span class="xref std std-term">array</span></a> that stores a single bit at each position.
Typically these bits represent
<a class="reference internal" href="#term-Boolean-variable"><span class="xref std std-term">Boolean variables</span></a> associated with
a collection of objects, such that the <span class="math notranslate nohighlight">\(i\)</span> th bit is the
Boolean value for the <span class="math notranslate nohighlight">\(i\)</span> th object.</p>
</dd>
<dt id="term-block">block<a class="headerlink" href="#term-block" title="Permalink to this term">¶</a></dt><dd><p>A unit of storage, usually referring to storage on a
<a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a> or other <a class="reference internal" href="#term-peripheral-storage"><span class="xref std std-term">peripheral storage</span></a> device.
A block is the basic unit of I/O for that device.</p>
</dd>
<dt id="term-Boolean-expression">Boolean expression<a class="headerlink" href="#term-Boolean-expression" title="Permalink to this term">¶</a></dt><dd><p>A Boolean expression is comprised of
<a class="reference internal" href="#term-Boolean-variable"><span class="xref std std-term">Boolean variables</span></a>
combined using the operators AND (<span class="math notranslate nohighlight">\(\cdot\)</span>), OR
(<span class="math notranslate nohighlight">\(+\)</span>), and NOT (to negate Boolean variable <span class="math notranslate nohighlight">\(x\)</span> we
write <span class="math notranslate nohighlight">\(\overline{x}\)</span>).</p>
</dd>
<dt id="term-Boolean-variable">Boolean variable<a class="headerlink" href="#term-Boolean-variable" title="Permalink to this term">¶</a></dt><dd><p>A variable that takes on one of the two values <code class="docutils literal notranslate"><span class="pre">True</span></code> and
<code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
<dt id="term-boom">boom<a class="headerlink" href="#term-boom" title="Permalink to this term">¶</a></dt><dd><p>In the context of an <a class="reference internal" href="#term-I-O-head"><span class="xref std std-term">I/O head</span></a>, is the central structure
to which all of the I/O heads are attached.
Thus, the all move together during a <a class="reference internal" href="#term-seek"><span class="xref std std-term">seek</span></a> operation.</p>
</dd>
<dt id="term-bounding-box">bounding box<a class="headerlink" href="#term-bounding-box" title="Permalink to this term">¶</a></dt><dd><p>A box (usually aligned to the coordinate axes of the reference
system) that contains a (potentially complex) object. In
graphics and computational geometry, complex objects might be
associated with a bounding box for use by algorithms that search
for objects in a particular location. The idea is that if the
bounding box is not within the area of interest, then neither is
the object. Checking the bounding box is cheaper than checking
the object, but it does require some time. So if enough objects
are not outside the area of interest, this approach will not
save time. But if most objects are outside of the area of
interest, then checking bounding boxes first can save a lot of
time.</p>
</dd>
<dt id="term-branch-and-bounds-algorithm">branch-and-bounds algorithm<a class="headerlink" href="#term-branch-and-bounds-algorithm" title="Permalink to this term">¶</a></dt><dd><p>A variation on <a class="reference internal" href="#term-backtracking"><span class="xref std std-term">backtracking</span></a> that applies
to <a class="reference internal" href="#term-optimization-problem"><span class="xref std std-term">optimization problems</span></a>.
We traverse the <a class="reference internal" href="#term-solution-tree"><span class="xref std std-term">solution tree</span></a> as with backtracking.
Proceeding deeper in the solution tree generally requires
additional cost.
We remember the best-cost solution found so far.
If the cost of the current branch in the tree exceeds the best
tour cost found so far, then we know to stop pursuing this
branch of the tree.
At this point we can immediately back up and take another branch.</p>
</dd>
<dt id="term-breadth-first-search">breadth-first search<a class="headerlink" href="#term-breadth-first-search" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> <a class="reference internal" href="#term-traversal"><span class="xref std std-term">traversal</span></a> algorithm.
As the name implies, all immediate <a class="reference internal" href="#term-neighbor"><span class="xref std std-term">neighbors</span></a>
for a <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> are <a class="reference internal" href="#term-visit"><span class="xref std std-term">visited</span></a> before any
more-distant nodes are visited.
BFS is driven by a <a class="reference internal" href="#term-queue"><span class="xref std std-term">queue</span></a>.
A start vertex is placed on the queue.
Then, until the queue is empty, a node is taken off the
queue, visited, and and then any <a class="reference internal" href="#term-unvisited"><span class="xref std std-term">unvisited</span></a> neighbors are
placed onto the queue.</p>
</dd>
<dt id="term-break-even-point">break-even point<a class="headerlink" href="#term-break-even-point" title="Permalink to this term">¶</a></dt><dd><p>The point at which two costs become even when measured as the
function of some variable.
In particular, used to compare the space requirements of two
implementations.
For example, when comparing the space requirements of an
<a class="reference internal" href="#term-array-based-list"><span class="xref std std-term">array-based list</span></a> implementation versus a
<a class="reference internal" href="#term-linked-list"><span class="xref std std-term">linked list</span></a> implementation, the key issue is how full
the list is compared to its capacity limit (for the array-based
list).
The point where the two representations would have the same
space cost is the break-even point.
As the list becomes more full beyond this point, the array-based
list implementation becomes more space efficent, while as the
list becomes less full below this point, the linked list
implementation becomes more space efficient.</p>
</dd>
<dt id="term-BST">BST<a class="headerlink" href="#term-BST" title="Permalink to this term">¶</a></dt><dd><p>Abbreviation for <a class="reference internal" href="#term-binary-search-tree"><span class="xref std std-term">binary search tree</span></a>.</p>
</dd>
<dt id="term-bubble-sort">bubble sort<a class="headerlink" href="#term-bubble-sort" title="Permalink to this term">¶</a></dt><dd><p>A simple sort that requires <span class="math notranslate nohighlight">\(Theta(n^2)\)</span> time in
<a class="reference internal" href="#term-best-case"><span class="xref std std-term">best</span></a>, <a class="reference internal" href="#term-average-case"><span class="xref std std-term">average</span></a>,
and <a class="reference internal" href="#term-worst-case"><span class="xref std std-term">worst</span></a> cases.
Even an optimized version will normally run slower than
<a class="reference internal" href="#term-Insertion-Sort"><span class="xref std std-term">insertion sort</span></a>, so it has little to recommend it.</p>
</dd>
<dt id="term-bucket">bucket<a class="headerlink" href="#term-bucket" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-bucket-hashing"><span class="xref std std-term">bucket hashing</span></a>, a bucket is a sequence of
<a class="reference internal" href="#term-slot"><span class="xref std std-term">slots</span></a> in the <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a> that are grouped
together.</p>
</dd>
<dt id="term-bucket-hashing">bucket hashing<a class="headerlink" href="#term-bucket-hashing" title="Permalink to this term">¶</a></dt><dd><p>A method of <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a> where multiple <a class="reference internal" href="#term-slot"><span class="xref std std-term">slots</span></a>
of the <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a> are grouped together to form a
<a class="reference internal" href="#term-bucket"><span class="xref std std-term">bucket</span></a>.
The <a class="reference internal" href="#term-hash-function"><span class="xref std std-term">hash function</span></a> then either hashes to some bucket, or
else it hashes to a <a class="reference internal" href="#term-home-slot"><span class="xref std std-term">home slot</span></a> in the normal way, but
this home slot is part of some bucket.
<a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">Collision resolution</span></a> is handled
first by attempting to find a free position within the same
bucket as the home slot.
If the bucket if full, then the record is placed in an
<a class="reference internal" href="#term-overflow-bucket"><span class="xref std std-term">overflow bucket</span></a>.</p>
</dd>
<dt id="term-bucket-sort">bucket sort<a class="headerlink" href="#term-bucket-sort" title="Permalink to this term">¶</a></dt><dd><p>A variation on the <a class="reference internal" href="#term-Binsort"><span class="xref std std-term">Binsort</span></a>, where each bin is associated
with a range of <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> values.
This will require some method of
sorting the records placed into each bin.</p>
</dd>
<dt id="term-buddy-method">buddy method<a class="headerlink" href="#term-buddy-method" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-memory-manager"><span class="xref std std-term">memory manager</span></a>, an alternative to using a
<a class="reference internal" href="#term-free-block-list"><span class="xref std std-term">free block list</span></a> and a <a class="reference internal" href="#term-sequential-fit"><span class="xref std std-term">sequential fit</span></a> method to
seach for a suitable free block to service a
<a class="reference internal" href="#term-memory-request"><span class="xref std std-term">memory request</span></a>.
Instead, the memory pool is broken down as needed into smaller
chunks by splitting it in half repeatedly until the smallest
power of 2 that is as big or bigger than the size of the memory
request is reached.
The name comes from the fact that the binary representation for
the start of the block positions only differ by one bit for
adjacent blocks of the same size.
These are referred to as “buddies” and will be merged together
if both are free.</p>
</dd>
<dt id="term-buffer">buffer<a class="headerlink" href="#term-buffer" title="Permalink to this term">¶</a></dt><dd><p>A block of memory, most often in <a class="reference internal" href="#term-primary-storage"><span class="xref std std-term">primary storage</span></a>.
The size of a buffer is typically one or a multiple of the basic
unit of I/O that is read or written on each access to
<a class="reference internal" href="#term-secondary-storage"><span class="xref std std-term">secondary storage</span></a> such as a <a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a>.</p>
</dd>
<dt id="term-buffer-passing">buffer passing<a class="headerlink" href="#term-buffer-passing" title="Permalink to this term">¶</a></dt><dd><p>An approach to implementing the <a class="reference internal" href="#term-ADT"><span class="xref std std-term">ADT</span></a> for a
<a class="reference internal" href="#term-buffer-pool"><span class="xref std std-term">buffer pool</span></a>, where a pointer to a <a class="reference internal" href="#term-buffer"><span class="xref std std-term">buffer</span></a> is
passed between the client and the buffer pool.
This is in contrast to a <a class="reference internal" href="#term-message-passing"><span class="xref std std-term">message passing</span></a> approach,
it is most likely to be used for long messages or when the
message size is always the same as the buffer size, such as when
implementing a <a class="reference internal" href="#term-1"><span class="xref std std-term">B-tree</span></a>.</p>
</dd>
<dt id="term-buffer-pool">buffer pool<a class="headerlink" href="#term-buffer-pool" title="Permalink to this term">¶</a></dt><dd><p>A collection of one or more <a class="reference internal" href="#term-buffer"><span class="xref std std-term">buffers</span></a>.
The buffer pool is an example of a <a class="reference internal" href="#term-caching"><span class="xref std std-term">cache</span></a>.
It is stored in <a class="reference internal" href="#term-primary-storage"><span class="xref std std-term">primary storage</span></a>, and holds data that is
expected to be used in the near future.
When a data value is requested, the buffer pool is searched
first.
If the value is found in the buffer pool, then
<a class="reference internal" href="#term-secondary-storage"><span class="xref std std-term">secondary storage</span></a> need not be accessed.
If the value is not found in the buffer pool, then it must be
fetched from secondary storage.
A number of traditional <a class="reference internal" href="#term-heuristic"><span class="xref std std-term">heuristics</span></a>
have been developed for deciding which data to <a class="reference internal" href="#term-flush"><span class="xref std std-term">flush</span></a>
from the buffer pool when new data must be stored,
such as <a class="reference internal" href="#term-least-recently-used"><span class="xref std std-term">least recently used</span></a>.</p>
</dd>
<dt id="term-buffering">buffering<a class="headerlink" href="#term-buffering" title="Permalink to this term">¶</a></dt><dd><p>A synonym for <a class="reference internal" href="#term-caching"><span class="xref std std-term">caching</span></a>.
More specifically, it refers to an arrangement where all
accesses to data (such as on a
<a class="reference internal" href="#term-peripheral-storage"><span class="xref std std-term">peripheral storage</span></a> device) must
be done in multiples of some minimum unit of storage.
On a <a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a>, this basic or smallest unit of I/O is a
<a class="reference internal" href="#term-sector"><span class="xref std std-term">sector</span></a>.
It is called “buffering” because the block of data returned by
such an access is stored in a <a class="reference internal" href="#term-buffer"><span class="xref std std-term">buffer</span></a>.</p>
</dd>
<dt id="term-caching">caching<a class="headerlink" href="#term-caching" title="Permalink to this term">¶</a></dt><dd><p>The concept of keeping selected data in <a class="reference internal" href="#term-main-memory"><span class="xref std std-term">main memory</span></a>.
The goal is to have in main memory the data values that are
most likely to be used in the near future.
An example of a caching technique is the use of a
<a class="reference internal" href="#term-buffer-pool"><span class="xref std std-term">buffer pool</span></a>.</p>
</dd>
<dt id="term-call-stack">call stack<a class="headerlink" href="#term-call-stack" title="Permalink to this term">¶</a></dt><dd><p>Known also as execution stack. A stack that stores the function
call sequence and the return address for each function.</p>
</dd>
<dt id="term-Cartesian-product">Cartesian product<a class="headerlink" href="#term-Cartesian-product" title="Permalink to this term">¶</a></dt><dd><p>For sets, this is another name for the <a class="reference internal" href="#term-set-product"><span class="xref std std-term">set product</span></a>.</p>
</dd>
<dt id="term-ceiling">ceiling<a class="headerlink" href="#term-ceiling" title="Permalink to this term">¶</a></dt><dd><p>Written <span class="math notranslate nohighlight">\(\lceil x \rceil\)</span>, for real value <span class="math notranslate nohighlight">\(x\)</span> the
ceiling is the least integer <span class="math notranslate nohighlight">\(\geq x\)</span>.</p>
</dd>
<dt id="term-child">child<a class="headerlink" href="#term-child" title="Permalink to this term">¶</a></dt><dd><p>In a tree, the set of <a class="reference internal" href="#term-node"><span class="xref std std-term">nodes</span></a> directly pointed to
by a node <span class="math notranslate nohighlight">\(R\)</span> are the <a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a> of <span class="math notranslate nohighlight">\(R\)</span>.</p>
</dd>
<dt id="term-circular-first-fit">circular first fit<a class="headerlink" href="#term-circular-first-fit" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-memory-manager"><span class="xref std std-term">memory manager</span></a>, circular first fit is a
<a class="reference internal" href="#term-heuristic"><span class="xref std std-term">heuristic</span></a> for deciding which <a class="reference internal" href="#term-free-block"><span class="xref std std-term">free block</span></a> to use
when allocating memory from a <a class="reference internal" href="#term-memory-pool"><span class="xref std std-term">memory pool</span></a>.
Circular first fit is a minor modification on <a class="reference internal" href="#term-first-fit"><span class="xref std std-term">first fit</span></a>
memory allocation, where the last free block allocated from is
remembered, and search for the next suitable free block picks up
from there.
Like first fit, it has the advantage that it is typically not
necessary to look at all free blocks on the free block list to
find a suitable free block.
And it has the advantage over first fit that it spreads out
memory allocations evenly across the <a class="reference internal" href="#term-free-block-list"><span class="xref std std-term">free block list</span></a>.
This might help to minimize <a class="reference internal" href="#term-external-fragmentation"><span class="xref std std-term">external fragmentation</span></a>.</p>
</dd>
<dt id="term-circular-list">circular list<a class="headerlink" href="#term-circular-list" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-list"><span class="xref std std-term">list</span></a> ADT implementation variant where the last element
of the list provides access to the first element of the list.</p>
</dd>
<dt id="term-class">class<a class="headerlink" href="#term-class" title="Permalink to this term">¶</a></dt><dd><p>In the <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming paradigm</span></a>
an ADT and its implementation together make up a class.
An instantiation of a class within a program is termed an
<a class="reference internal" href="#term-object"><span class="xref std std-term">object</span></a>.</p>
</dd>
<dt id="term-class-hierarchy">class hierarchy<a class="headerlink" href="#term-class-hierarchy" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming</span></a>,
a set of classes and their interrelationships.
One of the classes is the <a class="reference internal" href="#term-base-class"><span class="xref std std-term">base class</span></a>, and the others are
<a class="reference internal" href="#term-subclass"><span class="xref std std-term">subclasses</span></a> that <a class="reference internal" href="#term-inherit"><span class="xref std std-term">inherit</span></a> either
directly or indirectly from the base class.</p>
</dd>
<dt id="term-clause">clause<a class="headerlink" href="#term-clause" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-Boolean-expression"><span class="xref std std-term">Boolean expression</span></a>, a clause is one or more
<a class="reference internal" href="#term-literal"><span class="xref std std-term">literals</span></a> OR’ed together.</p>
</dd>
<dt id="term-client">client<a class="headerlink" href="#term-client" title="Permalink to this term">¶</a></dt><dd><p>The user of a service.
For example, the object or part of the program that calls a
<a class="reference internal" href="#term-memory-manager"><span class="xref std std-term">memory manager</span></a> class is the client of that memory
manager.
Likewise the class or code that calls a <a class="reference internal" href="#term-buffer-pool"><span class="xref std std-term">buffer pool</span></a>.</p>
</dd>
<dt id="term-clique">clique<a class="headerlink" href="#term-clique" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> terminology, a clique is a <a class="reference internal" href="#term-subgraph"><span class="xref std std-term">subgraph</span></a>,
defined as any <a class="reference internal" href="#term-subset"><span class="xref std std-term">subset</span></a> <span class="math notranslate nohighlight">\(U\)</span> of the graph’s
<a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertices</span></a> such that every vertex in <span class="math notranslate nohighlight">\(U\)</span>
has an <a class="reference internal" href="#term-edge"><span class="xref std std-term">edge</span></a> to every other vertex in <span class="math notranslate nohighlight">\(U\)</span>.
The size of the clique is the number of vertices in the clique.</p>
</dd>
<dt id="term-closed">closed<a class="headerlink" href="#term-closed" title="Permalink to this term">¶</a></dt><dd><p>A set is closed over a (binary) operation if,
whenever the operation is applied to two members of the set, the
result is a member of the set.</p>
</dd>
<dt id="term-closed-hash-system">closed hash system<a class="headerlink" href="#term-closed-hash-system" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-hash-system"><span class="xref std std-term">hash system</span></a> where all records are stored in slots of
the <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>.
This is in contrast to an <a class="reference internal" href="#term-open-hash-system"><span class="xref std std-term">open hash system</span></a>.</p>
</dd>
<dt id="term-closed-form-solution">closed-form solution<a class="headerlink" href="#term-closed-form-solution" title="Permalink to this term">¶</a></dt><dd><p>An algebraic equation with the same value as a <a class="reference internal" href="#term-summation"><span class="xref std std-term">summation</span></a>
or <a class="reference internal" href="#term-recurrence-relation"><span class="xref std std-term">recurrence relation</span></a>.
The process of replacing the summation or
recurrence with its closed-form solution is known as solving the
summation or recurrence.</p>
</dd>
<dt id="term-cluster">cluster<a class="headerlink" href="#term-cluster" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-file-processing"><span class="xref std std-term">file processing</span></a>, a collection of physically adjacent
<a class="reference internal" href="#term-sector"><span class="xref std std-term">sectors</span></a> that define the smallest allowed
allocation unit of space to a disk file.
The idea of requiring space to be allocated in multiples of
sectors is that this will reduce the number of
<a class="reference internal" href="#term-extent"><span class="xref std std-term">extents</span></a> required to store the file, which
reduces the expected number of <a class="reference internal" href="#term-seek"><span class="xref std std-term">seek</span></a> operations reuquired
to process a series of <a class="reference internal" href="#term-disk-access"><span class="xref std std-term">disk accesses</span></a> to
the file.
The disadvantage of large cluster size is that it increases
<a class="reference internal" href="#term-internal-fragmentation"><span class="xref std std-term">internal fragmentation</span></a> since any space not actually
used by the file in the last cluster is wasted.</p>
</dd>
<dt id="term-code-generation">code generation<a class="headerlink" href="#term-code-generation" title="Permalink to this term">¶</a></dt><dd><p>A phase in a <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a> that transforms
<a class="reference internal" href="#term-intermediate-code"><span class="xref std std-term">intermediate code</span></a> into the final executable form of the
code.
More generally, this can refer to the process of turning a parse
tree (that determines the correctness of the structure of the
program) into actual instructions that the computer can execute.</p>
</dd>
<dt id="term-code-optimization">code optimization<a class="headerlink" href="#term-code-optimization" title="Permalink to this term">¶</a></dt><dd><p>A phase in a <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a> that makes changes in the code
(typically <a class="reference internal" href="#term-assembly-code"><span class="xref std std-term">assembly code</span></a>) with the goal of replacing
it with a version of the code that will run faster while
performing the same computation.</p>
</dd>
<dt id="term-cohesion">cohesion<a class="headerlink" href="#term-cohesion" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming</span></a>,
a term that refers to the degree to which a class has a single
well-defined role or responsibility.</p>
</dd>
<dt id="term-Collatz-sequence">Collatz sequence<a class="headerlink" href="#term-Collatz-sequence" title="Permalink to this term">¶</a></dt><dd><p>For a given integer value <span class="math notranslate nohighlight">\(n\)</span>, the sequence of numbers
that derives from performing the following computatin on <span class="math notranslate nohighlight">\(n\)</span></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ODD</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>This is famous because, while it terminates for any value of
<span class="math notranslate nohighlight">\(n\)</span> that you try, it has never been proven to be a fact
that this always terminates.</p>
</dd>
<dt id="term-collision">collision<a class="headerlink" href="#term-collision" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-hash-system"><span class="xref std std-term">hash system</span></a>, this refers to the case where two
search <a class="reference internal" href="#term-key"><span class="xref std std-term">keys</span></a> are mapped by the
<a class="reference internal" href="#term-hash-function"><span class="xref std std-term">hash function</span></a> to the same
slot in the <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>.
This can happen on insertion or search when another record has
already been hashed to that slot.
In this case, a <a class="reference internal" href="#term-closed-hash-system"><span class="xref std std-term">closed hash system</span></a> will require a
process known as <a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a> to find the
location of the desired record.</p>
</dd>
<dt id="term-collision-resolution">collision resolution<a class="headerlink" href="#term-collision-resolution" title="Permalink to this term">¶</a></dt><dd><p>The outcome of a <a class="reference internal" href="#term-collision-resolution-policy"><span class="xref std std-term">collision resolution policy</span></a>.</p>
</dd>
<dt id="term-collision-resolution-policy">collision resolution policy<a class="headerlink" href="#term-collision-resolution-policy" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, the process of resolving a
<a class="reference internal" href="#term-collision"><span class="xref std std-term">collision</span></a>.
Specifically in a <a class="reference internal" href="#term-closed-hash-system"><span class="xref std std-term">closed hash system</span></a>, this is the
process of finding the proper position in a <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>
that contains the
desired record if the <a class="reference internal" href="#term-hash-function"><span class="xref std std-term">hash function</span></a> did not return the
correct position for that record due to a <a class="reference internal" href="#term-collision"><span class="xref std std-term">collision</span></a> with
another record.</p>
</dd>
<dt id="term-comparable">comparable<a class="headerlink" href="#term-comparable" title="Permalink to this term">¶</a></dt><dd><p>The concept that two objects can be compared to determine if they
are equal or not, or to determine which one is greater than the
other.
In set notation, elements <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> of a set are
comparable under a given relation <span class="math notranslate nohighlight">\(R\)</span> if either
<span class="math notranslate nohighlight">\(xRy\)</span> or <span class="math notranslate nohighlight">\(yRx\)</span>.
To be reliably compared for a greater/lesser relationship,
the values being compared must belong to a <a class="reference internal" href="#term-total-order"><span class="xref std std-term">total order</span></a>.
In programming, the property of a data type such that two
elements of the type can be compared to determine if they the
same (a weaker version), or which of the two is larger (a
stronger version).
<code class="docutils literal notranslate"><span class="pre">Comparable</span></code> is also the name of an <a class="reference internal" href="#term-interface"><span class="xref std std-term">interface</span></a> in Java that
asserts a comparable relationship between objects with a class,
and <code class="docutils literal notranslate"><span class="pre">.compareTo()</span></code> is the <code class="docutils literal notranslate"><span class="pre">Comparable</span></code> interface method that
implements the actual comparison between two objects of the class.</p>
</dd>
<dt id="term-comparator">comparator<a class="headerlink" href="#term-comparator" title="Permalink to this term">¶</a></dt><dd><p>A function given as a parameter to a method of a library
(or alternatively, a parameter for a C++ template or a Java
generic).
The comparator function concept provides a generic way
encapulates the process of performing a comparison between two
objects of a specific type.
For example, if we want to write a generic sorting routine, that
can handle any record type, we can require that the user of the
sorting routine pass in a comparator function
to define how records in the collection are to be compared.</p>
</dd>
<dt id="term-comparison">comparison<a class="headerlink" href="#term-comparison" title="Permalink to this term">¶</a></dt><dd><p>The act of comparing two <a class="reference internal" href="#term-key"><span class="xref std std-term">keys</span></a> or
<a class="reference internal" href="#term-record"><span class="xref std std-term">records</span></a>.
For many <a class="reference internal" href="#term-data-type"><span class="xref std std-term">data types</span></a>, a comparison has
constant time cost.
The number of comparisons required is often used as a
<a class="reference internal" href="#term-measure-of-cost"><span class="xref std std-term">measure of cost</span></a> for sorting and searching algorithms.</p>
</dd>
<dt id="term-compile-time-polymorphism">compile-time polymorphism<a class="headerlink" href="#term-compile-time-polymorphism" title="Permalink to this term">¶</a></dt><dd><p>A form of <a class="reference internal" href="#term-polymorphism"><span class="xref std std-term">polymorphism</span></a> known as Overloading.
Overloaded methods have the same names, but different signatures
as a method available elsewhere in the class.
Compare to <a class="reference internal" href="#term-run-time-polymorphism"><span class="xref std std-term">run-time polymorphism</span></a>.</p>
</dd>
<dt id="term-compiler">compiler<a class="headerlink" href="#term-compiler" title="Permalink to this term">¶</a></dt><dd><p>A computer program that reads computer programs and converts
them into a form that can be directly excecuted by some form of
computer.
The major phases in a compiler include <a class="reference internal" href="#term-lexical-analysis"><span class="xref std std-term">lexical analysis</span></a>,
<a class="reference internal" href="#term-syntax-analysis"><span class="xref std std-term">syntax analysis</span></a>, <a class="reference internal" href="#term-intermediate-code-generation"><span class="xref std std-term">intermediate code generation</span></a>,
<a class="reference internal" href="#term-code-optimization"><span class="xref std std-term">code optimization</span></a>, and <a class="reference internal" href="#term-code-generation"><span class="xref std std-term">code generation</span></a>.
More broadly, a compiler can be viewed as <a class="reference internal" href="#term-parser"><span class="xref std std-term">parsing</span></a> the program to verify that it is syntactically
correct, and then doing <a class="reference internal" href="#term-code-generation"><span class="xref std std-term">code generation</span></a> to convert the
hig-level program into something that the computer can execute.</p>
</dd>
<dt id="term-complete-binary-tree">complete binary tree<a class="headerlink" href="#term-complete-binary-tree" title="Permalink to this term">¶</a></dt><dd><p>A binary tree where the nodes are filled in row by row, with the
bottom row filled in left to right.
Due to this requirement, there is only one tree of <span class="math notranslate nohighlight">\(n\)</span>
nodes for any value of <span class="math notranslate nohighlight">\(n\)</span>.
Since storing the records in an <a class="reference internal" href="#term-array"><span class="xref std std-term">array</span></a> in row order leads to a
simple mapping from a node’s position in the array to its
<a class="reference internal" href="#term-parent"><span class="xref std std-term">parent</span></a>, <a class="reference internal" href="#term-sibling"><span class="xref std std-term">siblings</span></a>, and
<a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a>, the array representation is most
commonly used to implement the complete binary tree.
The <a class="reference internal" href="#term-heap"><span class="xref std std-term">heap</span></a> data structure is a complete binary tree with
partial ordering constraints on the node values.</p>
</dd>
<dt id="term-complete-graph">complete graph<a class="headerlink" href="#term-complete-graph" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> where every <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertex</span></a> connects to every
other vertex.</p>
</dd>
<dt id="term-complex-number">complex number<a class="headerlink" href="#term-complex-number" title="Permalink to this term">¶</a></dt><dd><p>In mathematics, an imaginary number, that is, a number with a
real component and an imaginary component.</p>
</dd>
<dt id="term-Composite-design-pattern">Composite design pattern<a class="headerlink" href="#term-Composite-design-pattern" title="Permalink to this term">¶</a></dt><dd><p>Given a class hierarchy representing a set of objects, and a
container for a collection of objects, the composite
<a class="reference internal" href="#term-design-pattern"><span class="xref std std-term">design pattern</span></a> addresses the relationship between the
object hierarchy and a bunch of behaviors on the objects.
In the composite design, each object is required to implement
the collection of behaviors.
This is in contrast to the procedural approach where a behavior
(such as a tree <a class="reference internal" href="#term-traversal"><span class="xref std std-term">traversal</span></a>) is implemented as a
method on  the object collection (such as a <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a>).
Procedural tree traversal requires that the tree have a method
that understands what to do when it encounters any of the object
types (<a class="reference internal" href="#term-internal-node"><span class="xref std std-term">internal</span></a> or
<a class="reference internal" href="#term-leaf-node"><span class="xref std std-term">leaf nodes</span></a>) that the tree might contain.
The composite approach would have the tree call the “traversal”
method on its root node, which then knows how to perform the
“traversal” behavior.
This might in turn require invoking the traversal method of
other objects (in this case, the children of the root).</p>
</dd>
<dt id="term-composite-type">composite type<a class="headerlink" href="#term-composite-type" title="Permalink to this term">¶</a></dt><dd><p>A type whose <a class="reference internal" href="#term-member"><span class="xref std std-term">members</span></a> have subparts.
For example, a typical database record.
Another term for this is <a class="reference internal" href="#term-aggregate-type"><span class="xref std std-term">aggregate type</span></a>.</p>
</dd>
<dt id="term-composition">composition<a class="headerlink" href="#term-composition" title="Permalink to this term">¶</a></dt><dd><p>Relationships between classes based on usage rather than
<a class="reference internal" href="#term-inherit"><span class="xref std std-term">inheritance</span></a>, i.e. a <strong>HAS-A</strong> relationship.
For example, some code in class ‘A’ has a <a class="reference internal" href="#term-reference"><span class="xref std std-term">reference</span></a> to some
other class ‘B’.</p>
</dd>
<dt id="term-computability">computability<a class="headerlink" href="#term-computability" title="Permalink to this term">¶</a></dt><dd><p>A branch of computer science that deals with the theory of
solving problems through computation.
More specificially, it deals with the limits to what problems
(functions) are computable.
An example of a famous problem that cannot in principle be
solved by a computer is the <a class="reference internal" href="#term-halting-problem"><span class="xref std std-term">halting problem</span></a>.</p>
</dd>
<dt id="term-computation">computation<a class="headerlink" href="#term-computation" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-Finite-Automata"><span class="xref std std-term">finite automata</span></a>, a computation is a sequence of
<a class="reference internal" href="#term-configuration"><span class="xref std std-term">configurations</span></a> for some
length <span class="math notranslate nohighlight">\(n \geq 0\)</span>.
In general, it is a series of operations that the machine
performs.</p>
</dd>
<dt id="term-computational-complexity-theory">computational complexity theory<a class="headerlink" href="#term-computational-complexity-theory" title="Permalink to this term">¶</a></dt><dd><p>A branch of the theory of computation in theoretical computer
science and mathematics that focuses on classifying
computational problems according to their inherent difficulty,
and relating those classes to each other.
An example is the study of <a class="reference internal" href="#term-NP-Complete"><span class="xref std std-term">NP-Complete</span></a> problems.</p>
</dd>
<dt id="term-configuration">configuration<a class="headerlink" href="#term-configuration" title="Permalink to this term">¶</a></dt><dd><p>For a <a class="reference internal" href="#term-Finite-Automata"><span class="xref std std-term">finite automata</span></a>, a complete specification for the
current condition of the machine on some input string.
This includes the current <a class="reference internal" href="#term-state"><span class="xref std std-term">state</span></a> that the machine is in,
and the current condition of the string, including which
character is about to be processed.</p>
</dd>
<dt id="term-Conjunctive-Normal-Form">Conjunctive Normal Form<a class="headerlink" href="#term-Conjunctive-Normal-Form" title="Permalink to this term">¶</a></dt><dt id="term-CNF">CNF<a class="headerlink" href="#term-CNF" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-Boolean-expression"><span class="xref std std-term">Boolean expression</span></a> written as a series of
<a class="reference internal" href="#term-clause"><span class="xref std std-term">clauses</span></a> that are AND’ed together.</p>
</dd>
<dt id="term-connected-component">connected component<a class="headerlink" href="#term-connected-component" title="Permalink to this term">¶</a></dt><dd><p>In an <a class="reference internal" href="#term-undirected-graph"><span class="xref std std-term">undirected graph</span></a>, a <a class="reference internal" href="#term-subset"><span class="xref std std-term">subset</span></a> of the
<a class="reference internal" href="#term-node"><span class="xref std std-term">nodes</span></a> such that each node in the subset can be
reached from any other node in that subset.</p>
</dd>
<dt id="term-connected-graph">connected graph<a class="headerlink" href="#term-connected-graph" title="Permalink to this term">¶</a></dt><dd><p>An <a class="reference internal" href="#term-undirected-graph"><span class="xref std std-term">undirected graph</span></a> is a connected graph if there is at
least one path from any <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertex</span></a> to any other.</p>
</dd>
<dt id="term-constant-running-time">constant running time<a class="headerlink" href="#term-constant-running-time" title="Permalink to this term">¶</a></dt><dd><p>The cost of a function whose running time is not related to its
input size.
In Theta notation, this is traditionally written as
<span class="math notranslate nohighlight">\(\Theta(1)\)</span>.</p>
</dd>
<dt id="term-constructive-induction">constructive induction<a class="headerlink" href="#term-constructive-induction" title="Permalink to this term">¶</a></dt><dd><p>A process for finding the
<a class="reference internal" href="#term-closed-form-solution"><span class="xref std std-term">closed form</span></a> for a
<a class="reference internal" href="#term-recurrence-relation"><span class="xref std std-term">recurrence relation</span></a>,
that involves substituting in a guess for the closed form to
replace the recursive part(s) of the recurrence.
Depending on the goal (typically either to show that the
hypothesized growth rate is right, or to find the precise
constants), one then manipulates the resulting non-recursive
equation.</p>
</dd>
<dt id="term-container">container<a class="headerlink" href="#term-container" title="Permalink to this term">¶</a></dt><dt id="term-container-class">container class<a class="headerlink" href="#term-container-class" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-data-structure"><span class="xref std std-term">data structure</span></a> that stores a collection of
<a class="reference internal" href="#term-record"><span class="xref std std-term">records</span></a>.
Typical examples are <a class="reference internal" href="#term-array"><span class="xref std std-term">arrays</span></a>,
<a class="reference internal" href="#term-search-tree"><span class="xref std std-term">search trees</span></a>, and
<a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash tables</span></a>.</p>
</dd>
<dt id="term-context-free-grammar">context-free grammar<a class="headerlink" href="#term-context-free-grammar" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-grammar"><span class="xref std std-term">grammar</span></a> comprised only of productions of the form
<span class="math notranslate nohighlight">\(A \rightarrow x\)</span> where <span class="math notranslate nohighlight">\(A\)</span> is a
<a class="reference internal" href="#term-non-terminal"><span class="xref std std-term">non-terminal</span></a> and <span class="math notranslate nohighlight">\(x\)</span> is a series of one or more
<a class="reference internal" href="#term-terminal"><span class="xref std std-term">terminals</span></a> and non-terminals.
That is, the given non-terminal <span class="math notranslate nohighlight">\(A\)</span> can be replaced at any
time.</p>
</dd>
<dt id="term-context-free-language">context-free language<a class="headerlink" href="#term-context-free-language" title="Permalink to this term">¶</a></dt><dt id="term-CFL">CFL<a class="headerlink" href="#term-CFL" title="Permalink to this term">¶</a></dt><dd><p>The set of <a class="reference internal" href="#term-language"><span class="xref std std-term">languages</span></a> that can be defined by
<a class="reference internal" href="#term-context-sensitive-grammar"><span class="xref std std-term">context-sensitive grammars</span></a>.</p>
</dd>
<dt id="term-context-sensitive-grammar">context-sensitive grammar<a class="headerlink" href="#term-context-sensitive-grammar" title="Permalink to this term">¶</a></dt><dt id="term-CFG">CFG<a class="headerlink" href="#term-CFG" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-grammar"><span class="xref std std-term">grammar</span></a> comprised only of productions of the form
<span class="math notranslate nohighlight">\(xAy \rightarrow xvy\)</span> where <span class="math notranslate nohighlight">\(A\)</span> is a
<a class="reference internal" href="#term-non-terminal"><span class="xref std std-term">non-terminal</span></a> and <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are each a
series of one or more
<a class="reference internal" href="#term-terminal"><span class="xref std std-term">terminals</span></a> and non-terminals.
That is, the given non-terminal <span class="math notranslate nohighlight">\(A\)</span> can be replaced only
when it is within the proper context.</p>
</dd>
<dt id="term-cost">cost<a class="headerlink" href="#term-cost" title="Permalink to this term">¶</a></dt><dd><p>The amount of resources that the solution consumes.</p>
</dd>
<dt id="term-cost-model">cost model<a class="headerlink" href="#term-cost-model" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-algorithm-analysis"><span class="xref std std-term">algorithm analysis</span></a>, a definition for the cost of each
<a class="reference internal" href="#term-basic-operation"><span class="xref std std-term">basic operation</span></a> performed by the algorithm,
along with a definition for the size of the input.
Having these definitions allows us to calculate the <a class="reference internal" href="#term-cost"><span class="xref std std-term">cost</span></a>
to run the algorithm on a given input, and from there determine
the <a class="reference internal" href="#term-growth-rate"><span class="xref std std-term">growth rate</span></a> of the algorithm.
A cost model would be considered “good” if it yields predictions
that conform to our understanding of reality.</p>
</dd>
<dt id="term-countably-infinite">countably infinite<a class="headerlink" href="#term-countably-infinite" title="Permalink to this term">¶</a></dt><dt id="term-countable">countable<a class="headerlink" href="#term-countable" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-set"><span class="xref std std-term">set</span></a> is countably infinite if it contains a finite
number of elements, or (for a set with an infinite number of
elements) if there exists a one-to-one mapping from
the set to the set of integers.</p>
</dd>
<dt id="term-CPU">CPU<a class="headerlink" href="#term-CPU" title="Permalink to this term">¶</a></dt><dd><p>Acronym for Central Processing Unit, the primary processing
device for a computer.</p>
</dd>
<dt id="term-current-position">current position<a class="headerlink" href="#term-current-position" title="Permalink to this term">¶</a></dt><dd><p>A property of some list ADTs, where there is maintained a
“current position” state that can be referred to later.</p>
</dd>
<dt id="term-cycle">cycle<a class="headerlink" href="#term-cycle" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> terminology,
a <a class="reference internal" href="#term-cycle"><span class="xref std std-term">cycle</span></a> is a <a class="reference internal" href="#term-path"><span class="xref std std-term">path</span></a> of length three or more that
connects some <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertex</span></a> <span class="math notranslate nohighlight">\(v_1\)</span> to itself.</p>
</dd>
<dt id="term-cylinder">cylinder<a class="headerlink" href="#term-cylinder" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a> normally consists of a stack of
<a class="reference internal" href="#term-platter"><span class="xref std std-term">platters</span></a>.
While this might not be so true today, traditionally all of the
<a class="reference internal" href="#term-I-O-head"><span class="xref std std-term">I/O heads</span></a> moved together during a
<a class="reference internal" href="#term-seek"><span class="xref std std-term">seek</span></a> operation.
Thus, when a given I/O head is positioned over a particular
<a class="reference internal" href="#term-track"><span class="xref std std-term">track</span></a> on a platter, the other I/O heads are also
positioned over the corresponding track on their platters.
That collection of tracks is called a cylinder.
A given cylinder represents all of the data that can be read
from all of the platters without doing another seek operation.</p>
</dd>
<dt id="term-cylinder-index">cylinder index<a class="headerlink" href="#term-cylinder-index" title="Permalink to this term">¶</a></dt><dd><p>In the <a class="reference internal" href="#term-ISAM"><span class="xref std std-term">ISAM</span></a> system, a simple <a class="reference internal" href="#term-linear-index"><span class="xref std std-term">linear index</span></a> that
stores the lowest key value stored in each <a class="reference internal" href="#term-cylinder"><span class="xref std std-term">cylinder</span></a>.</p>
</dd>
<dt id="term-cylinder-overflow">cylinder overflow<a class="headerlink" href="#term-cylinder-overflow" title="Permalink to this term">¶</a></dt><dd><p>In the <a class="reference internal" href="#term-ISAM"><span class="xref std std-term">ISAM</span></a> system, this is space reserved for storing
any records that can not fit in their respective
<a class="reference internal" href="#term-cylinder"><span class="xref std std-term">cylinder</span></a>.</p>
</dd>
<dt id="term-DAG">DAG<a class="headerlink" href="#term-DAG" title="Permalink to this term">¶</a></dt><dd><p>Abbreviation for <a class="reference internal" href="#term-directed-acyclic-graph"><span class="xref std std-term">directed acyclic graph</span></a>.</p>
</dd>
<dt id="term-data-field">data field<a class="headerlink" href="#term-data-field" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming</span></a>,
a synonym for <a class="reference internal" href="#term-data-member"><span class="xref std std-term">data member</span></a>.</p>
</dd>
<dt id="term-data-item">data item<a class="headerlink" href="#term-data-item" title="Permalink to this term">¶</a></dt><dd><p>A piece of information or a record whose value is drawn from a type.</p>
</dd>
<dt id="term-data-member">data member<a class="headerlink" href="#term-data-member" title="Permalink to this term">¶</a></dt><dd><p>The variables that together define the space required by a data
item are referred to as data members.
Some of the commonly used synonyms include <a class="reference internal" href="#term-data-field"><span class="xref std std-term">data field</span></a>,
<a class="reference internal" href="#term-attribute"><span class="xref std std-term">attribute</span></a>, and <a class="reference internal" href="#term-instance-variable"><span class="xref std std-term">instance variable</span></a>.</p>
</dd>
<dt id="term-data-structure">data structure<a class="headerlink" href="#term-data-structure" title="Permalink to this term">¶</a></dt><dd><p>The implementation for an <a class="reference internal" href="#term-ADT"><span class="xref std std-term">ADT</span></a>.</p>
</dd>
<dt id="term-data-type">data type<a class="headerlink" href="#term-data-type" title="Permalink to this term">¶</a></dt><dd><p>A type together with a collection of operations to manipulate
the type.</p>
</dd>
<dt id="term-deallocated">deallocated<a class="headerlink" href="#term-deallocated" title="Permalink to this term">¶</a></dt><dt id="term-deallocation">deallocation<a class="headerlink" href="#term-deallocation" title="Permalink to this term">¶</a></dt><dd><p>Free the memory allocated to an unused object.</p>
</dd>
<dt id="term-debugging">debugging<a class="headerlink" href="#term-debugging" title="Permalink to this term">¶</a></dt><dd><p>Correcting a program once we determine that it is not operating
as we intend. This is in contrast to <a class="reference internal" href="#term-testing"><span class="xref std std-term">testing</span></a>.</p>
</dd>
<dt id="term-decideability">decideability<a class="headerlink" href="#term-decideability" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-computability"><span class="xref std std-term">computability</span></a> theory, the question of whether a
question can be answered.
A typical example is whether to instances within a system are
equivalent.
“Do two computer programs do the same thing?”
is a variation of the <a class="reference internal" href="#term-halting-problem"><span class="xref std std-term">halting problem</span></a> (and is not
decideable).
“Do two <a class="reference internal" href="#term-DFA"><span class="xref std std-term">DFAs</span></a> do the same thing?” is decideable.</p>
</dd>
<dt id="term-decision-problem">decision problem<a class="headerlink" href="#term-decision-problem" title="Permalink to this term">¶</a></dt><dd><p>A problem whose output is either “YES” or “NO”.</p>
</dd>
<dt id="term-decision-tree">decision tree<a class="headerlink" href="#term-decision-tree" title="Permalink to this term">¶</a></dt><dd><p>A theoretical construct for modeling the behavior of algorithms.
Each point at which the algorithm makes a decision (such as an
if statement) is modeled by a branch in the tree that represents
the algorithms behavior.
Decision trees can be used in
<a class="reference internal" href="#term-lower-bounds-proof"><span class="xref std std-term">lower bounds proofs</span></a>,
such as the proof that sorting requires
<span class="math notranslate nohighlight">\(\Omega(n \log n)\)</span> comparisons in the <a class="reference internal" href="#term-worst-case"><span class="xref std std-term">worst case</span></a>.</p>
</dd>
<dt id="term-deep-copy">deep copy<a class="headerlink" href="#term-deep-copy" title="Permalink to this term">¶</a></dt><dd><p>Copying the actual content of a <a class="reference internal" href="#term-pointee"><span class="xref std std-term">pointee</span></a>.</p>
</dd>
<dt id="term-degree">degree<a class="headerlink" href="#term-degree" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> terminology, the degree for a <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertex</span></a> is
its number of <a class="reference internal" href="#term-neighbor"><span class="xref std std-term">neighbors</span></a>.
In a <a class="reference internal" href="#term-directed-graph"><span class="xref std std-term">directed graph</span></a>, the <a class="reference internal" href="#term-in-degree"><span class="xref std std-term">in degree</span></a> is the number
of edges directed into the vertex, and the <a class="reference internal" href="#term-out-degree"><span class="xref std std-term">out degree</span></a> is
the number of edges directed out of the vertex.
In <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a> terminology, the degree for a <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> is
its number of <a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a>.</p>
</dd>
<dt id="term-delegation-mental-model-for-recursion">delegation mental model for recursion<a class="headerlink" href="#term-delegation-mental-model-for-recursion" title="Permalink to this term">¶</a></dt><dd><p>A way of thinking about the process of <a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursion</span></a>.
The recursive function “delegates” most of the work when it
makes the recursive call.
The advantage of the delegation mental model for recursion is
that you don’t need to think about how the delegated task is
performed.
It just gets done.</p>
</dd>
<dt id="term-dense-graph">dense graph<a class="headerlink" href="#term-dense-graph" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> where the actual number of <a class="reference internal" href="#term-edge"><span class="xref std std-term">edges</span></a>
is a large fraction of the possible number of edges.
Generally, this is interpreted to mean that the <a class="reference internal" href="#term-degree"><span class="xref std std-term">degree</span></a>
for any <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertex</span></a> in the graph is relatively high.</p>
</dd>
<dt id="term-depth">depth<a class="headerlink" href="#term-depth" title="Permalink to this term">¶</a></dt><dd><p>The depth of a node <span class="math notranslate nohighlight">\(M\)</span> in a tree is the length
of the path from the root of the tree to <span class="math notranslate nohighlight">\(M\)</span>.</p>
</dd>
<dt id="term-depth-first-search">depth-first search<a class="headerlink" href="#term-depth-first-search" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> <a class="reference internal" href="#term-traversal"><span class="xref std std-term">traversal</span></a> algorithm.
Whenever a <span class="math notranslate nohighlight">\(v\)</span> is <a class="reference internal" href="#term-visit"><span class="xref std std-term">visited</span></a> during the
traversal, DFS will <a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursively</span></a> visit all of
<span class="math notranslate nohighlight">\(v\)</span> ‘s <a class="reference internal" href="#term-unvisited"><span class="xref std std-term">unvisited</span></a> <a class="reference internal" href="#term-neighbor"><span class="xref std std-term">neighbors</span></a>.</p>
</dd>
<dt id="term-depth-first-search-tree">depth-first search tree<a class="headerlink" href="#term-depth-first-search-tree" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a> that can be defined by the operation of a
<a class="reference internal" href="#term-depth-first-search"><span class="xref std std-term">depth-first search</span></a> (DFS) on a <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a>.
This tree would consist of the <a class="reference internal" href="#term-node"><span class="xref std std-term">nodes</span></a> of the graph
and a subset of the <a class="reference internal" href="#term-edge"><span class="xref std std-term">edges</span></a> of the graph that was
followed during the DFS.</p>
</dd>
<dt id="term-dequeue">dequeue<a class="headerlink" href="#term-dequeue" title="Permalink to this term">¶</a></dt><dd><p>A specialized term used to indicate removing an element from a queue.</p>
</dd>
<dt id="term-dereference">dereference<a class="headerlink" href="#term-dereference" title="Permalink to this term">¶</a></dt><dd><p>Accessing the value of the <a class="reference internal" href="#term-pointee"><span class="xref std std-term">pointee</span></a> for some
<a class="reference internal" href="#term-reference"><span class="xref std std-term">reference</span></a> variable.
Commonly, this happens in a language like Java when using the
“dot” operator to access some field of an object.</p>
</dd>
<dt id="term-derivation">derivation<a class="headerlink" href="#term-derivation" title="Permalink to this term">¶</a></dt><dd><p>In formal languages, the process of executing a series of
<a class="reference internal" href="#term-production-rule"><span class="xref std std-term">production rules</span></a> from a <a class="reference internal" href="#term-grammar"><span class="xref std std-term">grammar</span></a>.
A typical example of a derivation would be the series of
productions executed to go from the <a class="reference internal" href="#term-start-symbol"><span class="xref std std-term">start symbol</span></a> to a
given string.</p>
</dd>
<dt id="term-descendant">descendant<a class="headerlink" href="#term-descendant" title="Permalink to this term">¶</a></dt><dd><p>In a tree, the set of all nodes that have a node <span class="math notranslate nohighlight">\(A\)</span> as an
<a class="reference internal" href="#term-ancestor"><span class="xref std std-term">ancestor</span></a> are the descendants of <span class="math notranslate nohighlight">\(A\)</span>.
In other words, all of the nodes that can be reached from
<span class="math notranslate nohighlight">\(A\)</span> by progressing downwards in tree.
Another way to say it is: The
<a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a> of <span class="math notranslate nohighlight">\(A\)</span>, their children, and so
on.</p>
</dd>
<dt id="term-deserialization">deserialization<a class="headerlink" href="#term-deserialization" title="Permalink to this term">¶</a></dt><dd><p>The process of returning a <a class="reference internal" href="#term-serialization"><span class="xref std std-term">serialized</span></a>
representation for a data structure back to its original
in-memory form.</p>
</dd>
<dt id="term-design-pattern">design pattern<a class="headerlink" href="#term-design-pattern" title="Permalink to this term">¶</a></dt><dd><p>An abstraction for describing the design of programs,
that is, the interactions of objects and classes.
Experienced software designers learn and reuse patterns
for combining software components, and design patterns allow
this design knowledge to be passed on to new programmers more quickly.</p>
</dd>
<dt id="term-deterministic">deterministic<a class="headerlink" href="#term-deterministic" title="Permalink to this term">¶</a></dt><dd><p>Any <a class="reference internal" href="#term-Finite-Automata"><span class="xref std std-term">finite automata</span></a> in which, for every pair of
<a class="reference internal" href="#term-state"><span class="xref std std-term">state</span></a> and symbol, there is only a single transition.
This means that whenever the machine is in a given state and
sees a given symbol, only a single thing can happen.
This is in contrast to a <a class="reference internal" href="#term-non-deterministic"><span class="xref std std-term">non-deterministic</span></a> finite
automata, which has at least one state with multiple transitions
on at least one symbol.</p>
</dd>
<dt id="term-deterministic-algorithm">deterministic algorithm<a class="headerlink" href="#term-deterministic-algorithm" title="Permalink to this term">¶</a></dt><dd><p>An algorithm that does not involve any element of randomness,
and so its behavior on a given input will always be the same.
This is in contrast to a <a class="reference internal" href="#term-randomized-algorithm"><span class="xref std std-term">randomized algorithm</span></a>.</p>
</dd>
<dt id="term-Deterministic-Finite-Automata">Deterministic Finite Automata<a class="headerlink" href="#term-Deterministic-Finite-Automata" title="Permalink to this term">¶</a></dt><dt id="term-Deterministic-Finite-Acceptor">Deterministic Finite Acceptor<a class="headerlink" href="#term-Deterministic-Finite-Acceptor" title="Permalink to this term">¶</a></dt><dt id="term-DFA">DFA<a class="headerlink" href="#term-DFA" title="Permalink to this term">¶</a></dt><dd><p>An <a class="reference internal" href="#term-automata"><span class="xref std std-term">automata</span></a> or abstract machine that can process an
input string (shown on a tape) from left to right.
There is a control unit (with <a class="reference internal" href="#term-state"><span class="xref std std-term">states</span></a>),
behavior defined for what to do when in a given state and with a
given symbol on the current square of the tape.
All that we can “do” is change state before going to the next
letter to the right.</p>
</dd>
<dt id="term-DFS">DFS<a class="headerlink" href="#term-DFS" title="Permalink to this term">¶</a></dt><dd><p>Abbreviation for <a class="reference internal" href="#term-depth-first-search"><span class="xref std std-term">depth-first search</span></a>.</p>
</dd>
<dt id="term-diagonalization-argument">diagonalization argument<a class="headerlink" href="#term-diagonalization-argument" title="Permalink to this term">¶</a></dt><dd><p>A proof technique for proving that a set is
<a class="reference internal" href="#term-uncountably-infinite"><span class="xref std std-term">uncountably infinite</span></a>.
The approach is to show that, no matter what order the elements
of the set are put in, a new element of the set can be
constructed that is not in that ordering.
This is done by changing the <span class="math notranslate nohighlight">\(i\)</span> th value or position of
the element to be different from that of the <span class="math notranslate nohighlight">\(i\)</span> th
element in the proposed ordering.</p>
</dd>
<dt id="term-dictionary">dictionary<a class="headerlink" href="#term-dictionary" title="Permalink to this term">¶</a></dt><dd><p>An abstract data type or <a class="reference internal" href="#term-interface"><span class="xref std std-term">interface</span></a> for a data structure or
software subsystem that supports insertion, search, and deletion
of records.</p>
</dd>
<dt id="term-dictionary-search">dictionary search<a class="headerlink" href="#term-dictionary-search" title="Permalink to this term">¶</a></dt><dd><p>A close relative of an <a class="reference internal" href="#term-interpolation-search"><span class="xref std std-term">interpolation search</span></a>.
In a classical (paper) dictionary of words in a natural
language, there are markings for where in the dictionary the
words with a given letter start.
So in typical usage of such a dictionary, words are found by
opening the dictionary to some appropriate place within the
pages that contain words starting with that letter.</p>
</dd>
<dt id="term-digraph">digraph<a class="headerlink" href="#term-digraph" title="Permalink to this term">¶</a></dt><dd><p>Abbreviation for <a class="reference internal" href="#term-directed-graph"><span class="xref std std-term">directed graph</span></a>.</p>
</dd>
<dt id="term-Dijkstra-s-algorithm">Dijkstra’s algorithm<a class="headerlink" href="#term-Dijkstra-s-algorithm" title="Permalink to this term">¶</a></dt><dd><p>An algorithm to solve the
<a class="reference internal" href="#term-single-source-shortest-paths-problem"><span class="xref std std-term">single-source shortest paths problem</span></a> in a <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a>.
This is a <a class="reference internal" href="#term-greedy-algorithm"><span class="xref std std-term">greedy algorithm</span></a>.
It is nearly identical to <a class="reference internal" href="#term-Prim-s-algorithm"><span class="xref std std-term">Prim’s algorithm</span></a> for finding a
<a class="reference internal" href="#term-minimal-cost-spanning-tree"><span class="xref std std-term">minimal-cost spanning tree</span></a>, with the only difference
being the calculation done to update the best-known distance.</p>
</dd>
<dt id="term-diminishing-increment-sort">diminishing increment sort<a class="headerlink" href="#term-diminishing-increment-sort" title="Permalink to this term">¶</a></dt><dd><p>Another name for <a class="reference internal" href="#term-Shellsort"><span class="xref std std-term">Shellsort</span></a>.</p>
</dd>
<dt id="term-direct-access">direct access<a class="headerlink" href="#term-direct-access" title="Permalink to this term">¶</a></dt><dd><p>A storage device, such as a disk drive, that has some ability to
move to a desired data location more-or-less directly.
This is in contrast to a <a class="reference internal" href="#term-sequential-access"><span class="xref std std-term">sequential access</span></a> storage
device such as a tape drive.</p>
</dd>
<dt id="term-direct-proof">direct proof<a class="headerlink" href="#term-direct-proof" title="Permalink to this term">¶</a></dt><dd><p>In general, a direct proof is just a “logical explanation”.
A direct proof is sometimes referred to as an argument by deduction.
This is simply an argument in terms of logic.
Often written in English with words such as “if … then”,
it could also be written with logic notation such as
<span class="math notranslate nohighlight">\(P \Rightarrow Q\)</span>.</p>
</dd>
<dt id="term-directed-acyclic-graph">directed acyclic graph<a class="headerlink" href="#term-directed-acyclic-graph" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> with no cycles.
Abbreviated as <a class="reference internal" href="#term-DAG"><span class="xref std std-term">DAG</span></a>.
Note that a DAG is not necessarily a <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a> since a given
<a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> might have multiple <a class="reference internal" href="#term-parent"><span class="xref std std-term">parents</span></a>.</p>
</dd>
<dt id="term-directed-edge">directed edge<a class="headerlink" href="#term-directed-edge" title="Permalink to this term">¶</a></dt><dd><p>An <a class="reference internal" href="#term-edge"><span class="xref std std-term">edge</span></a> that goes from <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertex</span></a> to another.
In contrast, an <a class="reference internal" href="#term-undirected-edge"><span class="xref std std-term">undirected edge</span></a> simply links to vertices
without a direction.</p>
</dd>
<dt id="term-directed-graph">directed graph<a class="headerlink" href="#term-directed-graph" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> whose <a class="reference internal" href="#term-edge"><span class="xref std std-term">edges</span></a> each are directed
from one of its defining <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertices</span></a> to the
other.</p>
</dd>
<dt id="term-dirty-bit">dirty bit<a class="headerlink" href="#term-dirty-bit" title="Permalink to this term">¶</a></dt><dd><p>Within a <a class="reference internal" href="#term-buffer-pool"><span class="xref std std-term">buffer pool</span></a>, a piece of information associated
with each <a class="reference internal" href="#term-buffer"><span class="xref std std-term">buffer</span></a> that indicates whether the contents of
the buffer have changed since being read in from
<a class="reference internal" href="#term-backing-storage"><span class="xref std std-term">backing storage</span></a>.
When the buffer is <a class="reference internal" href="#term-flush"><span class="xref std std-term">flushed</span></a> from the buffer pool,
the buffer’s contents must be written to the backing storage if
the dirty bit is set (that is, if the contents have changed).
This means that a relatively expensive write operation is
required.
In contrast, if the dirty bit is not set, then it is unnecessary
to write the contents to backing storage, thus saving time over
not keeping track of whether the contents have changed or not.</p>
</dd>
<dt id="term-Discrete-Fourier-Transform">Discrete Fourier Transform<a class="headerlink" href="#term-Discrete-Fourier-Transform" title="Permalink to this term">¶</a></dt><dt id="term-DFT">DFT<a class="headerlink" href="#term-DFT" title="Permalink to this term">¶</a></dt><dd><p>Let <span class="math notranslate nohighlight">\(a = [a_0, a_1, ..., a_{n-1}]^T\)</span> be a vector that
stores the coefficients for a polynomial being evaluated.
We can then do the calculations to evaluate the polynomial at
the <span class="math notranslate nohighlight">\(n\)</span> th <span class="math notranslate nohighlight">\(roots of unity &lt;nth roots of unit&gt;\)</span>
by multiplying the <span class="math notranslate nohighlight">\(A_{z}\)</span>
matrix by the coefficient vector.
The resulting vector <span class="math notranslate nohighlight">\(F_{z}\)</span> is called the
Discrete Fourier Transform (or DFT) for the polynomial.</p>
</dd>
<dt id="term-discriminator">discriminator<a class="headerlink" href="#term-discriminator" title="Permalink to this term">¶</a></dt><dd><p>A part of a <a class="reference internal" href="#term-multi-dimensional-search-key"><span class="xref std std-term">multi-dimensional search key</span></a>.
Certain tree data structures such as the <a class="reference internal" href="#term-bintree"><span class="xref std std-term">bintree</span></a> and the
<a class="reference internal" href="#term-kd-tree"><span class="xref std std-term">kd tree</span></a> operate by making branching decisions at nodes
of the tree based on a single attribute of the multi-dimensional
key, with the attribute determined by the level of the node in
the tree.
For example, in 2 dimensions, nodes at the odd levels in the
tree might branch based on the <span class="math notranslate nohighlight">\(x\)</span> value of a coordinate,
while at the even levels the tree would branch based on the
<span class="math notranslate nohighlight">\(y\)</span> value of the coordinate.
Thus, the <span class="math notranslate nohighlight">\(x\)</span> coordinate is the discriminator for the odd
levels, while the <span class="math notranslate nohighlight">\(y\)</span> coordinate is the discriminator for
the even levels.</p>
</dd>
<dt id="term-disjoint">disjoint<a class="headerlink" href="#term-disjoint" title="Permalink to this term">¶</a></dt><dd><p>Two parts of a <a class="reference internal" href="#term-data-structure"><span class="xref std std-term">data structure</span></a> or two
collections with no objects in common are disjoint.
This term is often used in conjunction with a data structure
that has <a class="reference internal" href="#term-node"><span class="xref std std-term">nodes</span></a> (such as a <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a>).
Also used in the context of <a class="reference internal" href="#term-set"><span class="xref std std-term">sets</span></a>, where two
<a class="reference internal" href="#term-subset"><span class="xref std std-term">subsets</span></a> are disjoint if they share no elements.</p>
</dd>
<dt id="term-disjoint-sets">disjoint sets<a class="headerlink" href="#term-disjoint-sets" title="Permalink to this term">¶</a></dt><dd><p>A collection of <a class="reference internal" href="#term-set"><span class="xref std std-term">sets</span></a>, any pair of which share no
elements in common.
A collection of disjoint sets partitions some objects
such that every object is in exactly one of the disjoint sets.</p>
</dd>
<dt id="term-disk-access">disk access<a class="headerlink" href="#term-disk-access" title="Permalink to this term">¶</a></dt><dd><p>The act of reading data from a disk drive (or other form of
<a class="reference internal" href="#term-peripheral-storage"><span class="xref std std-term">peripheral storage</span></a>).
The number of times data must be read from (or written to) a
disk is often a good measure of cost for an algorithm that
involves disk I/O, since this is usually the dominant cost.</p>
</dd>
<dt id="term-disk-controller">disk controller<a class="headerlink" href="#term-disk-controller" title="Permalink to this term">¶</a></dt><dd><p>The control mechanism for a <a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a>.
Responsible for the action of reading or writing a <a class="reference internal" href="#term-sector"><span class="xref std std-term">sector</span></a>
of data.</p>
</dd>
<dt id="term-disk-drive">disk drive<a class="headerlink" href="#term-disk-drive" title="Permalink to this term">¶</a></dt><dd><p>An example of <a class="reference internal" href="#term-peripheral-storage"><span class="xref std std-term">peripheral storage</span></a> or
<a class="reference internal" href="#term-secondary-storage"><span class="xref std std-term">secondary storage</span></a>.
Data access times are typically measured in thousandths of a
second (milliseconds), which
is roughly a million times slower than access times for
<a class="reference internal" href="#term-RAM"><span class="xref std std-term">RAM</span></a>, which is an example of a <a class="reference internal" href="#term-primary-storage"><span class="xref std std-term">primary storage</span></a>
device.
Reads from and writes to a disk drive are always done in terms
of some minimum size, which is typically called a
<a class="reference internal" href="#term-block"><span class="xref std std-term">block</span></a>.
The block size is 512 bytes on most disk drives.
Disk drives and RAM are typical parts of a computer’s
<a class="reference internal" href="#term-memory-hierarchy"><span class="xref std std-term">memory hierarchy</span></a>.</p>
</dd>
<dt id="term-disk-I-O">disk I/O<a class="headerlink" href="#term-disk-I-O" title="Permalink to this term">¶</a></dt><dd><p>Refers to the act of reading data from or writing data to a
<a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a>.
All disk reads and writes are done in units of a <a class="reference internal" href="#term-sector"><span class="xref std std-term">sector</span></a>
or <a class="reference internal" href="#term-block"><span class="xref std std-term">block</span></a>.</p>
</dd>
<dt id="term-disk-based-space-time-tradeoff">disk-based space/time tradeoff<a class="headerlink" href="#term-disk-based-space-time-tradeoff" title="Permalink to this term">¶</a></dt><dd><p>In contrast to the standard <a class="reference internal" href="#term-space-time-tradeoff"><span class="xref std std-term">space/time tradeoff</span></a>, this
principle states that the smaller you can make your disk storage
requirements, the faster your program will run.
This is because the time to read information from disk is
enormous compared to computation time, so almost any amount of
additional computation needed to unpack the data is going to be
less than the disk-reading time saved by reducing the storage
requirements.</p>
</dd>
<dt id="term-distance">distance<a class="headerlink" href="#term-distance" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> representations, a synonym for <a class="reference internal" href="#term-weight"><span class="xref std std-term">weight</span></a>.</p>
</dd>
<dt id="term-divide-and-conquer">divide and conquer<a class="headerlink" href="#term-divide-and-conquer" title="Permalink to this term">¶</a></dt><dd><p>A technique for designing algorithms where a solution is found
by breaking the problem into smaller (similar) subproblems,
solving the subproblems, then combining the subproblem solutions
to form the solution to the original problem.
This process is often implemented using <a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursion</span></a>.</p>
</dd>
<dt id="term-divide-and-conquer-recurrences">divide-and-conquer recurrences<a class="headerlink" href="#term-divide-and-conquer-recurrences" title="Permalink to this term">¶</a></dt><dd><p>A common form of <a class="reference internal" href="#term-recurrence-relation"><span class="xref std std-term">recurrence relation</span></a>
that have the form</p>
<div class="math notranslate nohighlight">
\[{\bf T}(n) = a{\bf T}(n/b) + cn^k; \quad {\bf T}(1) = c\]</div>
<p>where <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span>, <span class="math notranslate nohighlight">\(c\)</span>, and <span class="math notranslate nohighlight">\(k\)</span> are constants.
In general, this recurrence describes a problem of size <span class="math notranslate nohighlight">\(n\)</span>
divided into <span class="math notranslate nohighlight">\(a\)</span> subproblems of size <span class="math notranslate nohighlight">\(n/b\)</span>,
while <span class="math notranslate nohighlight">\(cn^k\)</span> is the amount of work necessary to combine the
partial solutions.</p>
</dd>
<dt id="term-divide-and-guess">divide-and-guess<a class="headerlink" href="#term-divide-and-guess" title="Permalink to this term">¶</a></dt><dd><p>A technique for finding a <a class="reference internal" href="#term-closed-form-solution"><span class="xref std std-term">closed-form solution</span></a> to a
<a class="reference internal" href="#term-summation"><span class="xref std std-term">summation</span></a> or <a class="reference internal" href="#term-recurrence-relation"><span class="xref std std-term">recurrence relation</span></a>.</p>
</dd>
<dt id="term-domain">domain<a class="headerlink" href="#term-domain" title="Permalink to this term">¶</a></dt><dd><p>The set of possible inputs to a function.</p>
</dd>
<dt id="term-double-buffering">double buffering<a class="headerlink" href="#term-double-buffering" title="Permalink to this term">¶</a></dt><dd><p>The idea of using multiple <a class="reference internal" href="#term-buffer"><span class="xref std std-term">buffers</span></a> to allow the
<a class="reference internal" href="#term-CPU"><span class="xref std std-term">CPU</span></a> to operate in parallel with a
<a class="reference internal" href="#term-peripheral-storage"><span class="xref std std-term">peripheral storage</span></a> device.
Once the first buffer’s worth of data has been read in, the CPU
can process this while the next block of data is being
read from the peripheral storage.
For this idea to work, the next block of data to be processed
must be known or predicted with reasonable accuracy.</p>
</dd>
<dt id="term-double-hashing">double hashing<a class="headerlink" href="#term-double-hashing" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a> method. A second hash
function is used to generate a value <span class="math notranslate nohighlight">\(c\)</span> on the key.
That value is then used by this key as the step size in
<a class="reference internal" href="#term-linear-probing-by-steps"><span class="xref std std-term">linear probing by steps</span></a>.
Since different keys use different step sizes (as generated by
the second hash function), this process avoids the clustering
caused by standard linear probing by steps.</p>
</dd>
<dt id="term-double-rotation">double rotation<a class="headerlink" href="#term-double-rotation" title="Permalink to this term">¶</a></dt><dd><p>A type of <a class="reference internal" href="#term-rebalancing-operation"><span class="xref std std-term">rebalancing operation</span></a> used by the
<a class="reference internal" href="#term-Splay-Tree"><span class="xref std std-term">Splay Tree</span></a> and <a class="reference internal" href="#term-AVL-Tree"><span class="xref std std-term">AVL Tree</span></a>.</p>
</dd>
<dt id="term-doubly-linked-list">doubly linked list<a class="headerlink" href="#term-doubly-linked-list" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-linked-list"><span class="xref std std-term">linked list</span></a> implementation variant where each list
node contains access pointers to both the previous element and
the next element on the list.</p>
</dd>
<dt id="term-DSA">DSA<a class="headerlink" href="#term-DSA" title="Permalink to this term">¶</a></dt><dd><p>Abbreviation for Data Structures and Algorithms.</p>
</dd>
<dt id="term-dynamic">dynamic<a class="headerlink" href="#term-dynamic" title="Permalink to this term">¶</a></dt><dd><p>Something that is changes (in contrast to <a class="reference internal" href="#term-static"><span class="xref std std-term">static</span></a>).
In computer programming, dynamic normally refers to something
that happens at run time.
For example, run-time analysis is analysis of the program’s
behavior, as opposed to its (static) text or structure
Dynamic binding or dynamic memory allocation occurs at run time.</p>
</dd>
<dt id="term-dynamic-allocation">dynamic allocation<a class="headerlink" href="#term-dynamic-allocation" title="Permalink to this term">¶</a></dt><dd><p>The act of creating an object from <a class="reference internal" href="#term-free-store"><span class="xref std std-term">free store</span></a>.
In C++, Java, and JavaScript, this is done using the <code class="docutils literal notranslate"><span class="pre">new</span></code>
operator.</p>
</dd>
<dt id="term-dynamic-array">dynamic array<a class="headerlink" href="#term-dynamic-array" title="Permalink to this term">¶</a></dt><dd><p>Arrays, once allocated, are of fixed size. A dynamic array puts
an <a class="reference internal" href="#term-interface"><span class="xref std std-term">interface</span></a> around the array so as to appear to allow the array
to grow and shrink in size as necessary. Typically this is done
by allocating a new copy, copying the contents of the old array,
and then returning the old array to <a class="reference internal" href="#term-free-store"><span class="xref std std-term">free store</span></a>.
If done correctly, the <a class="reference internal" href="#term-amortized-cost"><span class="xref std std-term">amortized cost</span></a> for dynamically
resizing the array can be made constant.
In some programming languages such as Java, the term
<a class="reference internal" href="#term-vector"><span class="xref std std-term">vector</span></a> is used as a synonym for dynamic array.</p>
</dd>
<dt id="term-dynamic-memory-allocation">dynamic memory allocation<a class="headerlink" href="#term-dynamic-memory-allocation" title="Permalink to this term">¶</a></dt><dd><p>A programming technique where linked objects in a data structure
are created from <a class="reference internal" href="#term-free-store"><span class="xref std std-term">free store</span></a> as needed. When no longer
needed, the object is either returned to <a class="reference internal" href="#term-free-store"><span class="xref std std-term">free store</span></a> or
left as <a class="reference internal" href="#term-garbage"><span class="xref std std-term">garbage</span></a>, depending on the programming language.</p>
</dd>
<dt id="term-dynamic-programming">dynamic programming<a class="headerlink" href="#term-dynamic-programming" title="Permalink to this term">¶</a></dt><dd><p>An approach to designing algorithms that works by storing a table
of results for subproblems.
A typical cause for excessive cost in
<a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursive</span></a>
algorithms is that different branches of the recursion might
solve the same subproblem.
Dynamic programming uses a table to store information about
which subproblems have already been solved, and uses the stored
information to immediately give the answer for any repeated
attempts to solve that subproblem.</p>
</dd>
<dt id="term-edge">edge<a class="headerlink" href="#term-edge" title="Permalink to this term">¶</a></dt><dd><p>The connection that links two <a class="reference internal" href="#term-node"><span class="xref std std-term">nodes</span></a> in a
<a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a>, <a class="reference internal" href="#term-linked-list"><span class="xref std std-term">linked list</span></a>, or <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a>.</p>
</dd>
<dt id="term-edit-distance">edit distance<a class="headerlink" href="#term-edit-distance" title="Permalink to this term">¶</a></dt><dd><p>Given strings <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(T\)</span>, the edit distance is
a measure for the number of editing steps required to convert
<span class="math notranslate nohighlight">\(S\)</span> into <span class="math notranslate nohighlight">\(T\)</span>.</p>
</dd>
<dt id="term-efficient">efficient<a class="headerlink" href="#term-efficient" title="Permalink to this term">¶</a></dt><dd><p>A solution is said to be efficient
if it solves the problem within the required
<a class="reference internal" href="#term-resource-constraints"><span class="xref std std-term">resource constraints</span></a>.
A solution is sometimes said to be
efficient if it requires fewer resources than known
alternatives, regardless of whether it meets any particular
requirements.</p>
</dd>
<dt id="term-element">element<a class="headerlink" href="#term-element" title="Permalink to this term">¶</a></dt><dd><p>One value or member in a set.</p>
</dd>
<dt id="term-empirical-comparison">empirical comparison<a class="headerlink" href="#term-empirical-comparison" title="Permalink to this term">¶</a></dt><dd><p>An approach to comparing to things by actually seeing how they
perform.
Most typically, we are referring to the comparison of two
programs by running each on a suite of test data and measuring
the actual running times.
Empirical comparison is subject to many possible complications,
including unfair selection of test data, and inaccuracies in the
time measurements due to variations in the computing environment
between various executions of the programs.</p>
</dd>
<dt id="term-empty">empty<a class="headerlink" href="#term-empty" title="Permalink to this term">¶</a></dt><dd><p>For a <a class="reference internal" href="#term-container"><span class="xref std std-term">container</span></a> class, the state of containing no
<a class="reference internal" href="#term-element"><span class="xref std std-term">elements</span></a>.</p>
</dd>
<dt id="term-encapsulation">encapsulation<a class="headerlink" href="#term-encapsulation" title="Permalink to this term">¶</a></dt><dd><p>In programming, the concept of hiding implementation details
from the user of an ADT, and protecting
<a class="reference internal" href="#term-data-member"><span class="xref std std-term">data members</span></a> of an
object from outside access.</p>
</dd>
<dt id="term-enqueue">enqueue<a class="headerlink" href="#term-enqueue" title="Permalink to this term">¶</a></dt><dd><p>A specialized term used to indicate inserting an element onto a queue.</p>
</dd>
<dt id="term-entry-sequenced-file">entry-sequenced file<a class="headerlink" href="#term-entry-sequenced-file" title="Permalink to this term">¶</a></dt><dd><p>A file that stores records in the order that they were added to
the file.</p>
</dd>
<dt id="term-enumeration">enumeration<a class="headerlink" href="#term-enumeration" title="Permalink to this term">¶</a></dt><dd><p>The process by which a <a class="reference internal" href="#term-traversal"><span class="xref std std-term">traversal</span></a> lists every object in
the <a class="reference internal" href="#term-container"><span class="xref std std-term">container</span></a> exactly once.
Thus, a traversal that prints the <a class="reference internal" href="#term-node"><span class="xref std std-term">nodes</span></a> is said
to enumerate the nodes.
An enumeration can also refer to the actual listing that is
produced by the traversal
(as well as the process that created that listing).</p>
</dd>
<dt id="term-equidistribution-property">equidistribution property<a class="headerlink" href="#term-equidistribution-property" title="Permalink to this term">¶</a></dt><dd><p>In random number theory, this means that a given series of
random numbers cannot be described more briefly than simply
listing it out.</p>
</dd>
<dt id="term-equivalence-class">equivalence class<a class="headerlink" href="#term-equivalence-class" title="Permalink to this term">¶</a></dt><dd><p>An <a class="reference internal" href="#term-equivalence-relation"><span class="xref std std-term">equivalence relation</span></a> can be used to partition a set
into equivalence classes.</p>
</dd>
<dt id="term-equivalence-relation">equivalence relation<a class="headerlink" href="#term-equivalence-relation" title="Permalink to this term">¶</a></dt><dd><p>Relation <span class="math notranslate nohighlight">\(R\)</span> is an equivalence relation on set
<span class="math notranslate nohighlight">\(\mathbf{S}\)</span> if it is <a class="reference internal" href="#term-reflexive"><span class="xref std std-term">reflexive</span></a>,
<a class="reference internal" href="#term-symmetric"><span class="xref std std-term">symmetric</span></a>, and <a class="reference internal" href="#term-transitive"><span class="xref std std-term">transitive</span></a>.</p>
</dd>
<dt id="term-equivalent">equivalent<a class="headerlink" href="#term-equivalent" title="Permalink to this term">¶</a></dt><dd><p>In the study of formal langauges, two entities are equivalent if
they accept the same language. That is, entities <span class="math notranslate nohighlight">\(M_1\)</span> and
<span class="math notranslate nohighlight">\(M_2\)</span> are equivalent if <span class="math notranslate nohighlight">\(L(M_1) = L(M_2)\)</span>.
Two mechanisms for representing or recognizing languages are
equivalent if the collection of languages that each accept are
the same.
For example, <a class="reference internal" href="#term-DFA"><span class="xref std std-term">DFAs</span></a> and <a class="reference internal" href="#term-NFA"><span class="xref std std-term">NFAs</span></a> are
equivalent because every DFA is technically an NFA, and every
NFA can be converted into a DFA.</p>
</dd>
<dt id="term-estimation">estimation<a class="headerlink" href="#term-estimation" title="Permalink to this term">¶</a></dt><dd><p>As a technical skill, this is the process of generating a rough
estimate in order to evaluate the feasibility of a proposed
solution.
This is sometimes known as “back of the napkin” or
“back of the envelope” calculation.
The estimation process can be formalized as (1) determine the
major parameters that affect the problem, (2) derive an equation
that relates the parameters to the problem, then (3) select
values for the parameters and apply the equation to yield an
estimated solution.</p>
</dd>
<dt id="term-evaluation">evaluation<a class="headerlink" href="#term-evaluation" title="Permalink to this term">¶</a></dt><dd><p>The act of finding the value for a polynomial at a given point.</p>
</dd>
<dt id="term-exact-match-query">exact-match query<a class="headerlink" href="#term-exact-match-query" title="Permalink to this term">¶</a></dt><dd><p>Records are accessed by unique identifier.</p>
</dd>
<dt id="term-exceptions">exceptions<a class="headerlink" href="#term-exceptions" title="Permalink to this term">¶</a></dt><dd><p>Exceptions are techniques used to predict possible runtime
errors and handle them properly.</p>
</dd>
<dt id="term-exchange">exchange<a class="headerlink" href="#term-exchange" title="Permalink to this term">¶</a></dt><dd><p>A swap of adjacent records in an <a class="reference internal" href="#term-array"><span class="xref std std-term">array</span></a>.</p>
</dd>
<dt id="term-exchange-sort">exchange sort<a class="headerlink" href="#term-exchange-sort" title="Permalink to this term">¶</a></dt><dd><p>A sort that relies solely on exchanges (swaps of adjacent
records) to reorder the list.
<a class="reference internal" href="#term-Insertion-Sort"><span class="xref std std-term">Insertion Sort</span></a> and
<a class="reference internal" href="#term-bubble-sort"><span class="xref std std-term">Bubble Sort</span></a> are examples of exchange sorts.
All exchange sorts require
<span class="math notranslate nohighlight">\(\Theta(n^2)\)</span> time in the <a class="reference internal" href="#term-worst-case"><span class="xref std std-term">worst case</span></a>.</p>
</dd>
<dt id="term-expanding-the-recurrence">expanding the recurrence<a class="headerlink" href="#term-expanding-the-recurrence" title="Permalink to this term">¶</a></dt><dd><p>A technique for solving a <a class="reference internal" href="#term-recurrence-relation"><span class="xref std std-term">recurrence relation</span></a>.
The idea is to replace the recursive part of the recurrence with
a copy of recurrence.</p>
</dd>
<dt id="term-exponential-growth-rate">exponential growth rate<a class="headerlink" href="#term-exponential-growth-rate" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-growth-rate"><span class="xref std std-term">growth rate</span></a> function where <span class="math notranslate nohighlight">\(n\)</span> (the input size)
appears in the exponent. For example, <span class="math notranslate nohighlight">\(2^n\)</span>.</p>
</dd>
<dt id="term-expression-tree">expression tree<a class="headerlink" href="#term-expression-tree" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a> structure meant to represent a mathematical expression.
<a class="reference internal" href="#term-internal-node"><span class="xref std std-term">Internal nodes</span></a> of the expression tree
are operators in the expression, with the subtrees being the
sub-expressions that are its operand.
All <a class="reference internal" href="#term-leaf-node"><span class="xref std std-term">leaf nodes</span></a> are operands.</p>
</dd>
<dt id="term-extent">extent<a class="headerlink" href="#term-extent" title="Permalink to this term">¶</a></dt><dd><p>A physically contiguous block of <a class="reference internal" href="#term-sector"><span class="xref std std-term">sectors</span></a> on a
<a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a> that are all part of a given disk file.
The fewer extents needed to store the data for a disk file,
generally the fewer <a class="reference internal" href="#term-seek"><span class="xref std std-term">seek</span></a> operations that will be
required to process a series of <a class="reference internal" href="#term-disk-access"><span class="xref std std-term">disk access</span></a> operations
on that file.</p>
</dd>
<dt id="term-external-fragmentation">external fragmentation<a class="headerlink" href="#term-external-fragmentation" title="Permalink to this term">¶</a></dt><dd><p>A condition that arises when a series of
<a class="reference internal" href="#term-memory-request"><span class="xref std std-term">memory requests</span></a>
result in lots of small <a class="reference internal" href="#term-free-block"><span class="xref std std-term">free blocks</span></a>, no one
of which is useful for servicing typical requests.</p>
</dd>
<dt id="term-external-sort">external sort<a class="headerlink" href="#term-external-sort" title="Permalink to this term">¶</a></dt><dd><p>A sorting algorithm that is applied to data stored in
<a class="reference internal" href="#term-peripheral-storage"><span class="xref std std-term">peripheral storage</span></a> such as on a <a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a>.
This is in contrast to an <a class="reference internal" href="#term-internal-sort"><span class="xref std std-term">internal sort</span></a> that works on
data stored in <a class="reference internal" href="#term-main-memory"><span class="xref std std-term">main memory</span></a>.</p>
</dd>
<dt id="term-factorial">factorial<a class="headerlink" href="#term-factorial" title="Permalink to this term">¶</a></dt><dd><p>The factorial function is defined as <span class="math notranslate nohighlight">\(f(n) = n f(n-1)\)</span> for
<span class="math notranslate nohighlight">\(n &gt; 0\)</span>.</p>
</dd>
<dt id="term-failure-policy">failure policy<a class="headerlink" href="#term-failure-policy" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-memory-manager"><span class="xref std std-term">memory manager</span></a>, a failure policy is the response
that takes place when there is no way to satisfy a
<a class="reference internal" href="#term-memory-request"><span class="xref std std-term">memory request</span></a> from the current
<a class="reference internal" href="#term-free-block"><span class="xref std std-term">free blocks</span></a> in the <a class="reference internal" href="#term-memory-pool"><span class="xref std std-term">memory pool</span></a>.
Possibilities include rejecting the request, expanding the
memory pool, collecting <a class="reference internal" href="#term-garbage"><span class="xref std std-term">garbage</span></a>, and reorganizing the
memory pool (to collect together free space).</p>
</dd>
<dt id="term-family-of-languages">family of languages<a class="headerlink" href="#term-family-of-languages" title="Permalink to this term">¶</a></dt><dd><p>Given some class or type of <a class="reference internal" href="#term-Finite-Automata"><span class="xref std std-term">finite automata</span></a>
(for example, the <a class="reference internal" href="#term-Deterministic-Finite-Automata"><span class="xref std std-term">deterministic finite automata</span></a>),
the set of languages accepted by that class of finite automata
is called a family.
For example, the <a class="reference internal" href="#term-regular-language"><span class="xref std std-term">regular languages</span></a> is
a family defined by the DFAs.</p>
</dd>
<dt id="term-FIFO">FIFO<a class="headerlink" href="#term-FIFO" title="Permalink to this term">¶</a></dt><dd><p>Abbreviation for “first-in, first-out”.
This is the access paradigm for a <a class="reference internal" href="#term-queue"><span class="xref std std-term">queue</span></a>,
and an old terminology for the queue is “FIFO list”.</p>
</dd>
<dt id="term-file-allocation-table">file allocation table<a class="headerlink" href="#term-file-allocation-table" title="Permalink to this term">¶</a></dt><dd><p>A legacy file system architecture orginially developed for DOS
and then used in Windows.
It is still in use in many small-scale peripheral devices such
as USB memory sticks and digital camera memory.</p>
</dd>
<dt id="term-file-manager">file manager<a class="headerlink" href="#term-file-manager" title="Permalink to this term">¶</a></dt><dd><p>A part of the <a class="reference internal" href="#term-operating-system"><span class="xref std std-term">operating system</span></a>
responsible for taking requests for data from a
<a class="reference internal" href="#term-logical-file"><span class="xref std std-term">logical file</span></a> and mapping those requests to the
physical location of the data on disk.</p>
</dd>
<dt id="term-file-processing">file processing<a class="headerlink" href="#term-file-processing" title="Permalink to this term">¶</a></dt><dd><p>The domain with Computer Science that deals with processing data
stored on a <a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a> (in a file), or more broadly,
dealing with data stored on any <a class="reference internal" href="#term-peripheral-storage"><span class="xref std std-term">peripheral storage</span></a>
device.
Two fundamental properties make dealing with data on a
peripheral device different from dealing with data in main
memory:
(1) Reading/writing data on a peripheral storage device is far
slower than reading/writing data to main memory (for example, a
typical disk drive is about a million times slower than
<a class="reference internal" href="#term-RAM"><span class="xref std std-term">RAM</span></a>).
(2) All I/O to a peripheral device is typically in terms of a
<a class="reference internal" href="#term-block"><span class="xref std std-term">block</span></a> of data (for example, nearly all disk drives do
all I/O in terms of blocks of 512 bytes).</p>
</dd>
<dt id="term-file-structure">file structure<a class="headerlink" href="#term-file-structure" title="Permalink to this term">¶</a></dt><dd><p>The organization of data on <a class="reference internal" href="#term-peripheral-storage"><span class="xref std std-term">peripheral storage</span></a>,
such as a <a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a> or DVD drive.</p>
</dd>
<dt id="term-final-state">final state<a class="headerlink" href="#term-final-state" title="Permalink to this term">¶</a></dt><dd><p>A required element of any <a class="reference internal" href="#term-Finite-State-Acceptor"><span class="xref std std-term">acceptor</span></a>.
When computation on a string ends in a final state, then the
machine accepts the string.
Otherwise the machine rejects the string.</p>
</dd>
<dt id="term-FIND">FIND<a class="headerlink" href="#term-FIND" title="Permalink to this term">¶</a></dt><dd><p>One half of the <a class="reference internal" href="#term-UNION-FIND"><span class="xref std std-term">UNION/FIND</span></a> algorithm for managing
<a class="reference internal" href="#term-disjoint-sets"><span class="xref std std-term">disjoint sets</span></a>.
It is the process of moving upwards in a
tree to find the tree’s root.</p>
</dd>
<dt id="term-Finite-State-Acceptor">Finite State Acceptor<a class="headerlink" href="#term-Finite-State-Acceptor" title="Permalink to this term">¶</a></dt><dd><p>A simple type of <a class="reference internal" href="#term-Finite-State-Automata"><span class="xref std std-term">finite state automata</span></a>, an acceptor’s
only ability is to accept or reject a string.
So, a finite state acceptor does not have the ability to modify
the input tape.
If computation on the string ends in a <a class="reference internal" href="#term-final-state"><span class="xref std std-term">final state</span></a>,
then the the string is accepted, otherwise it is rejected.</p>
</dd>
<dt id="term-Finite-State-Machine">Finite State Machine<a class="headerlink" href="#term-Finite-State-Machine" title="Permalink to this term">¶</a></dt><dt id="term-FSM">FSM<a class="headerlink" href="#term-FSM" title="Permalink to this term">¶</a></dt><dt id="term-Finite-State-Automata">Finite State Automata<a class="headerlink" href="#term-Finite-State-Automata" title="Permalink to this term">¶</a></dt><dt id="term-FSA">FSA<a class="headerlink" href="#term-FSA" title="Permalink to this term">¶</a></dt><dt id="term-Finite-Automata">Finite Automata<a class="headerlink" href="#term-Finite-Automata" title="Permalink to this term">¶</a></dt><dd><p>Any abstract state machine, generally represented as a graph
where the nodes are the <a class="reference internal" href="#term-state"><span class="xref std std-term">states</span></a>, and the edges
represent transitions between nodes that take place when the
machine is in that node (state) and sees an appropriate input.
See, as an example, <a class="reference internal" href="#term-Deterministic-Finite-Automata"><span class="xref std std-term">Deterministic Finite Automata</span></a>.</p>
</dd>
<dt id="term-first-fit">first fit<a class="headerlink" href="#term-first-fit" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-memory-manager"><span class="xref std std-term">memory manager</span></a>, first fit is a <a class="reference internal" href="#term-heuristic"><span class="xref std std-term">heuristic</span></a>
for deciding which <a class="reference internal" href="#term-free-block"><span class="xref std std-term">free block</span></a> to use when allocating
memory from a <a class="reference internal" href="#term-memory-pool"><span class="xref std std-term">memory pool</span></a>.
First fit will always allocate the first <a class="reference internal" href="#term-free-block"><span class="xref std std-term">free block</span></a> on
the <a class="reference internal" href="#term-free-block-list"><span class="xref std std-term">free block list</span></a> that is large enough to service the
memory request.
The advantage of this approach is that it is typically not
necessary to look at all free blocks on the free block list to
find a suitable free block.
The disadvantage is that it is not “intelligently” selecting
what might be a better choice of free block.</p>
</dd>
<dt id="term-fixed-length-coding">fixed-length coding<a class="headerlink" href="#term-fixed-length-coding" title="Permalink to this term">¶</a></dt><dd><p>Given a collection of objects, a fixed-length coding scheme
assigns a code to each object in the collection using codes that
are all of the same length.
Standard ASCII and Unicode representations for characters are
both examples of fixed-length coding schemes.
This is in contrast to <a class="reference internal" href="#term-variable-length-coding"><span class="xref std std-term">variable-length coding</span></a>.</p>
</dd>
<dt id="term-floor">floor<a class="headerlink" href="#term-floor" title="Permalink to this term">¶</a></dt><dd><p>Written <span class="math notranslate nohighlight">\(\lfloor x \rfloor\)</span>, for real value <span class="math notranslate nohighlight">\(x\)</span> the
floor is the greatest integer <span class="math notranslate nohighlight">\(\leq x\)</span>.</p>
</dd>
<dt id="term-Floyd-s-algorithm">Floyd’s algorithm<a class="headerlink" href="#term-Floyd-s-algorithm" title="Permalink to this term">¶</a></dt><dd><p>An algorithm to solve the
<a class="reference internal" href="#term-all-pairs-shortest-paths-problem"><span class="xref std std-term">all-pairs shortest paths problem</span></a>.
It uses the <a class="reference internal" href="#term-dynamic-programming"><span class="xref std std-term">dynamic programming</span></a> algorithmic technique,
and runs in <span class="math notranslate nohighlight">\(\Theta(n^3)\)</span> time.
As with any <a class="reference internal" href="#term-dynamic-programming"><span class="xref std std-term">dynamic programming</span></a> algorithm,
the key issue is to avoid duplicating work by using proper
bookkeeping on the algorithm’s progress through the solution space.
The basic idea is to first find all the direct edge costs, then
improving those costs by allowing paths through <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertex</span></a>
0, then the cheapest paths involving paths going through
vertices 0 and 1, and so on.</p>
</dd>
<dt id="term-flush">flush<a class="headerlink" href="#term-flush" title="Permalink to this term">¶</a></dt><dd><p>The act of removing data from a <a class="reference internal" href="#term-caching"><span class="xref std std-term">cache</span></a>, most
typically because other data considered of higher future value
must replace it in the cache.
If the data being flushed has been modified since it was first
read in from <a class="reference internal" href="#term-secondary-storage"><span class="xref std std-term">secondary storage</span></a> (and the changes are
meant to be saved), then it must be written back to that
secondary storage.
The the context of a <a class="reference internal" href="#term-buffer-pool"><span class="xref std std-term">buffer pool</span></a>, the process of
removing the contents stored in a <a class="reference internal" href="#term-buffer"><span class="xref std std-term">buffer</span></a>
when that buffer is required in order to store new data.
If the buffer’s contents have been changed since having been
read in from <a class="reference internal" href="#term-backing-storage"><span class="xref std std-term">backing storage</span></a> (this fact would
normally be tracked by using a <a class="reference internal" href="#term-dirty-bit"><span class="xref std std-term">dirty bit</span></a>),
then they must be copied back to the backing storage before the
buffer can be reused.</p>
</dd>
<dt id="term-flyweight">flyweight<a class="headerlink" href="#term-flyweight" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-design-pattern"><span class="xref std std-term">design pattern</span></a> that is meant to solve the following
problem:
You have an application with many objects.
Some of these objects are identical in the information that
they contain, and the role that they play.
But they must be reached from various places, and conceptually they
really are distinct objects.
Because there is so much duplication of the same information,
we want to reduce memory cost by sharing that space.
For example, in document layout,
the letter “C” might be represented by an object that
describes that character’s strokes and bounding box.
However, we do not want to create a separate “C” object everywhere
in the document that a “C” appears.
The solution is to allocate a single copy of the shared representation
for “C” objects.
Then, every place in the document that needs a “C” in a given font,
size, and typeface will reference this single copy.
The various instances of <a class="reference internal" href="#term-reference"><span class="xref std std-term">references</span></a> to a
specific form of “C” are called flyweights.
Flyweights can also be used to implement the empty leaf nodes
of the <a class="reference internal" href="#term-bintree"><span class="xref std std-term">bintree</span></a> and <a class="reference internal" href="#term-PR-quadtree"><span class="xref std std-term">PR quadtree</span></a>.</p>
</dd>
<dt id="term-folding-method">folding method<a class="headerlink" href="#term-folding-method" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, an approach to implementing a
<a class="reference internal" href="#term-hash-function"><span class="xref std std-term">hash function</span></a>.
Most typically used when the key is a string, the folding method
breaks the string into pieces (perhaps each letter is a piece,
or a small series of letters is a piece), converts the letter(s)
to an integer value (typically by using its underlying encoding
value), and summing up the pieces.</p>
</dd>
<dt id="term-Ford-and-Johnson-sort">Ford and Johnson sort<a class="headerlink" href="#term-Ford-and-Johnson-sort" title="Permalink to this term">¶</a></dt><dd><p>A sorting algorithm that is close to the theoretical minimum
number of key comparisons necessary to sort.
Generally not considered practical in practice due to the fact
that it is not efficient in terms of the number of records that
need to be moved.
It consists of first sorting pairs of nodes into winners and
losers (of the pairs comparisons), then (recursively)
sorting the winners of the pairs, and then finally carefully
selecting the order in which the losers are added to the chain
of sorted items.</p>
</dd>
<dt id="term-forest">forest<a class="headerlink" href="#term-forest" title="Permalink to this term">¶</a></dt><dd><p>A collection of one or more <a class="reference internal" href="#term-tree"><span class="xref std std-term">trees</span></a>.</p>
</dd>
<dt id="term-free-block">free block<a class="headerlink" href="#term-free-block" title="Permalink to this term">¶</a></dt><dd><p>A block of unused space in a <a class="reference internal" href="#term-memory-pool"><span class="xref std std-term">memory pool</span></a>.</p>
</dd>
<dt id="term-free-block-list">free block list<a class="headerlink" href="#term-free-block-list" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-memory-manager"><span class="xref std std-term">memory manager</span></a>, the list that stores the necessary
information about the current <a class="reference internal" href="#term-free-block"><span class="xref std std-term">free blocks</span></a>.
Generally, this is done with some sort of <a class="reference internal" href="#term-linked-list"><span class="xref std std-term">linked list</span></a>,
where each node of the linked list indicates the start position
and length of the free block in the <a class="reference internal" href="#term-memory-pool"><span class="xref std std-term">memory pool</span></a>.</p>
</dd>
<dt id="term-free-store">free store<a class="headerlink" href="#term-free-store" title="Permalink to this term">¶</a></dt><dd><p>Space available to a program during runtime to be used for
<a class="reference internal" href="#term-dynamic-allocation"><span class="xref std std-term">dynamic allocation</span></a> of objects.
The free store is distinct from the <a class="reference internal" href="#term-runtime-stack"><span class="xref std std-term">runtime stack</span></a>.
The free store is sometimes referred to as the <a class="reference internal" href="#term-heap"><span class="xref std std-term">heap</span></a>,
which can be confusing because <a class="reference internal" href="#term-heap"><span class="xref std std-term">heap</span></a> more often refers to
a specific data structure. Most programming languages provide
functions to allocate (and maybe to deallocate) objects from the
free store, such as <code class="docutils literal notranslate"><span class="pre">new</span></code> in C++ and Java.</p>
</dd>
<dt id="term-free-tree">free tree<a class="headerlink" href="#term-free-tree" title="Permalink to this term">¶</a></dt><dd><p>A connected, <a class="reference internal" href="#term-undirected-graph"><span class="xref std std-term">undirected graph</span></a> with no simple cycles.
An equivalent definition is that a free tree is connected and
has <span class="math notranslate nohighlight">\(|\mathbf{V}| - 1\)</span> edges.</p>
</dd>
<dt id="term-freelist">freelist<a class="headerlink" href="#term-freelist" title="Permalink to this term">¶</a></dt><dd><p>A simple and faster alternative to using <a class="reference internal" href="#term-free-store"><span class="xref std std-term">free store</span></a> when
the objects being dynamically allocated are all of the same size
(and thus are interchangeable).
Typically implemented as a <a class="reference internal" href="#term-linked-stack"><span class="xref std std-term">linked stack</span></a>, released
objects are put on the front of the freelist.
When a request is made to allocate an object, the freelist is
checked first and it provides the object if possible.
If the freelist is empty, then a new object is allocated from
<a class="reference internal" href="#term-free-store"><span class="xref std std-term">free store</span></a>.</p>
</dd>
<dt id="term-frequency-count">frequency count<a class="headerlink" href="#term-frequency-count" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-heuristic"><span class="xref std std-term">heuristic</span></a> used to maintain a
<a class="reference internal" href="#term-self-organizing-list"><span class="xref std std-term">self-organizing list</span></a>.
Under this heuristic, a count is maintained for every record.
When a record access is made, its count is increased.
If this makes its count greater than that of another record in
the list, it moves up toward the front of the list accordingly
so as to keep the list sorted by frequency.
Analogous to the <a class="reference internal" href="#term-least-frequently-used"><span class="xref std std-term">least frequently used</span></a> heuristic for
maintaining a <a class="reference internal" href="#term-buffer-pool"><span class="xref std std-term">buffer pool</span></a>.</p>
</dd>
<dt id="term-full-binary-tree-theorem">full binary tree theorem<a class="headerlink" href="#term-full-binary-tree-theorem" title="Permalink to this term">¶</a></dt><dd><p>This theorem states that
the number of leaves in a non-empty full binary tree is one
more than the number of internal nodes.
Equivalently, then number of null pointers in a standard
<a class="reference internal" href="#term-pointer-based-implementation-for-binary-tree-nodes"><span class="xref std std-term">pointer-based implementation for binary tree nodes</span></a>
is one more than the number of nodes in the binary tree.</p>
</dd>
<dt id="term-full-tree">full tree<a class="headerlink" href="#term-full-tree" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-binary-tree"><span class="xref std std-term">binary tree</span></a> is full if every <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> is either a
<a class="reference internal" href="#term-leaf-node"><span class="xref std std-term">leaf node</span></a> or else it is an <a class="reference internal" href="#term-internal-node"><span class="xref std std-term">internal node</span></a> with
two non-empty <a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a>.</p>
</dd>
<dt id="term-function">function<a class="headerlink" href="#term-function" title="Permalink to this term">¶</a></dt><dd><p>In mathematics, a matching between inputs (the <a class="reference internal" href="#term-domain"><span class="xref std std-term">domain</span></a>)
and outputs (the <a class="reference internal" href="#term-range"><span class="xref std std-term">range</span></a>).
In programming, a subroutine that takes input parameters and
uses them to compute and return a value.
In this case, it is usually considered bad practice for a
function to change any global variables
(doing so is called a side effect).</p>
</dd>
<dt id="term-garbage">garbage<a class="headerlink" href="#term-garbage" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-memory-manager"><span class="xref std std-term">memory management</span></a>,
any memory that was previously (dynamically)
allocated by the program during runtime, but which is no longer
accessible since all pointers to the memory have been deleted or
overwritten.
In some languages, garbage can be recovered by
<a class="reference internal" href="#term-garbage-collection"><span class="xref std std-term">garbage collection</span></a>.
In languages such as C and C++ that do not support garbage
collection, so creating garbage is considered a
<a class="reference internal" href="#term-memory-leak"><span class="xref std std-term">memory leak</span></a>.</p>
</dd>
<dt id="term-garbage-collection">garbage collection<a class="headerlink" href="#term-garbage-collection" title="Permalink to this term">¶</a></dt><dd><p>Languages with garbage collection such
Java, JavaScript, Lisp, and Scheme will periodically reclaim
<a class="reference internal" href="#term-garbage"><span class="xref std std-term">garbage</span></a> and return it to <a class="reference internal" href="#term-free-store"><span class="xref std std-term">free store</span></a>.</p>
</dd>
<dt id="term-general-tree">general tree<a class="headerlink" href="#term-general-tree" title="Permalink to this term">¶</a></dt><dd><p>A tree in which any given node can have any number of
<a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a>.
This is in contrast to, for example, a <a class="reference internal" href="#term-binary-tree"><span class="xref std std-term">binary tree</span></a> where
each node has a fixed number of children (some of which might be
<code class="docutils literal notranslate"><span class="pre">null</span></code>).
General tree nodes tend to be harder to implement for this reason.</p>
</dd>
<dt id="term-grammar">grammar<a class="headerlink" href="#term-grammar" title="Permalink to this term">¶</a></dt><dd><p>A formal definition for what strings make up a <a class="reference internal" href="#term-language"><span class="xref std std-term">language</span></a>,
in terms of a set of <a class="reference internal" href="#term-production-rule"><span class="xref std std-term">production rules</span></a>.</p>
</dd>
<dt id="term-graph">graph<a class="headerlink" href="#term-graph" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> <span class="math notranslate nohighlight">\(\mathbf{G} = (\mathbf{V}, \mathbf{E})\)</span>
consists of a set of <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertices</span></a>
<span class="math notranslate nohighlight">\(\mathbf{V}\)</span> and a set of <a class="reference internal" href="#term-edge"><span class="xref std std-term">edges</span></a>
<span class="math notranslate nohighlight">\(\mathbf{E}\)</span>, such that each edge in <span class="math notranslate nohighlight">\(\mathbf{E}\)</span> is
a connection between a pair of vertices in <span class="math notranslate nohighlight">\(\mathbf{V}\)</span>.</p>
</dd>
<dt id="term-greedy-algorithm">greedy algorithm<a class="headerlink" href="#term-greedy-algorithm" title="Permalink to this term">¶</a></dt><dd><p>An algorithm that makes locally optimal choices at each step.</p>
</dd>
<dt id="term-growth-rate">growth rate<a class="headerlink" href="#term-growth-rate" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-algorithm-analysis"><span class="xref std std-term">algorithm analysis</span></a>, the rate at which the cost
of the <a class="reference internal" href="#term-algorithm"><span class="xref std std-term">algorithm</span></a> grows as the size of its input grows.</p>
</dd>
<dt id="term-guess-and-test">guess-and-test<a class="headerlink" href="#term-guess-and-test" title="Permalink to this term">¶</a></dt><dd><p>A technique used when trying to determine the
<a class="reference internal" href="#term-closed-form-solution"><span class="xref std std-term">closed-form solution</span></a> for a
<a class="reference internal" href="#term-summation"><span class="xref std std-term">summation</span></a> or <a class="reference internal" href="#term-recurrence-relation"><span class="xref std std-term">recurrence relation</span></a>.
Given a hypothesis for the closed-form solution,
if it is correct, then it is often relatively easy to prove that
using <a class="reference internal" href="#term-proof-by-induction"><span class="xref std std-term">induction</span></a>.</p>
</dd>
<dt id="term-guided-traversal">guided traversal<a class="headerlink" href="#term-guided-traversal" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-tree-traversal"><span class="xref std std-term">tree traversal</span></a> that does not need to visit every node
in the tree.
An example would be a <a class="reference internal" href="#term-range-query"><span class="xref std std-term">range query</span></a> in a <a class="reference internal" href="#term-BST"><span class="xref std std-term">BST</span></a>.</p>
</dd>
<dt id="term-halt-state">halt state<a class="headerlink" href="#term-halt-state" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-Finite-Automata"><span class="xref std std-term">finite automata</span></a>, a designated <a class="reference internal" href="#term-state"><span class="xref std std-term">state</span></a> which
causes the machine to immediately halt when it is entered.</p>
</dd>
<dt id="term-halted-configuration">halted configuration<a class="headerlink" href="#term-halted-configuration" title="Permalink to this term">¶</a></dt><dd><p>A halted configuration occurs in a <a class="reference internal" href="#term-Turing-machine"><span class="xref std std-term">Turing machine</span></a> when
the machine transitions into the <a class="reference internal" href="#term-halt-state"><span class="xref std std-term">halt state</span></a>.</p>
</dd>
<dt id="term-halting-problem">halting problem<a class="headerlink" href="#term-halting-problem" title="Permalink to this term">¶</a></dt><dd><p>The halting problem is to answer this question:
Given a computer program <span class="math notranslate nohighlight">\(P\)</span> and an
input <span class="math notranslate nohighlight">\(I\)</span>, will program <span class="math notranslate nohighlight">\(P\)</span> halt when executed on
input <span class="math notranslate nohighlight">\(I\)</span>?
This problem has been proved impossible to solve in the general
case.
Thus, it is an example of an <a class="reference internal" href="#term-unsolveable-problem"><span class="xref std std-term">unsolveable problem</span></a>.</p>
</dd>
<dt id="term-handle">handle<a class="headerlink" href="#term-handle" title="Permalink to this term">¶</a></dt><dd><p>When using a <a class="reference internal" href="#term-memory-manager"><span class="xref std std-term">memory manager</span></a> to store data, the
<a class="reference internal" href="#term-client"><span class="xref std std-term">client</span></a> will pass data to be stored
(the <a class="reference internal" href="#term-message"><span class="xref std std-term">message</span></a>) to the memory manager, and the memory
manager will return to the client a handle.
The handle encodes the necessary information that the memory
manager can later use to recover and return the message to the
client.
This is typically the location and length of the message within
the <a class="reference internal" href="#term-memory-pool"><span class="xref std std-term">memory pool</span></a>.</p>
</dd>
<dt id="term-hanging-configuration">hanging configuration<a class="headerlink" href="#term-hanging-configuration" title="Permalink to this term">¶</a></dt><dd><p>A hanging configuration occurs in a <a class="reference internal" href="#term-Turing-machine"><span class="xref std std-term">Turing machine</span></a> when
the I/O head moves to the left from the left-most square of the
tape, or when the machine goes into an infinite loop.</p>
</dd>
<dt id="term-happy-path-testing">happy path testing<a class="headerlink" href="#term-happy-path-testing" title="Permalink to this term">¶</a></dt><dd><p>Testing “proper” inputs or uses of a program.</p>
</dd>
<dt id="term-hard-algorithm">hard algorithm<a class="headerlink" href="#term-hard-algorithm" title="Permalink to this term">¶</a></dt><dd><p>“Hard” is traditionally defined in relation to running time, and
a “hard” algorithm is defined to be an algorithm with exponential
running time.</p>
</dd>
<dt id="term-hard-problem">hard problem<a class="headerlink" href="#term-hard-problem" title="Permalink to this term">¶</a></dt><dd><p>“Hard” is traditionally defined in relation to running time, and
a “hard” problem is defined to be one whose best known algorithm
requires exponential running time.</p>
</dd>
<dt id="term-harmonic-series">harmonic series<a class="headerlink" href="#term-harmonic-series" title="Permalink to this term">¶</a></dt><dd><p>The sum of reciprocals from 1 to <span class="math notranslate nohighlight">\(n\)</span> is called the
Harmonic Series, and is written <span class="math notranslate nohighlight">\({\cal H}_n\)</span>.
This sum has a value between <span class="math notranslate nohighlight">\(\log_e n\)</span> and
<span class="math notranslate nohighlight">\(\log_e n + 1\)</span>.</p>
</dd>
<dt id="term-hash-function">hash function<a class="headerlink" href="#term-hash-function" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-hash-system"><span class="xref std std-term">hash system</span></a>, the function that converts a
<a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> value to a position in the <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>.
The hope is that this position in the hash table contains the
record that matches the key value.</p>
</dd>
<dt id="term-hash-system">hash system<a class="headerlink" href="#term-hash-system" title="Permalink to this term">¶</a></dt><dd><p>The implementation for search based on hash lookup in a
<a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>.
The <a class="reference internal" href="#term-search-key"><span class="xref std std-term">search key</span></a> is processed by a
<a class="reference internal" href="#term-hash-function"><span class="xref std std-term">hash function</span></a>, which returns a position in a
<a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>, which hopefully is the correct position in
which to find the record corresponding to the search key.</p>
</dd>
<dt id="term-hash-table">hash table<a class="headerlink" href="#term-hash-table" title="Permalink to this term">¶</a></dt><dd><p>The data structure (usually an <a class="reference internal" href="#term-array"><span class="xref std std-term">array</span></a>) that stores data
records for lookup using <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>.</p>
</dd>
<dt id="term-hashing">hashing<a class="headerlink" href="#term-hashing" title="Permalink to this term">¶</a></dt><dd><p>A search method that uses a <a class="reference internal" href="#term-hash-function"><span class="xref std std-term">hash function</span></a> to convert a
<a class="reference internal" href="#term-search-key"><span class="xref std std-term">search key</span></a> value into a position within a
<a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>.
In a properly implemented <a class="reference internal" href="#term-hash-system"><span class="xref std std-term">hash system</span></a>, that position in
the table will have high probability of containing the record
that matches the key value.
Sometimes, the hash function will return an position that does
not store the desired key, due to a process called
<a class="reference internal" href="#term-collision"><span class="xref std std-term">collision</span></a>.
In that case, the desired record is found through a process
known as <a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a>.</p>
</dd>
<dt id="term-head">head<a class="headerlink" href="#term-head" title="Permalink to this term">¶</a></dt><dd><p>The beginning of a <a class="reference internal" href="#term-list"><span class="xref std std-term">list</span></a>.</p>
</dd>
<dt id="term-header-node">header node<a class="headerlink" href="#term-header-node" title="Permalink to this term">¶</a></dt><dd><p>Commonly used in implementations for a <a class="reference internal" href="#term-linked-list"><span class="xref std std-term">linked list</span></a> or
related structure, this <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> preceeds the first element
of the list.
Its purpose is to simplify the code implementation by
reducing the number of special cases that must be programmed
for.</p>
</dd>
<dt id="term-heap">heap<a class="headerlink" href="#term-heap" title="Permalink to this term">¶</a></dt><dd><p>This term has two different meanings.
Uncommonly, it is a synonym for <a class="reference internal" href="#term-free-store"><span class="xref std std-term">free store</span></a>.
Most often it is used to refer to a particular data structure.
This data structure is a <a class="reference internal" href="#term-complete-binary-tree"><span class="xref std std-term">complete binary tree</span></a> with the
requirement that every <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> has a value greater than its
<a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a> (called a <a class="reference internal" href="#term-max-heap"><span class="xref std std-term">max heap</span></a>), or else
the requirement that every node has a value less than its
children (called a <a class="reference internal" href="#term-min-heap"><span class="xref std std-term">min heap</span></a>).
Since it is a complete binary tree, a heap is nearly always
implemented using an <a class="reference internal" href="#term-array"><span class="xref std std-term">array</span></a> rather than an explicit tree
structure.
To add a new value to a heap, or to remove the extreme value
(the max value in a max-heap or min value in a min-heap) and
update the heap,
takes <span class="math notranslate nohighlight">\(\Theta(\log n)\)</span> time in the <a class="reference internal" href="#term-worst-case"><span class="xref std std-term">worst case</span></a>.
However, if given all of the values in an unordered array,
the values can be re-arranged to form a heap in only
<span class="math notranslate nohighlight">\(\Theta(n)\)</span> time.
Due to its space and time efficiency, the heap is a
popular choice for implementing a <a class="reference internal" href="#term-priority-queue"><span class="xref std std-term">priority queue</span></a>.</p>
</dd>
<dt id="term-heapsort">heapsort<a class="headerlink" href="#term-heapsort" title="Permalink to this term">¶</a></dt><dd><p>A sorting algorithm that costs <span class="math notranslate nohighlight">\(\Theta(n \log n)\)</span> time in
the <a class="reference internal" href="#term-best-case"><span class="xref std std-term">best</span></a>, <a class="reference internal" href="#term-average-case"><span class="xref std std-term">average</span></a>,
and <a class="reference internal" href="#term-worst-case"><span class="xref std std-term">worst</span></a> cases.
It tends to be slower than <a class="reference internal" href="#term-Mergesort"><span class="xref std std-term">Mergesort</span></a> and
<a class="reference internal" href="#term-Quicksort"><span class="xref std std-term">Quicksort</span></a>.
It works by building a <a class="reference internal" href="#term-max-heap"><span class="xref std std-term">max heap</span></a>, and
then repeatedly removing the item with maximum <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> value
(moving it to the end of the heap) until all elements have been
removed (and replaced at their proper location in the array).</p>
</dd>
<dt id="term-height">height<a class="headerlink" href="#term-height" title="Permalink to this term">¶</a></dt><dd><p>The height of a tree is one more than the <a class="reference internal" href="#term-depth"><span class="xref std std-term">depth</span></a> of the
deepest <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> in the tree.</p>
</dd>
<dt id="term-height-balanced">height balanced<a class="headerlink" href="#term-height-balanced" title="Permalink to this term">¶</a></dt><dd><p>The condition the <a class="reference internal" href="#term-depth"><span class="xref std std-term">depths</span></a> of each <a class="reference internal" href="#term-subtree"><span class="xref std std-term">subtree</span></a>
in a tree are roughly the same.</p>
</dd>
<dt id="term-heuristic">heuristic<a class="headerlink" href="#term-heuristic" title="Permalink to this term">¶</a></dt><dd><p>A way to solve a problem that is not guarenteed to be optimal.
While it might not be guarenteed to be optimal, it is generally
expected (by the agent employing the heuristic) to provide a
reasonably efficient solution.</p>
</dd>
<dt id="term-heuristic-algorithm">heuristic algorithm<a class="headerlink" href="#term-heuristic-algorithm" title="Permalink to this term">¶</a></dt><dd><p>A type of <a class="reference internal" href="#term-approximation-algorithm"><span class="xref std std-term">approximation algorithm</span></a>, that uses a
<a class="reference internal" href="#term-heuristic"><span class="xref std std-term">heuristic</span></a> to find a good, but not necessarily cheapest,
solution to an <a class="reference internal" href="#term-optimization-problem"><span class="xref std std-term">optimization problem</span></a>.</p>
</dd>
<dt id="term-home-position">home position<a class="headerlink" href="#term-home-position" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, a synonym for <a class="reference internal" href="#term-home-slot"><span class="xref std std-term">home slot</span></a>.</p>
</dd>
<dt id="term-home-slot">home slot<a class="headerlink" href="#term-home-slot" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, this is the <a class="reference internal" href="#term-slot"><span class="xref std std-term">slot</span></a> in the
<a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a> determined for a given key by the
<a class="reference internal" href="#term-hash-function"><span class="xref std std-term">hash function</span></a>.</p>
</dd>
<dt id="term-homogeneity">homogeneity<a class="headerlink" href="#term-homogeneity" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-container"><span class="xref std std-term">container</span></a> class, this is the property that all
objects stored in the ncontainer are of the same class.
For example, if you have a list intended to store Payroll
records, is it possible for the programmer to insert an integer
onto the list instead?</p>
</dd>
<dt id="term-Huffman-codes">Huffman codes<a class="headerlink" href="#term-Huffman-codes" title="Permalink to this term">¶</a></dt><dd><p>The codes given to a collection of letters (or other symbols)
through the process of Huffman coding.
Huffman coding uses a <a class="reference internal" href="#term-Huffman-coding-tree"><span class="xref std std-term">Huffman coding tree</span></a> to generate
the codes.
The codes can be of variable length, such that the letters which
are expected to appear most frequently are shorter.
Huffman coding is optimal whenever the true frequencies are
known, and the frequency of a letter is independent of the
context of that letter in the message.</p>
</dd>
<dt id="term-Huffman-coding-tree">Huffman coding tree<a class="headerlink" href="#term-Huffman-coding-tree" title="Permalink to this term">¶</a></dt><dd><p>A Huffman coding tree is a <a class="reference internal" href="#term-full-tree"><span class="xref std std-term">full binary tree</span></a>
that is used to represent letters (or other symbols)
efficiently.
Each letter is associated with a node in the tree, and is then
given a <a class="reference internal" href="#term-Huffman-codes"><span class="xref std std-term">Huffman code</span></a> based on the
position of the associated node.
A Huffman coding tree is an example of a binary <a class="reference internal" href="#term-trie"><span class="xref std std-term">trie</span></a>.</p>
</dd>
<dt id="term-Huffman-tree">Huffman tree<a class="headerlink" href="#term-Huffman-tree" title="Permalink to this term">¶</a></dt><dd><p>Shorter form of the term <a class="reference internal" href="#term-Huffman-coding-tree"><span class="xref std std-term">Huffman coding tree</span></a>.</p>
</dd>
<dt id="term-I-O-head">I/O head<a class="headerlink" href="#term-I-O-head" title="Permalink to this term">¶</a></dt><dd><p>On a <a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a> (or similar device), the part of the
machinery that actually reads data from the disk.</p>
</dd>
<dt id="term-image-space-decomposition">image-space decomposition<a class="headerlink" href="#term-image-space-decomposition" title="Permalink to this term">¶</a></dt><dd><p>A from of <a class="reference internal" href="#term-key-space-decomposition"><span class="xref std std-term">key-space decomposition</span></a> where the
<a class="reference internal" href="#term-key-space"><span class="xref std std-term">key space</span></a> splitting points is predetermined (typically
by splitting in half).
For example, a <a class="reference internal" href="#term-Huffman-coding-tree"><span class="xref std std-term">Huffman coding tree</span></a> splits the letters
being coded into those with codes that start with 0 on the left
side, and those with codes that start with 1 on the right side.
This regular decomposition of the key space is the basis for a
<a class="reference internal" href="#term-trie"><span class="xref std std-term">trie</span></a> data structure.
An image-space decomposition is in opposition to an
<a class="reference internal" href="#term-object-space-decomposition"><span class="xref std std-term">object-space decomposition</span></a>.</p>
</dd>
<dt id="term-in-degree">in degree<a class="headerlink" href="#term-in-degree" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> terminology, the in degree for a <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertex</span></a> is
the number of edges directed into the vertex.</p>
</dd>
<dt id="term-incident">incident<a class="headerlink" href="#term-incident" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> terminology,
an edge connecting two vertices is said to be incident with
those vertices.
The two vertices are said to be <a class="reference internal" href="#term-adjacent"><span class="xref std std-term">adjacent</span></a>.</p>
</dd>
<dt id="term-index-file">index file<a class="headerlink" href="#term-index-file" title="Permalink to this term">¶</a></dt><dd><p>A file whose records consist of
<a class="reference internal" href="#term-key-value-pair"><span class="xref std std-term">key-value pairs</span></a> where the
pointers are referencing the complete records stored in another
file.</p>
</dd>
<dt id="term-indexing">indexing<a class="headerlink" href="#term-indexing" title="Permalink to this term">¶</a></dt><dd><p>The process of associating a <a class="reference internal" href="#term-search-key"><span class="xref std std-term">search key</span></a> with the
location of a corresponding data record.
The two defining points to the concept of an index is the
association of a key with a record, and the fact that the index
does not actually store the record itself but rather it stores a
<a class="reference internal" href="#term-reference"><span class="xref std std-term">reference</span></a> to the record.
In this way, a collection of records can be supported by
multiple indices, typically a separate index for each key field
in the record.</p>
</dd>
<dt id="term-induction-hypothesis">induction hypothesis<a class="headerlink" href="#term-induction-hypothesis" title="Permalink to this term">¶</a></dt><dd><p>The key assumption used in a <a class="reference internal" href="#term-proof-by-induction"><span class="xref std std-term">proof by induction</span></a>,
that the theorem to be proved holds for smaller instances of the
theorem.
The induction hypothesis is equivalent to the
<a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursive</span></a>
call in a recursive function.</p>
</dd>
<dt id="term-induction-step">induction step<a class="headerlink" href="#term-induction-step" title="Permalink to this term">¶</a></dt><dd><p>Part of a <a class="reference internal" href="#term-proof-by-induction"><span class="xref std std-term">proof by induction</span></a>.
In its simplest form, this is a proof of the implication that if
the theorem holds for $n-1$, then it holds for $n$.
As an alternative, see <a class="reference internal" href="#term-strong-induction"><span class="xref std std-term">strong induction</span></a>.</p>
</dd>
<dt id="term-induction-variable">induction variable<a class="headerlink" href="#term-induction-variable" title="Permalink to this term">¶</a></dt><dd><p>The variable used to parameterize the theorem being proved by
induction.
For example, if we seek to prove that the sum of the integers
from 1 to $n$ is $n(n+1)/2$, then $n$ is the induction
variable.
An induction variable must be an integer.</p>
</dd>
<dt id="term-information-theoretic-lower-bound">information theoretic lower bound<a class="headerlink" href="#term-information-theoretic-lower-bound" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-lower-bound"><span class="xref std std-term">lower bound</span></a> on the amount of resources needed to solve
a <a class="reference internal" href="#term-problem"><span class="xref std std-term">problem</span></a> based on the number of bits of information
needed to uniquely specify the answer.
Sometimes referred to as a “Shannon theoretic lower bound” due
to Shannon’s work on information theory and entropy.
An example is that sorting has a lower bound of
<span class="math notranslate nohighlight">\(\Omega(\log_2 n!)\)</span> because there are <span class="math notranslate nohighlight">\(n!\)</span> possible
orderings for <span class="math notranslate nohighlight">\(n\)</span> values.
This observation alone does not make the lower bound tight,
because it is possible that no algorithm could actually reach
the information theory lower limit.</p>
</dd>
<dt id="term-inherit">inherit<a class="headerlink" href="#term-inherit" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming</span></a>,
the process by which a <a class="reference internal" href="#term-subclass"><span class="xref std std-term">subclass</span></a> gains
<a class="reference internal" href="#term-data-member"><span class="xref std std-term">data members</span></a> and <a class="reference internal" href="#term-method"><span class="xref std std-term">methods</span></a>
from a <a class="reference internal" href="#term-base-class"><span class="xref std std-term">base class</span></a>.</p>
</dd>
<dt id="term-initial-state">initial state<a class="headerlink" href="#term-initial-state" title="Permalink to this term">¶</a></dt><dd><p>A synonym for <a class="reference internal" href="#term-start-state"><span class="xref std std-term">start state</span></a>.</p>
</dd>
<dt id="term-inode">inode<a class="headerlink" href="#term-inode" title="Permalink to this term">¶</a></dt><dd><p>Short for “index node”.
In UNIX-style file systems, specific disk <a class="reference internal" href="#term-sector"><span class="xref std std-term">sectors</span></a>
that hold indexing information to define the layout of the file
system.</p>
</dd>
<dt id="term-inorder-traversal">inorder traversal<a class="headerlink" href="#term-inorder-traversal" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-binary-tree"><span class="xref std std-term">binary tree</span></a>, a <a class="reference internal" href="#term-traversal"><span class="xref std std-term">traversal</span></a> that first
<a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursively</span></a> <a class="reference internal" href="#term-visit"><span class="xref std std-term">visits</span></a> the left
<a class="reference internal" href="#term-child"><span class="xref std std-term">child</span></a>, then visits the <a class="reference internal" href="#term-root"><span class="xref std std-term">root</span></a>,
and then recursively visits the right child.
In a <a class="reference internal" href="#term-binary-search-tree"><span class="xref std std-term">binary search tree</span></a>, this traversal will
<a class="reference internal" href="#term-enumeration"><span class="xref std std-term">enumerate</span></a> the nodes in sorted order.</p>
</dd>
<dt id="term-Insertion-Sort">Insertion Sort<a class="headerlink" href="#term-Insertion-Sort" title="Permalink to this term">¶</a></dt><dd><p>A sorting algorithm with <span class="math notranslate nohighlight">\(\Theta(n^2)\)</span>
<a class="reference internal" href="#term-average-case"><span class="xref std std-term">average</span></a> and <a class="reference internal" href="#term-worst-case"><span class="xref std std-term">worst case</span></a> cost,
and <span class="math notranslate nohighlight">\(Theta(n)\)</span> <a class="reference internal" href="#term-best-case"><span class="xref std std-term">best case</span></a> cost.
This best case cost makes it useful when we have reason to
expect the input to be nearly sorted.</p>
</dd>
<dt id="term-instance-variable">instance variable<a class="headerlink" href="#term-instance-variable" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming</span></a>,
a synonym for <a class="reference internal" href="#term-data-member"><span class="xref std std-term">data member</span></a>.</p>
</dd>
<dt id="term-integer-function">integer function<a class="headerlink" href="#term-integer-function" title="Permalink to this term">¶</a></dt><dd><p>Any function whose input is an integer and whose output is an
integer. It can be proved by
<a class="reference internal" href="#term-diagonalization-argument"><span class="xref std std-term">diagonalization</span></a> that the
set of integer functions is <a class="reference internal" href="#term-uncountably-infinite"><span class="xref std std-term">uncountably infinite</span></a>.</p>
</dd>
<dt id="term-inter-sector-gap">inter-sector gap<a class="headerlink" href="#term-inter-sector-gap" title="Permalink to this term">¶</a></dt><dd><p>On a disk drive, a physical gap in the data that occurs between
the <a class="reference internal" href="#term-sector"><span class="xref std std-term">sectors</span></a>.
This allows the <a class="reference internal" href="#term-I-O-head"><span class="xref std std-term">I/O head</span></a> detect the end of the sector.</p>
</dd>
<dt id="term-interface">interface<a class="headerlink" href="#term-interface" title="Permalink to this term">¶</a></dt><dd><p>An interface is a class-like structure that only contains method
signatures and fields. An interface does not contain an implementation
of the methods or any <a class="reference internal" href="#term-data-member"><span class="xref std std-term">data members</span></a>.</p>
</dd>
<dt id="term-intermediate-code">intermediate code<a class="headerlink" href="#term-intermediate-code" title="Permalink to this term">¶</a></dt><dd><p>A step in a typical <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a> is to transform the
original high-level language into a form on which it is easier
to do other stages of the process.
For example, some compilers will transform the original
high-level source code into <a class="reference internal" href="#term-assembly-code"><span class="xref std std-term">assembly code</span></a> on which it
can do <a class="reference internal" href="#term-code-optimization"><span class="xref std std-term">code optimization</span></a>, before translating it into its final
executable form.</p>
</dd>
<dt id="term-intermediate-code-generation">intermediate code generation<a class="headerlink" href="#term-intermediate-code-generation" title="Permalink to this term">¶</a></dt><dd><p>A phase in a <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a>, that walks through a
<a class="reference internal" href="#term-parse-tree"><span class="xref std std-term">parse tree</span></a> to produce simple <a class="reference internal" href="#term-assembly-code"><span class="xref std std-term">assembly code</span></a>.</p>
</dd>
<dt id="term-internal-fragmentation">internal fragmentation<a class="headerlink" href="#term-internal-fragmentation" title="Permalink to this term">¶</a></dt><dd><p>A condition that occurs when more than <span class="math notranslate nohighlight">\(m\)</span> bytes
are allocated to service a <a class="reference internal" href="#term-memory-request"><span class="xref std std-term">memory request</span></a> for <span class="math notranslate nohighlight">\(m\)</span>
bytes, wasting free storage.
This is often done to simplify
<a class="reference internal" href="#term-memory-manager"><span class="xref std std-term">memory management</span></a>.</p>
</dd>
<dt id="term-internal-node">internal node<a class="headerlink" href="#term-internal-node" title="Permalink to this term">¶</a></dt><dd><p>In a tree, any node that has at least one non-empty
<a class="reference internal" href="#term-child"><span class="xref std std-term">child</span></a> is an  internal node.</p>
</dd>
<dt id="term-internal-sort">internal sort<a class="headerlink" href="#term-internal-sort" title="Permalink to this term">¶</a></dt><dd><p>A sorting algorithm that is applied to data stored in
<a class="reference internal" href="#term-main-memory"><span class="xref std std-term">main memory</span></a>.
This is in contrast to an <a class="reference internal" href="#term-external-sort"><span class="xref std std-term">external sort</span></a> that is meant to
work on data stored in
<a class="reference internal" href="#term-peripheral-storage"><span class="xref std std-term">peripheral storage</span></a> such as on a <a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a>.</p>
</dd>
<dt id="term-interpolation">interpolation<a class="headerlink" href="#term-interpolation" title="Permalink to this term">¶</a></dt><dd><p>The act of finding the coefficients of a polynomial, given the
values at some points.
A polynomal of degree <span class="math notranslate nohighlight">\(n-1\)</span> requires <span class="math notranslate nohighlight">\(n\)</span> points to
interpolate the coefficients.</p>
</dd>
<dt id="term-interpolation-search">interpolation search<a class="headerlink" href="#term-interpolation-search" title="Permalink to this term">¶</a></dt><dd><p>Given a sorted array, and knowing the first and last <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a>
values stored in some subarray known to contain
<a class="reference internal" href="#term-search-key"><span class="xref std std-term">search key</span></a> <span class="math notranslate nohighlight">\(K\)</span>, interpolation search will compute
the expected location of <span class="math notranslate nohighlight">\(K\)</span> in the subarray as a fraction
of the distance between the known key values.
So it will next check that computed location, thus narrowing the
search for the next iteration.
Given reasonable key value distribution, the <a class="reference internal" href="#term-average-case"><span class="xref std std-term">average
case</span></a> for interpolation search will be
<span class="math notranslate nohighlight">\(\Theta(\log \log n)\)</span>, or better than the expected cost of
<a class="reference internal" href="#term-binary-search"><span class="xref std std-term">binary search</span></a>.
Nonetheless, binary search is expected to be faster in nearly
all practical situations due to the small difference between the
two costs, combined with the higher constant factors required to
implement interpolation search as compared to binary search.</p>
</dd>
<dt id="term-interpreter">interpreter<a class="headerlink" href="#term-interpreter" title="Permalink to this term">¶</a></dt><dd><p>In contrast to a <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a> that translates a high-level
program into something that can be repeatedly executed to
perform a computation, an interpreter directly performs
computation on the high-level langauge.
This tends to make the computation much slower than if it were
performed on the directly executable version produced by a
compiler.</p>
</dd>
<dt id="term-inversion">inversion<a class="headerlink" href="#term-inversion" title="Permalink to this term">¶</a></dt><dd><p>A measure of how disordered a series of values is. For each
element <span class="math notranslate nohighlight">\(X\)</span> in the series, count one inversion for each
element to left of <span class="math notranslate nohighlight">\(X\)</span> that is greater than the value of
<span class="math notranslate nohighlight">\(X\)</span> (and so must ultimately be moved to the right of
<span class="math notranslate nohighlight">\(X\)</span> during a sorting process).</p>
</dd>
<dt id="term-inverted-file">inverted file<a class="headerlink" href="#term-inverted-file" title="Permalink to this term">¶</a></dt><dd><p>Synonym for <a class="reference internal" href="#term-inverted-list"><span class="xref std std-term">inverted list</span></a> when the inverted list is
stored in a disk file.</p>
</dd>
<dt id="term-inverted-list">inverted list<a class="headerlink" href="#term-inverted-list" title="Permalink to this term">¶</a></dt><dd><p>An <a class="reference internal" href="#term-indexing"><span class="xref std std-term">index</span></a> which links
<a class="reference internal" href="#term-secondary-key"><span class="xref std std-term">secondary keys</span></a> to either the associated
<a class="reference internal" href="#term-primary-key"><span class="xref std std-term">primary key</span></a> or the actual record in the database.</p>
</dd>
<dt id="term-irreflexive">irreflexive<a class="headerlink" href="#term-irreflexive" title="Permalink to this term">¶</a></dt><dd><p>In set notation, binary relation <span class="math notranslate nohighlight">\(R\)</span> on set <span class="math notranslate nohighlight">\(S\)</span> is
irreflexive if <span class="math notranslate nohighlight">\(aRa\)</span> is never in the relation for
any <span class="math notranslate nohighlight">\(a \in \mathbf{S}\)</span>.</p>
</dd>
<dt id="term-ISAM">ISAM<a class="headerlink" href="#term-ISAM" title="Permalink to this term">¶</a></dt><dd><p>Indexed Sequential Access Method: an obsolete method for
indexing data for (at the time) fast retrieval. More generally,
the term is used also to generically refer to an
<a class="reference internal" href="#term-indexing"><span class="xref std std-term">index</span></a> that supports both sequential and
<a class="reference internal" href="#term-key"><span class="xref std std-term">keyed</span></a> access to data records.
Today, that would nearly always be implemented using a
<a class="reference internal" href="#term-1"><span class="xref std std-term">B-Tree</span></a>.</p>
</dd>
<dt id="term-iterator">iterator<a class="headerlink" href="#term-iterator" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-container"><span class="xref std std-term">container</span></a> such as a List, a separate class that
indicates position within the container, with support for
<a class="reference internal" href="#term-traversal"><span class="xref std std-term">traversing</span></a> through all
<a class="reference internal" href="#term-element"><span class="xref std std-term">elements</span></a> in the container.</p>
</dd>
<dt id="term-job">job<a class="headerlink" href="#term-job" title="Permalink to this term">¶</a></dt><dd><p>Common name for processes or tasks to be run by an operating
system.
They typically need to be processed in order of
importance, and so are kept organized by a
<a class="reference internal" href="#term-priority-queue"><span class="xref std std-term">priority queue</span></a>.
Another common use for this term is for a collection of tasks to
be ordered by a <a class="reference internal" href="#term-topological-sort"><span class="xref std std-term">topological sort</span></a>.</p>
</dd>
<dt id="term-jump-search">jump search<a class="headerlink" href="#term-jump-search" title="Permalink to this term">¶</a></dt><dd><p>An algorithm for searching a sorted list, that falls between
<a class="reference internal" href="#term-sequential-search"><span class="xref std std-term">sequential search</span></a> and <a class="reference internal" href="#term-binary-search"><span class="xref std std-term">binary search</span></a> in both
computational cost and conceptual complexity.
The idea is to keep jumping by some fixed number of positions
until a value is found that is bigger than <a class="reference internal" href="#term-search-key"><span class="xref std std-term">search key</span></a>
<span class="math notranslate nohighlight">\(K\)</span>, then do a sequential search over the subarray that is
now known to contain the search key.
The optimal number of steps to jump will be <span class="math notranslate nohighlight">\(\sqrt{n}\)</span> for
an array of size <span class="math notranslate nohighlight">\(n\)</span>, and the <a class="reference internal" href="#term-worst-case"><span class="xref std std-term">worst case</span></a> cost will
be <span class="math notranslate nohighlight">\(\Theta(\sqrt{n})\)</span>.</p>
</dd>
<dt id="term-K-ary-tree">K-ary tree<a class="headerlink" href="#term-K-ary-tree" title="Permalink to this term">¶</a></dt><dd><p>A type of <a class="reference internal" href="#term-full-tree"><span class="xref std std-term">full tree</span></a> where every internal node has
exactly <span class="math notranslate nohighlight">\(K\)</span> <a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a>.</p>
</dd>
<dt id="term-k-path">k-path<a class="headerlink" href="#term-k-path" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-Floyd-s-algorithm"><span class="xref std std-term">Floyd’s algorithm</span></a>, a k-path is a path between two
vertices <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> that can only go through
vertices with an index value less than or equal to <span class="math notranslate nohighlight">\(k\)</span>.</p>
</dd>
<dt id="term-kd-tree">kd tree<a class="headerlink" href="#term-kd-tree" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-spatial-data-structure"><span class="xref std std-term">spatial data structure</span></a> that uses a binary tree to
store a collection of data records based on their (point)
location in space.
It uses the concept of a <a class="reference internal" href="#term-discriminator"><span class="xref std std-term">discriminator</span></a> at each level to
decide which single component of the
<a class="reference internal" href="#term-multi-dimensional-search-key"><span class="xref std std-term">multi-dimensional search key</span></a> to branch on at that level.
It uses a <a class="reference internal" href="#term-key-space-decomposition"><span class="xref std std-term">key-space decomposition</span></a>, meaning that all data
records in the left subtree of a node have a value on the
corresponding discriminator that is less than that of the node,
while all data records in the right subtree have a greater
value.
The <a class="reference internal" href="#term-bintree"><span class="xref std std-term">bintree</span></a> is the <a class="reference internal" href="#term-image-space-decomposition"><span class="xref std std-term">image-space decomposition</span></a>
analog of the kd tree.</p>
</dd>
<dt id="term-key">key<a class="headerlink" href="#term-key" title="Permalink to this term">¶</a></dt><dd><p>A field or part of a larger record used to represent that record
for the purpose of searching or comparing.
Another term for <a class="reference internal" href="#term-search-key"><span class="xref std std-term">search key</span></a>.</p>
</dd>
<dt id="term-key-sort">key sort<a class="headerlink" href="#term-key-sort" title="Permalink to this term">¶</a></dt><dd><p>Any sorting operation applied to a collection of
<a class="reference internal" href="#term-key-value-pair"><span class="xref std std-term">key-value pairs</span></a> where the value in this
case is a <a class="reference internal" href="#term-reference"><span class="xref std std-term">reference</span></a> to a complete record (that is, a
pointer to the record in memory or a position for a record on
disk).
This is in contrast to a sorting operation that works directly
on a collection of records.
The intention is that the collection of key-value pairs is far
smaller than the collection of records themselves.
As such, this might allow for an <a class="reference internal" href="#term-internal-sort"><span class="xref std std-term">internal sort</span></a> when
sorting the records directly would require an <a class="reference internal" href="#term-external-sort"><span class="xref std std-term">external
sort</span></a>.
The collection of key-value pairs can also act as an
<a class="reference internal" href="#term-indexing"><span class="xref std std-term">index</span></a>.</p>
</dd>
<dt id="term-key-space">key space<a class="headerlink" href="#term-key-space" title="Permalink to this term">¶</a></dt><dd><p>The range of values that a <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> value may take on.</p>
</dd>
<dt id="term-key-space-decomposition">key-space decomposition<a class="headerlink" href="#term-key-space-decomposition" title="Permalink to this term">¶</a></dt><dd><p>The idea that the range for a <a class="reference internal" href="#term-search-key"><span class="xref std std-term">search key</span></a> will be split
into pieces.
There are two general approaches to this:
<a class="reference internal" href="#term-object-space-decomposition"><span class="xref std std-term">object-space decomposition</span></a> and
<a class="reference internal" href="#term-image-space-decomposition"><span class="xref std std-term">image-space decomposition</span></a>.</p>
</dd>
<dt id="term-key-value-pair">key-value pair<a class="headerlink" href="#term-key-value-pair" title="Permalink to this term">¶</a></dt><dd><p>A standard solution for solving the problem of how to relate a
<a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> value to a record (or how to find the key for a
given record) within the context of a particular
<a class="reference internal" href="#term-indexing"><span class="xref std std-term">index</span></a>.
The idea is to simply store as records in the index pairs of
keys and records.
Specifically, the index will typically store a copy of the key
along with a <a class="reference internal" href="#term-reference"><span class="xref std std-term">reference</span></a> to the record.
The other standard solution to this problem is to pass a
<a class="reference internal" href="#term-comparator"><span class="xref std std-term">comparator</span></a> function to the index.</p>
</dd>
<dt id="term-knapsack-problem">knapsack problem<a class="headerlink" href="#term-knapsack-problem" title="Permalink to this term">¶</a></dt><dd><p>While there are many variations of this problem, here is a
typical version: Given knapsack of a fixed size, and a
collection of objects of various sizes, is there a subset of the
objects that exactly fits into the knapsack?
This problem is known to be <a class="reference internal" href="#term-NP-Complete"><span class="xref std std-term">NP-complete</span></a>, but can be
solved for problem instances in practical time relatively
quickly using <a class="reference internal" href="#term-dynamic-programming"><span class="xref std std-term">dynamic programming</span></a>.
Thus, it is considered to have
<a class="reference internal" href="#term-pseudo-polynomial"><span class="xref std std-term">pseudo-polynomial</span></a> cost.
An <a class="reference internal" href="#term-optimization-problem"><span class="xref std std-term">optimization problem</span></a> version is to find the subset
that can fit with the greatest amount of items, either in terms of
their total size, or in terms of the sum of values associated
with each item.</p>
</dd>
<dt id="term-Kruskal-s-algorithm">Kruskal’s algorithm<a class="headerlink" href="#term-Kruskal-s-algorithm" title="Permalink to this term">¶</a></dt><dd><p>An algorithm for computing the <a class="reference internal" href="#term-MCST"><span class="xref std std-term">MCST</span></a> of a
<a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a>.
During processing, it makes use of the <a class="reference internal" href="#term-UNION-FIND"><span class="xref std std-term">UNION/FIND</span></a>
process to efficiently determine of two vertices are within the
same <a class="reference internal" href="#term-subgraph"><span class="xref std std-term">subgraph</span></a>.</p>
</dd>
<dt id="term-labeled-graph">labeled graph<a class="headerlink" href="#term-labeled-graph" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> with labels associated with the
<a class="reference internal" href="#term-node"><span class="xref std std-term">nodes</span></a>.</p>
</dd>
<dt id="term-language">language<a class="headerlink" href="#term-language" title="Permalink to this term">¶</a></dt><dd><p>A subset of the strings that can be generated from a given
<a class="reference internal" href="#term-alphabet"><span class="xref std std-term">alphabet</span></a>.</p>
</dd>
<dt id="term-Las-Vegas-algorithms">Las Vegas algorithms<a class="headerlink" href="#term-Las-Vegas-algorithms" title="Permalink to this term">¶</a></dt><dd><p>A form of <a class="reference internal" href="#term-randomized-algorithm"><span class="xref std std-term">randomized algorithm</span></a>.
We always find the maximum value, and “usually” we find it fast.
Such algorithms have a guaranteed result, but do not guarantee fast
running time.</p>
</dd>
<dt id="term-leaf-node">leaf node<a class="headerlink" href="#term-leaf-node" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-binary-tree"><span class="xref std std-term">binary tree</span></a>, leaf node is any node that has two
empty <a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a>.
(Note that a binary tree is defined so that every
node has two children, and that is why the leaf node has to have
two empty children, rather than no children.)
In a general tree, any node is a leaf node if it has no children.</p>
</dd>
<dt id="term-least-frequently-used">least frequently used<a class="headerlink" href="#term-least-frequently-used" title="Permalink to this term">¶</a></dt><dd><p>Abbreviated <a class="reference internal" href="#term-LFU"><span class="xref std std-term">LFU</span></a>, it is a <a class="reference internal" href="#term-heuristic"><span class="xref std std-term">heuristic</span></a> that can be
used to decide which <a class="reference internal" href="#term-buffer"><span class="xref std std-term">buffer</span></a> in a <a class="reference internal" href="#term-buffer-pool"><span class="xref std std-term">buffer pool</span></a>
to <a class="reference internal" href="#term-flush"><span class="xref std std-term">flush</span></a> when data in the buffer pool must be
replaced by new data being read into a
<a class="reference internal" href="#term-caching"><span class="xref std std-term">cache</span></a>.
However, <a class="reference internal" href="#term-least-recently-used"><span class="xref std std-term">least recently used</span></a> is more popular than LFU.
Analogous to the <a class="reference internal" href="#term-frequency-count"><span class="xref std std-term">frequency count</span></a> heuristic for
maintaining a <a class="reference internal" href="#term-self-organizing-list"><span class="xref std std-term">self-organizing list</span></a>.</p>
</dd>
<dt id="term-least-recently-used">least recently used<a class="headerlink" href="#term-least-recently-used" title="Permalink to this term">¶</a></dt><dd><p>Abbreviated <a class="reference internal" href="#term-LRU"><span class="xref std std-term">LRU</span></a>, it is a popular <a class="reference internal" href="#term-heuristic"><span class="xref std std-term">heuristic</span></a> to
use for deciding which <a class="reference internal" href="#term-buffer"><span class="xref std std-term">buffer</span></a> in a <a class="reference internal" href="#term-buffer-pool"><span class="xref std std-term">buffer pool</span></a>
to <a class="reference internal" href="#term-flush"><span class="xref std std-term">flush</span></a> when data in the buffer pool must be
replaced by new data being read into a <a class="reference internal" href="#term-caching"><span class="xref std std-term">cache</span></a>.
Analogous to the <a class="reference internal" href="#term-move-to-front"><span class="xref std std-term">move-to-front</span></a> heuristic for
maintaining a <a class="reference internal" href="#term-self-organizing-list"><span class="xref std std-term">self-organizing list</span></a>.</p>
</dd>
<dt id="term-left-recursive">left recursive<a class="headerlink" href="#term-left-recursive" title="Permalink to this term">¶</a></dt><dd><p>In automata theory, a <a class="reference internal" href="#term-production"><span class="xref std std-term">production</span></a> is left recursive
if it is of the form <span class="math notranslate nohighlight">\(A \rightarrow Ax\)</span>,
<span class="math notranslate nohighlight">\(A \in V, x \in (V \cup T)^*\)</span> where <span class="math notranslate nohighlight">\(V\)</span> is the set
of <a class="reference internal" href="#term-non-terminal"><span class="xref std std-term">non-terminals</span></a> and <span class="math notranslate nohighlight">\(T\)</span> is the set
of <a class="reference internal" href="#term-terminal"><span class="xref std std-term">terminals</span></a> in the <a class="reference internal" href="#term-grammar"><span class="xref std std-term">grammar</span></a>.</p>
</dd>
<dt id="term-length">length<a class="headerlink" href="#term-length" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-list"><span class="xref std std-term">list</span></a>, the number of elements. In a string, the
number of characters.</p>
</dd>
<dt id="term-level">level<a class="headerlink" href="#term-level" title="Permalink to this term">¶</a></dt><dd><p>In a tree, all nodes of <a class="reference internal" href="#term-depth"><span class="xref std std-term">depth</span></a> <span class="math notranslate nohighlight">\(d\)</span> are at
level <span class="math notranslate nohighlight">\(d\)</span> in the tree.
The root is the only node at level 0, and its depth is 0.</p>
</dd>
<dt id="term-lexical-analysis">lexical analysis<a class="headerlink" href="#term-lexical-analysis" title="Permalink to this term">¶</a></dt><dd><p>A phase of a <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a> or <a class="reference internal" href="#term-interpreter"><span class="xref std std-term">interpreter</span></a> responsible
for reading in characters of the program or language and grouping
them into <a class="reference internal" href="#term-token"><span class="xref std std-term">tokens</span></a>.</p>
</dd>
<dt id="term-lexical-scoping">lexical scoping<a class="headerlink" href="#term-lexical-scoping" title="Permalink to this term">¶</a></dt><dd><p>Within programming languages, the convention of allowing access
to a variable only within the block of code in which the
variable is defined.
A synonym for <a class="reference internal" href="#term-static-scoping"><span class="xref std std-term">static scoping</span></a>.</p>
</dd>
<dt id="term-LFU">LFU<a class="headerlink" href="#term-LFU" title="Permalink to this term">¶</a></dt><dd><p>Abbreviation for <a class="reference internal" href="#term-least-frequently-used"><span class="xref std std-term">least frequently used</span></a>.</p>
</dd>
<dt id="term-lifetime">lifetime<a class="headerlink" href="#term-lifetime" title="Permalink to this term">¶</a></dt><dd><p>For a variable, lifetime is the amount of time it will exist
before it is destroyed.</p>
</dd>
<dt id="term-LIFO">LIFO<a class="headerlink" href="#term-LIFO" title="Permalink to this term">¶</a></dt><dd><p>Abbreviation for “Last-In, First-Out”.
This is the access paradigm for a <a class="reference internal" href="#term-stack"><span class="xref std std-term">stack</span></a>,
and an old terminolgy for the stack is “LIFO list”.</p>
</dd>
<dt id="term-linear-congruential-method">linear congruential method<a class="headerlink" href="#term-linear-congruential-method" title="Permalink to this term">¶</a></dt><dd><p>In random number theory, a process for computing the next number
in a <a class="reference internal" href="#term-pseudo-random"><span class="xref std std-term">pseudo-random</span></a> sequence.
Starting from a <a class="reference internal" href="#term-seed"><span class="xref std std-term">seed</span></a>, the next term <span class="math notranslate nohighlight">\(r(i)\)</span> in the
series is calculated from term <span class="math notranslate nohighlight">\(r(i-1)\)</span> by the equation</p>
<div class="math notranslate nohighlight">
\[r(i) = (r(i-1)\times b) \bmod t\]</div>
<p>where <span class="math notranslate nohighlight">\(b\)</span> and <span class="math notranslate nohighlight">\(t\)</span> are constants.
These constants must be well chosen for the resulting series of
numbers to have desireable properties as a random number sequence.</p>
</dd>
<dt id="term-linear-growth-rate">linear growth rate<a class="headerlink" href="#term-linear-growth-rate" title="Permalink to this term">¶</a></dt><dd><p>For input size <span class="math notranslate nohighlight">\(n\)</span>, a growth rate of <span class="math notranslate nohighlight">\(cn\)</span> (for
<span class="math notranslate nohighlight">\(c\)</span> any positive constant).
In other words, the cost of
the associated function is linear on the input size.</p>
</dd>
<dt id="term-linear-index">linear index<a class="headerlink" href="#term-linear-index" title="Permalink to this term">¶</a></dt><dd><p>A form of <a class="reference internal" href="#term-indexing"><span class="xref std std-term">indexing</span></a> that stores
<a class="reference internal" href="#term-key-value-pair"><span class="xref std std-term">key-value pairs</span></a> in a sorted array.
Typically this is used for an index to a large collection of
records stored on disk, where the linear index itself might be
on disk or in <a class="reference internal" href="#term-main-memory"><span class="xref std std-term">main memory</span></a>.
It allows for efficient search (including for
<a class="reference internal" href="#term-range-query"><span class="xref std std-term">range queries</span></a>), but it is not good for
inserting and deleting entries in the array.
Therefore, it is an ideal indexing structure when the system
needs to do range queries but the collection of records never
changes once the linear index has been created.</p>
</dd>
<dt id="term-linear-order">linear order<a class="headerlink" href="#term-linear-order" title="Permalink to this term">¶</a></dt><dd><p>Another term for <a class="reference internal" href="#term-total-order"><span class="xref std std-term">total order</span></a>.</p>
</dd>
<dt id="term-linear-probing">linear probing<a class="headerlink" href="#term-linear-probing" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, this is the simplest
<a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a> method.
Term <span class="math notranslate nohighlight">\(i\)</span> of the <a class="reference internal" href="#term-probe-sequence"><span class="xref std std-term">probe sequence</span></a> is simply
<span class="math notranslate nohighlight">\(i\)</span>, meaning that collision resolution works by moving
sequentially through the hash table from the <a class="reference internal" href="#term-home-slot"><span class="xref std std-term">home slot</span></a>.
While simple, it is also inefficient, since it quickly leads to
certain free <a class="reference internal" href="#term-slot"><span class="xref std std-term">slots</span></a> in the hash table having
higher probability of being selected during insertion or
search.</p>
</dd>
<dt id="term-linear-probing-by-steps">linear probing by steps<a class="headerlink" href="#term-linear-probing-by-steps" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, this <a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a> method is
a variation on simple <a class="reference internal" href="#term-linear-probing"><span class="xref std std-term">linear probing</span></a>.
Some constant <span class="math notranslate nohighlight">\(c\)</span> is defined such that
term <span class="math notranslate nohighlight">\(i\)</span> of the <a class="reference internal" href="#term-probe-sequence"><span class="xref std std-term">probe sequence</span></a> is
<span class="math notranslate nohighlight">\(ci\)</span>.
This  means that collision resolution works by moving
sequentially through the hash table from the <a class="reference internal" href="#term-home-slot"><span class="xref std std-term">home slot</span></a>
in steps of size <span class="math notranslate nohighlight">\(c\)</span>.
While not much improvement on linear probing, it forms the basis
of another collision resolution method called
<a class="reference internal" href="#term-double-hashing"><span class="xref std std-term">double hashing</span></a>, where each key uses a value for
<span class="math notranslate nohighlight">\(c\)</span> defined by a second <a class="reference internal" href="#term-hash-function"><span class="xref std std-term">hash function</span></a>.</p>
</dd>
<dt id="term-linear-search">linear search<a class="headerlink" href="#term-linear-search" title="Permalink to this term">¶</a></dt><dd><p>Another name for <a class="reference internal" href="#term-sequential-search"><span class="xref std std-term">sequential search</span></a>.</p>
</dd>
<dt id="term-link-node">link node<a class="headerlink" href="#term-link-node" title="Permalink to this term">¶</a></dt><dd><p>A widely used supporting object that forms the basic
building block for a <a class="reference internal" href="#term-linked-list"><span class="xref std std-term">linked list</span></a> and similar
<a class="reference internal" href="#term-data-structure"><span class="xref std std-term">data structures</span></a>.
A link node contains one or more fields that store data, and a
<a class="reference internal" href="#term-pointer"><span class="xref std std-term">pointer</span></a> or <a class="reference internal" href="#term-reference"><span class="xref std std-term">reference</span></a> to another link node.</p>
</dd>
<dt id="term-linked-list">linked list<a class="headerlink" href="#term-linked-list" title="Permalink to this term">¶</a></dt><dd><p>An implementation for the list ADT that uses
<a class="reference internal" href="#term-dynamic-allocation"><span class="xref std std-term">dynamic allocation</span></a>
of <a class="reference internal" href="#term-link-node"><span class="xref std std-term">link nodes</span></a> to store the list elements.
Common variants are the <a class="reference internal" href="#term-singly-linked-list"><span class="xref std std-term">singly linked list</span></a>,
<a class="reference internal" href="#term-doubly-linked-list"><span class="xref std std-term">doubly linked list</span></a> and <a class="reference internal" href="#term-circular-list"><span class="xref std std-term">circular list</span></a>.
The <a class="reference internal" href="#term-overhead"><span class="xref std std-term">overhead</span></a> required is the pointers in each link node.</p>
</dd>
<dt id="term-linked-stack">linked stack<a class="headerlink" href="#term-linked-stack" title="Permalink to this term">¶</a></dt><dd><p>Analogous to a <a class="reference internal" href="#term-linked-list"><span class="xref std std-term">linked list</span></a>, this uses
<a class="reference internal" href="#term-dynamic-allocation"><span class="xref std std-term">dynamic allocation</span></a> of nodes to
store the elements when implementing the stack ADT.</p>
</dd>
<dt id="term-list">list<a class="headerlink" href="#term-list" title="Permalink to this term">¶</a></dt><dd><p>A finite, ordered sequence of <a class="reference internal" href="#term-data-item"><span class="xref std std-term">data items</span></a> known as
<a class="reference internal" href="#term-element"><span class="xref std std-term">elements</span></a>.
This is close to the mathematical concept of a <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a>.
Note that “ordered” in this definition means that the list
elements have position.
It does not refer to the relationship
between <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> values for the list elements (that is,
“ordered” does not mean “sorted”).</p>
</dd>
<dt id="term-literal">literal<a class="headerlink" href="#term-literal" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-Boolean-expression"><span class="xref std std-term">Boolean expression</span></a>, a <a class="reference internal" href="#term-literal"><span class="xref std std-term">literal</span></a> is a
<a class="reference internal" href="#term-Boolean-variable"><span class="xref std std-term">Boolean variable</span></a> or its negation.
In the context of compilers, it is any constant value.
Similar to a <a class="reference internal" href="#term-terminal"><span class="xref std std-term">terminal</span></a>.</p>
</dd>
<dt id="term-load-factor">load factor<a class="headerlink" href="#term-load-factor" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a> this is the fraction of the <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash
table</span></a> <a class="reference internal" href="#term-slot"><span class="xref std std-term">slots</span></a> that contain a record.
Hash systems usually try to keep the load factor below 50%.</p>
</dd>
<dt id="term-local-storage">local storage<a class="headerlink" href="#term-local-storage" title="Permalink to this term">¶</a></dt><dd><p>local storage.</p>
</dd>
<dt id="term-local-variable">local variable<a class="headerlink" href="#term-local-variable" title="Permalink to this term">¶</a></dt><dd><p>A variable declared within a function or method.
It exists only from the time when the function is called to when
the function exits.
When a function is suspended (due to calling another function),
the function’s local variables are stored in an
<a class="reference internal" href="#term-activation-record"><span class="xref std std-term">activation record</span></a> on the <a class="reference internal" href="#term-runtime-stack"><span class="xref std std-term">runtime stack</span></a>.</p>
</dd>
<dt id="term-locality-of-reference">locality of reference<a class="headerlink" href="#term-locality-of-reference" title="Permalink to this term">¶</a></dt><dd><p>The concept that accesses within a collection of records is not
evenly distributed.
This can express itself as some small fraction of the records
receiving the bulk of the accesses (<a class="reference internal" href="#term-80-20-rule"><span class="xref std std-term">80/20 rule</span></a>).
Alternatively, it can express itself as an increased probability
that the next or future accesses will come close to the most
recent access.
This is the fundamental property for success of <a class="reference internal" href="#term-caching"><span class="xref std std-term">caching</span></a>.</p>
</dd>
<dt id="term-logarithm">logarithm<a class="headerlink" href="#term-logarithm" title="Permalink to this term">¶</a></dt><dd><p>The <cite>logarithm</cite> of base <span class="math notranslate nohighlight">\(b\)</span> for value <span class="math notranslate nohighlight">\(y\)</span> is the power
to which <span class="math notranslate nohighlight">\(b\)</span> is raised to get <span class="math notranslate nohighlight">\(y\)</span>.</p>
</dd>
<dt id="term-logical-file">logical file<a class="headerlink" href="#term-logical-file" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-file-processing"><span class="xref std std-term">file processing</span></a>, the programmer’s view of a
<a class="reference internal" href="#term-random-access"><span class="xref std std-term">random access</span></a> file stored on <a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk</span></a>
as a contiguous series of bytes, with those bytes possibly
combining to form data records.
This is in contrast to the <a class="reference internal" href="#term-physical-file"><span class="xref std std-term">physical file</span></a>.</p>
</dd>
<dt id="term-logical-form">logical form<a class="headerlink" href="#term-logical-form" title="Permalink to this term">¶</a></dt><dd><p>The definition for a data type in terms of an ADT. Contrast to
the <a class="reference internal" href="#term-physical-form"><span class="xref std std-term">physical form</span></a> for the data type.</p>
</dd>
<dt id="term-lookup-table">lookup table<a class="headerlink" href="#term-lookup-table" title="Permalink to this term">¶</a></dt><dd><p>A table of pre-calculated values, used to speed up processing
time when the values are going to be viewed many times. The
costs to this approach are the space required for the table and
the time required to compute the table. This is an example of a
<a class="reference internal" href="#term-space-time-tradeoff"><span class="xref std std-term">space/time tradeoff</span></a>.</p>
</dd>
<dt id="term-lower-bound">lower bound<a class="headerlink" href="#term-lower-bound" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-algorithm-analysis"><span class="xref std std-term">algorithm analysis</span></a>, a <a class="reference internal" href="#term-growth-rate"><span class="xref std std-term">growth rate</span></a> that is
always less than or equal to the growth rate of the
<a class="reference internal" href="#term-algorithm"><span class="xref std std-term">algorithm</span></a> in question.
In practice, this is the fastest-growing function that we know
grows no faster than all but a constant number of inputs.
It could be a gross under-estimate of the truth.
Since the lower bound for the algorithm can be very different
for different situations (such as the <a class="reference internal" href="#term-best-case"><span class="xref std std-term">best case</span></a> or
<a class="reference internal" href="#term-worst-case"><span class="xref std std-term">worst case</span></a>), we typically have to specify which
situation we are referring to.</p>
</dd>
<dt id="term-lower-bounds-proof">lower bounds proof<a class="headerlink" href="#term-lower-bounds-proof" title="Permalink to this term">¶</a></dt><dd><p>A proof regarding the lower bound, with this term most typically
referring to the lower bound for any possible algorithm to solve
a given <a class="reference internal" href="#term-problem"><span class="xref std std-term">problem</span></a>.
Many problems have a simple lower bound based on the concept
that the minimum amount of processing is related to looking at
all of the problem’s input.
However, some problems have a higher lower bound than that.
For example, the lower bound for the problem of sorting
(<span class="math notranslate nohighlight">\(\Omega(n \log n)\)</span>) is greater than the input size to
sorting (<span class="math notranslate nohighlight">\(n\)</span>).
Proving such “non-trivial” lower bounds for problems is
notoriously difficult.</p>
</dd>
<dt id="term-LRU">LRU<a class="headerlink" href="#term-LRU" title="Permalink to this term">¶</a></dt><dd><p>Abbreviation for <a class="reference internal" href="#term-least-recently-used"><span class="xref std std-term">least recently used</span></a>.</p>
</dd>
<dt id="term-main-memory">main memory<a class="headerlink" href="#term-main-memory" title="Permalink to this term">¶</a></dt><dd><p>A synonym for <a class="reference internal" href="#term-primary-storage"><span class="xref std std-term">primary storage</span></a>.
In a computer, typically this will be <a class="reference internal" href="#term-RAM"><span class="xref std std-term">RAM</span></a>.</p>
</dd>
<dt id="term-map">map<a class="headerlink" href="#term-map" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-data-structure"><span class="xref std std-term">data structure</span></a> that relates a <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> to a
<a class="reference internal" href="#term-record"><span class="xref std std-term">record</span></a>.</p>
</dd>
<dt id="term-mapping">mapping<a class="headerlink" href="#term-mapping" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a> that maps every element of a given
<a class="reference internal" href="#term-set"><span class="xref std std-term">set</span></a> to a unique element of another set; a
correspondence.</p>
</dd>
<dt id="term-mark-array">mark array<a class="headerlink" href="#term-mark-array" title="Permalink to this term">¶</a></dt><dd><p>It is typical in <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> algorithms that there is a need
to track which nodes have been visited at some point in the
algorithm.
An <a class="reference internal" href="#term-array"><span class="xref std std-term">array</span></a> of bits or values called the <a class="reference internal" href="#term-mark-array"><span class="xref std std-term">mark array</span></a> is
often maintained for this purpose.</p>
</dd>
<dt id="term-mark-sweep-algorithm">mark/sweep algorithm<a class="headerlink" href="#term-mark-sweep-algorithm" title="Permalink to this term">¶</a></dt><dd><p>An algorithm for <a class="reference internal" href="#term-garbage-collection"><span class="xref std std-term">garbage collection</span></a>.
All accessible variables, and any space that is reachable by a
chain of pointers from any accessible variable, is “marked”.
Then a sequential sweep of all memory in the pool is made.
Any unmarked memory locations are assumed to not be needed by
the program and can be considered as free to be reused.</p>
</dd>
<dt id="term-master-theorem">master theorem<a class="headerlink" href="#term-master-theorem" title="Permalink to this term">¶</a></dt><dd><p>A theorem that makes it easy to solve
<a class="reference internal" href="#term-divide-and-conquer-recurrences"><span class="xref std std-term">divide-and-conquer recurrences</span></a>.</p>
</dd>
<dt id="term-matching">matching<a class="headerlink" href="#term-matching" title="Permalink to this term">¶</a></dt><dd><p>In graph theory, a pairing (or match) of various nodes in a graph.</p>
</dd>
<dt id="term-matching-problem">matching problem<a class="headerlink" href="#term-matching-problem" title="Permalink to this term">¶</a></dt><dd><p>Any problem that involves finding a <a class="reference internal" href="#term-matching"><span class="xref std std-term">matching</span></a> in a graph
with some desired property.
For example, a well-known <a class="reference internal" href="#term-NP-Complete"><span class="xref std std-term">NP-complete</span></a> problem is to find
a <a class="reference internal" href="#term-maximum-match"><span class="xref std std-term">maximum match</span></a> for an undirected graph.</p>
</dd>
<dt id="term-max-heap">max heap<a class="headerlink" href="#term-max-heap" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-heap"><span class="xref std std-term">heap</span></a> where every <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> has a <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> value
greater than its <a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a>.
As a consequence, the node with maximum key value is
at the <a class="reference internal" href="#term-root"><span class="xref std std-term">root</span></a>.</p>
</dd>
<dt id="term-maximal-match">maximal match<a class="headerlink" href="#term-maximal-match" title="Permalink to this term">¶</a></dt><dd><p>In a graph, any <a class="reference internal" href="#term-matching"><span class="xref std std-term">matching</span></a> that leaves no pair of
unmatched vertices that are connected.
A maximal matching is not necessarily a
<a class="reference internal" href="#term-maximum-match"><span class="xref std std-term">maximum match</span></a>.
In other words, there might be a larger matching than the
maximal matching that was found.</p>
</dd>
<dt id="term-maximum-lower-bound">maximum lower bound<a class="headerlink" href="#term-maximum-lower-bound" title="Permalink to this term">¶</a></dt><dd><p>The <a class="reference internal" href="#term-lower-bound"><span class="xref std std-term">lower bound</span></a> for the <a class="reference internal" href="#term-problem"><span class="xref std std-term">problem</span></a> of finding the
maximum value in an unsorted list is <span class="math notranslate nohighlight">\(\Omega(n)\)</span>.</p>
</dd>
<dt id="term-maximum-match">maximum match<a class="headerlink" href="#term-maximum-match" title="Permalink to this term">¶</a></dt><dd><p>In a graph, the largest possible <a class="reference internal" href="#term-matching"><span class="xref std std-term">matching</span></a>.</p>
</dd>
<dt id="term-MCST">MCST<a class="headerlink" href="#term-MCST" title="Permalink to this term">¶</a></dt><dt id="term-MST">MST<a class="headerlink" href="#term-MST" title="Permalink to this term">¶</a></dt><dd><p>Abbreviation for <a class="reference internal" href="#term-minimal-cost-spanning-tree"><span class="xref std std-term">minimal-cost spanning tree</span></a>.</p>
</dd>
<dt id="term-measure-of-cost">measure of cost<a class="headerlink" href="#term-measure-of-cost" title="Permalink to this term">¶</a></dt><dd><p>When comparing two things, such as two algorithms, some event or
unit must be used as the basic unit of comparison.
It might be number of milliseconds needed or machine instructions
expended by a program, but it is usually desirable to have a way
to do comparison between two algorithms without writing a
program.
Thus, some other measure of cost might be used as a basis for
comparison between the algorithms.
For example, when comparing two sorting algorthms it is
traditional to use as a measure of cost the number of
<a class="reference internal" href="#term-comparison"><span class="xref std std-term">comparisons</span></a> made between the key values of
record pairs.</p>
</dd>
<dt id="term-member">member<a class="headerlink" href="#term-member" title="Permalink to this term">¶</a></dt><dd><p>In set notation, this is a synonym for <a class="reference internal" href="#term-element"><span class="xref std std-term">element</span></a>.
In abstract design, a <a class="reference internal" href="#term-data-item"><span class="xref std std-term">data item</span></a> is a member of a <a class="reference internal" href="#term-type"><span class="xref std std-term">type</span></a>.
In an object-oriented language,
<a class="reference internal" href="#term-data-member"><span class="xref std std-term">data members</span></a> are data fields in an
object.</p>
</dd>
<dt id="term-member-function">member function<a class="headerlink" href="#term-member-function" title="Permalink to this term">¶</a></dt><dd><p>Each operation associated with the ADT is implemented by a
member function or <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a>.</p>
</dd>
<dt id="term-memory-allocation">memory allocation<a class="headerlink" href="#term-memory-allocation" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-memory-manager"><span class="xref std std-term">memory manager</span></a>, the act of honoring a request for
memory.</p>
</dd>
<dt id="term-memory-deallocation">memory deallocation<a class="headerlink" href="#term-memory-deallocation" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-memory-manager"><span class="xref std std-term">memory manager</span></a>, the act of freeing a block of
memory, which should create or add to a <a class="reference internal" href="#term-free-block"><span class="xref std std-term">free block</span></a>.</p>
</dd>
<dt id="term-memory-hierarchy">memory hierarchy<a class="headerlink" href="#term-memory-hierarchy" title="Permalink to this term">¶</a></dt><dd><p>The concept that a computer system stores data in a range of
storage types that range from fast but expensive
(<a class="reference internal" href="#term-primary-storage"><span class="xref std std-term">primary storage</span></a>) to slow but cheap
(<a class="reference internal" href="#term-secondary-storage"><span class="xref std std-term">secondary storage</span></a>).
When there is too much data to store in <a class="reference internal" href="#term-primary-storage"><span class="xref std std-term">primary storage</span></a>,
the goal is to have the data that is needed soon or
most often in the primary storage as much as possible,
by using <a class="reference internal" href="#term-caching"><span class="xref std std-term">caching</span></a> techniques.</p>
</dd>
<dt id="term-memory-leak">memory leak<a class="headerlink" href="#term-memory-leak" title="Permalink to this term">¶</a></dt><dd><p>In programming, the act of creating <a class="reference internal" href="#term-garbage"><span class="xref std std-term">garbage</span></a>.
In languages such as C and C++ that do not support
<a class="reference internal" href="#term-garbage-collection"><span class="xref std std-term">garbage collection</span></a>, repeated memory leaks will evenually
cause the program to terminate.</p>
</dd>
<dt id="term-memory-manager">memory manager<a class="headerlink" href="#term-memory-manager" title="Permalink to this term">¶</a></dt><dd><p>Functionality for managing a <a class="reference internal" href="#term-memory-pool"><span class="xref std std-term">memory pool</span></a>.
Typically, the memory pool is viewed as an <a class="reference internal" href="#term-array"><span class="xref std std-term">array</span></a> of bytes by the
memory manager.
The <a class="reference internal" href="#term-client"><span class="xref std std-term">client</span></a> of the memory manager will request a
collection of (adjacent) bytes of some size, and release the
bytes for reuse when the space is no longer needed.
The memory manager should not know anything about the
interpretation of the data that is being stored by the client
into the memory pool.
Depending on the precise implementation, the client might pass
in the data to be stored, in which case the memory manager will
deal with the actual copy of the data into the memory pool.
The memory manager will return to the client a <a class="reference internal" href="#term-handle"><span class="xref std std-term">handle</span></a>
that can later be used by the client to retrieve the data.</p>
</dd>
<dt id="term-memory-pool">memory pool<a class="headerlink" href="#term-memory-pool" title="Permalink to this term">¶</a></dt><dd><p>Memory (usually in <a class="reference internal" href="#term-RAM"><span class="xref std std-term">RAM</span></a> but possibly on disk or
<a class="reference internal" href="#term-peripheral-storage"><span class="xref std std-term">peripheral storage</span></a> device) that is logically viewed as
an array of memory positions.
A memory pool is usually managed by a <a class="reference internal" href="#term-memory-manager"><span class="xref std std-term">memory manager</span></a>.</p>
</dd>
<dt id="term-memory-request">memory request<a class="headerlink" href="#term-memory-request" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-memory-manager"><span class="xref std std-term">memory manager</span></a>, a request from some <a class="reference internal" href="#term-client"><span class="xref std std-term">client</span></a>
to the memory manager to reserve a block of memory and store
some bytes there.</p>
</dd>
<dt id="term-merge-insert-sort">merge insert sort<a class="headerlink" href="#term-merge-insert-sort" title="Permalink to this term">¶</a></dt><dd><p>A synonym for the <a class="reference internal" href="#term-Ford-and-Johnson-sort"><span class="xref std std-term">Ford and Johnson sort</span></a>.</p>
</dd>
<dt id="term-Mergesort">Mergesort<a class="headerlink" href="#term-Mergesort" title="Permalink to this term">¶</a></dt><dd><p>A sorting algorithm that requires <span class="math notranslate nohighlight">\(\Theta(n \log n)\)</span> in
the <a class="reference internal" href="#term-best-case"><span class="xref std std-term">best</span></a>, <a class="reference internal" href="#term-average-case"><span class="xref std std-term">average</span></a>,
and <a class="reference internal" href="#term-worst-case"><span class="xref std std-term">worst</span></a> cases.
Conceptually it is simple:
Split the list in half, sort the halves, then merge them
together.
It is a bit complicated to implement efficiently on an <a class="reference internal" href="#term-array"><span class="xref std std-term">array</span></a>.</p>
</dd>
<dt id="term-message">message<a class="headerlink" href="#term-message" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-memory-manager"><span class="xref std std-term">memory manager</span></a> implementation
(particularly a memory manager implemented with a
<a class="reference internal" href="#term-message-passing"><span class="xref std std-term">message passing</span></a> style of
<a class="reference internal" href="#term-interface"><span class="xref std std-term">interface</span></a>), the message is the data that the <a class="reference internal" href="#term-client"><span class="xref std std-term">client</span></a> of
the memory manager wishes to have stored in the
<a class="reference internal" href="#term-memory-pool"><span class="xref std std-term">memory pool</span></a>.
The memory manager will reply to the client by returning a
<a class="reference internal" href="#term-handle"><span class="xref std std-term">handle</span></a> that defines the location and size of the message
as stored in the memory pool.
The client can later recover the message by passing the handle
back to the memory manager.</p>
</dd>
<dt id="term-message-passing">message passing<a class="headerlink" href="#term-message-passing" title="Permalink to this term">¶</a></dt><dd><p>A common approach to implementing the <a class="reference internal" href="#term-ADT"><span class="xref std std-term">ADT</span></a> for a
<a class="reference internal" href="#term-memory-manager"><span class="xref std std-term">memory manager</span></a> or <a class="reference internal" href="#term-buffer-pool"><span class="xref std std-term">buffer pool</span></a>, where the
contents of a <a class="reference internal" href="#term-message"><span class="xref std std-term">message</span></a> to be stored is explicitly
passed between the client and the memory manager.
This is in contrast to a <a class="reference internal" href="#term-buffer-passing"><span class="xref std std-term">buffer passing</span></a> approach.</p>
</dd>
<dt id="term-metaphor">metaphor<a class="headerlink" href="#term-metaphor" title="Permalink to this term">¶</a></dt><dd><p>Humans deal with complexity by assigning a label to an assembly of
objects or concepts and then manipulating the label in place of the
assembly. Cognitive psychologists call such a label a
metaphor.</p>
</dd>
<dt id="term-method">method<a class="headerlink" href="#term-method" title="Permalink to this term">¶</a></dt><dd><p>In the <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming paradigm</span></a>,
a method is an operation on a <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a>.
A synonym for <a class="reference internal" href="#term-member-function"><span class="xref std std-term">member function</span></a>.</p>
</dd>
<dt id="term-mid-square-method">mid-square method<a class="headerlink" href="#term-mid-square-method" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, an approach to implementing a
<a class="reference internal" href="#term-hash-function"><span class="xref std std-term">hash function</span></a>.
The key value is squared, and some number of bits from the
middle of the resulting value are extracted as the hash code.
Some care must be taken to extract bits that tend to actually be
in the middle of the resulting value, which requires some
understanding of the typical key values.
When done correctly, this has the advantage of having the hash
code be affected by all bits of the key</p>
</dd>
<dt id="term-min-heap">min heap<a class="headerlink" href="#term-min-heap" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-heap"><span class="xref std std-term">heap</span></a> where every <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> has a <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> value
less than its <a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a>.
As a consequence, the node with minimum key value is
at the <a class="reference internal" href="#term-root"><span class="xref std std-term">root</span></a>.</p>
</dd>
<dt id="term-minimal-cost-spanning-tree">minimal-cost spanning tree<a class="headerlink" href="#term-minimal-cost-spanning-tree" title="Permalink to this term">¶</a></dt><dd><p>Abbreviated as MCST, or sometimes as MST.
Derived from a <a class="reference internal" href="#term-weighted-graph"><span class="xref std std-term">weighted graph</span></a>, the MCST is the
<a class="reference internal" href="#term-subset"><span class="xref std std-term">subset</span></a> of the graph’s <a class="reference internal" href="#term-edge"><span class="xref std std-term">edges</span></a> that
maintains the connectivitiy of the graph while having lowest
total cost (as defined by the sum of the
<a class="reference internal" href="#term-weight"><span class="xref std std-term">weights</span></a> of the edges in the MCST).
The result is referred to as a <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a> because it would
never have a <a class="reference internal" href="#term-cycle"><span class="xref std std-term">cycle</span></a> (since an edge could be removed from
the cycle and still preserve connectivity).
Two algorithms to solve this problem are
<a class="reference internal" href="#term-Prim-s-algorithm"><span class="xref std std-term">Prim’s algorithm</span></a> and <a class="reference internal" href="#term-Kruskal-s-algorithm"><span class="xref std std-term">Kruskal’s algorithm</span></a>.</p>
</dd>
<dt id="term-minimum-external-path-weight">minimum external path weight<a class="headerlink" href="#term-minimum-external-path-weight" title="Permalink to this term">¶</a></dt><dd><p>Given a collection of objects, each associated with a
<a class="reference internal" href="#term-leaf-node"><span class="xref std std-term">leaf node</span></a> in a tree, the binary tree with minimum
external path weight is the one with the minimum sum of
<a class="reference internal" href="#term-weighted-path-length"><span class="xref std std-term">weighted path lengths</span></a> for the
given set of leaves.
This concept is used to create a <a class="reference internal" href="#term-Huffman-coding-tree"><span class="xref std std-term">Huffman coding tree</span></a>,
where a letter with high weight should have low depth, so that
it will count the least against the total path length.
As a result, another letter might be pushed deeper in the tree
if it has less weight.</p>
</dd>
<dt id="term-mod">mod<a class="headerlink" href="#term-mod" title="Permalink to this term">¶</a></dt><dd><p>Abbreviation for the <a class="reference internal" href="#term-modulus"><span class="xref std std-term">modulus</span></a> function.</p>
</dd>
<dt id="term-model">model<a class="headerlink" href="#term-model" title="Permalink to this term">¶</a></dt><dd><p>A simplification of reality that preserves only the essential
elements.
With a model, we can more easily focus on and reason about these
essentials.
In <a class="reference internal" href="#term-algorithm-analysis"><span class="xref std std-term">algorithm analysis</span></a>, we are especially concerned with
the <a class="reference internal" href="#term-cost-model"><span class="xref std std-term">cost model</span></a> for measuring the cost of an algorithm.</p>
</dd>
<dt id="term-modulus">modulus<a class="headerlink" href="#term-modulus" title="Permalink to this term">¶</a></dt><dd><p>The modulus function returns the
remainder of an integer division.
Sometimes written <span class="math notranslate nohighlight">\(n \bmod m\)</span> in mathematical expressions,
the syntax in many programming languages is <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">%</span> <span class="pre">m</span></code>.</p>
</dd>
<dt id="term-Monte-Carlo-algorithms">Monte Carlo algorithms<a class="headerlink" href="#term-Monte-Carlo-algorithms" title="Permalink to this term">¶</a></dt><dd><p>A form of <a class="reference internal" href="#term-randomized-algorithm"><span class="xref std std-term">randomized algorithm</span></a>.
We find the maximum value fast, or we don’t get an answer at all
(but fast).
While such algorithms have good running time, their result is not
guaranteed.</p>
</dd>
<dt id="term-move-to-front">move-to-front<a class="headerlink" href="#term-move-to-front" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-heuristic"><span class="xref std std-term">heuristic</span></a> used to maintain a
<a class="reference internal" href="#term-self-organizing-list"><span class="xref std std-term">self-organizing list</span></a>.
Under this heuristic, whenever a record is accessed it is moved
to the front of the list.
Analogous to the <a class="reference internal" href="#term-least-recently-used"><span class="xref std std-term">least recently used</span></a> heuristic for
maintaining a <a class="reference internal" href="#term-buffer-pool"><span class="xref std std-term">buffer pool</span></a>.</p>
</dd>
<dt id="term-multi-dimensional-search-key">multi-dimensional search key<a class="headerlink" href="#term-multi-dimensional-search-key" title="Permalink to this term">¶</a></dt><dd><p>A search key containing multiple parts, that works in
conjunction with a <a class="reference internal" href="#term-multi-dimensional-search-structure"><span class="xref std std-term">multi-dimensional search structure</span></a>.
Most typically, a <a class="reference internal" href="#term-spatial"><span class="xref std std-term">spatial</span></a> search key representing a
position in multi-dimensional (2 or 3 dimensions) space.
But a multi-dimensional key could be used to organize data within
non-spatial dimensions, such as temperature and time.</p>
</dd>
<dt id="term-multi-dimensional-search-structure">multi-dimensional search structure<a class="headerlink" href="#term-multi-dimensional-search-structure" title="Permalink to this term">¶</a></dt><dd><p>A data structure used to support efficient search on a
<a class="reference internal" href="#term-multi-dimensional-search-key"><span class="xref std std-term">multi-dimensional search key</span></a>.
The main concept here is that a multi-dimensional search
structure works more efficiently by considering the multiple
parts of the search key as a whole, rather than making
independent searches on each one-dimensional component of the
key.
A primary example is a <a class="reference internal" href="#term-spatial-data-structure"><span class="xref std std-term">spatial data structure</span></a> that can
efficiently represent and search for records in
multi-dimensional space.</p>
</dd>
<dt id="term-multilist">multilist<a class="headerlink" href="#term-multilist" title="Permalink to this term">¶</a></dt><dd><p>A list that may contain sublists.
This term is sometimes used as a synonym to the term
<a class="reference internal" href="#term-bag"><span class="xref std std-term">bag</span></a>.</p>
</dd>
<dt id="term-natural-numbers">natural numbers<a class="headerlink" href="#term-natural-numbers" title="Permalink to this term">¶</a></dt><dd><p>Zero and the positive integers.</p>
</dd>
<dt id="term-necessary-fallacy">necessary fallacy<a class="headerlink" href="#term-necessary-fallacy" title="Permalink to this term">¶</a></dt><dd><p>A common mistake in a
<a class="reference internal" href="#term-lower-bounds-proof"><span class="xref std std-term">lower bounds proof</span></a> for a problem, where the proof makes
an inappropriate assumption that any algorithm must operate in
some manner (typically in the way that some known algorithm
behaves).</p>
</dd>
<dt id="term-neighbor">neighbor<a class="headerlink" href="#term-neighbor" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a>, a <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> <span class="math notranslate nohighlight">\(w\)</span> is said to be a
neighbor of <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> <span class="math notranslate nohighlight">\(v\)</span> if there is an <a class="reference internal" href="#term-edge"><span class="xref std std-term">edge</span></a>
from <span class="math notranslate nohighlight">\(v\)</span> to <span class="math notranslate nohighlight">\(w\)</span>.</p>
</dd>
<dt id="term-node">node<a class="headerlink" href="#term-node" title="Permalink to this term">¶</a></dt><dd><p>The objects that make up a linked structure such as a linked
list or binary tree.
Typically, nodes are allocated using
<a class="reference internal" href="#term-dynamic-memory-allocation"><span class="xref std std-term">dynamic memory allocation</span></a>.
In <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> terminology, the nodes are more commonly called
<a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertices</span></a>.</p>
</dd>
<dt id="term-non-deterministic">non-deterministic<a class="headerlink" href="#term-non-deterministic" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-Finite-Automata"><span class="xref std std-term">finite automata</span></a>, at least one <a class="reference internal" href="#term-state"><span class="xref std std-term">state</span></a> has
multiple transitions on at least one symbol.
This means that it is not <a class="reference internal" href="#term-deterministic"><span class="xref std std-term">deterministic</span></a> about what
transition to take in that situation.
A non-deterministic machine is said to <a class="reference internal" href="#term-accept"><span class="xref std std-term">accept</span></a> a string
if it completes execution on the string in an
<a class="reference internal" href="#term-accepting-state"><span class="xref std std-term">accepting state</span></a> under at least one choice of
non-deterministic transitions.
Generally, non-determinism can be simulated with a deterministic
machine by alternating between the execution that would take
place under each of the branching choices.</p>
</dd>
<dt id="term-non-deterministic-algorithm">non-deterministic algorithm<a class="headerlink" href="#term-non-deterministic-algorithm" title="Permalink to this term">¶</a></dt><dd><p>An algorithm that may operate using a
<a class="reference internal" href="#term-non-deterministic-choice"><span class="xref std std-term">non-deterministic choice</span></a> operation.</p>
</dd>
<dt id="term-non-deterministic-choice">non-deterministic choice<a class="headerlink" href="#term-non-deterministic-choice" title="Permalink to this term">¶</a></dt><dd><p>An operation that captures the concept of nondeterminism.
A nondeterministic choice can be viewed as either
“correctly guessing” between a set of choices, or implementing
each of the choices in parallel.
In the parallel view, the nondeterminism was successful if at
least one of the choices leads to a correct answer.</p>
</dd>
<dt id="term-non-deterministic-polynomial-time-algorithm">non-deterministic polynomial time algorithm<a class="headerlink" href="#term-non-deterministic-polynomial-time-algorithm" title="Permalink to this term">¶</a></dt><dd><p>An algorithm that runs in polynomial time, and which may
(or might not) use <a class="reference internal" href="#term-non-deterministic-choice"><span class="xref std std-term">non-deterministic choice</span></a>.</p>
</dd>
<dt id="term-non-strict-partial-order">non-strict partial order<a class="headerlink" href="#term-non-strict-partial-order" title="Permalink to this term">¶</a></dt><dd><p>In set notation, a relation that is <a class="reference internal" href="#term-reflexive"><span class="xref std std-term">reflexive</span></a>,
<a class="reference internal" href="#term-antisymmetric"><span class="xref std std-term">antisymmetric</span></a>, and <a class="reference internal" href="#term-transitive"><span class="xref std std-term">transitive</span></a>.</p>
</dd>
<dt id="term-non-terminal">non-terminal<a class="headerlink" href="#term-non-terminal" title="Permalink to this term">¶</a></dt><dd><p>In contrast to a <a class="reference internal" href="#term-terminal"><span class="xref std std-term">terminal</span></a>, a non-terminal is an abstract
state in a <a class="reference internal" href="#term-production-rule"><span class="xref std std-term">production rule</span></a>. Begining with the
<a class="reference internal" href="#term-start-symbol"><span class="xref std std-term">start symbol</span></a>, all non-terminals must be converted into
terminals in order to complete a <a class="reference internal" href="#term-derivation"><span class="xref std std-term">derivation</span></a>.</p>
</dd>
<dt id="term-Nondeterministic-Finite-Automata">Nondeterministic Finite Automata<a class="headerlink" href="#term-Nondeterministic-Finite-Automata" title="Permalink to this term">¶</a></dt><dt id="term-Nondeterministic-Finite-Acceptor">Nondeterministic Finite Acceptor<a class="headerlink" href="#term-Nondeterministic-Finite-Acceptor" title="Permalink to this term">¶</a></dt><dt id="term-NFA">NFA<a class="headerlink" href="#term-NFA" title="Permalink to this term">¶</a></dt><dd><p>An <a class="reference internal" href="#term-automata"><span class="xref std std-term">automata</span></a> or abstract machine that can process an
input string (shown on a tape) from left to right.
There is a control unit (with <a class="reference internal" href="#term-state"><span class="xref std std-term">states</span></a>),
behavior defined for what to do when in a given state and with a
given symbol on the current square of the tape.
All that we can “do” is change state before going to the next
letter to the right.
In distinction from a <a class="reference internal" href="#term-DFA"><span class="xref std std-term">DFA</span></a>, a NFA may have multiple
transitions from a given state on the same input symbol, or
there can be a transition from a given state on the empty
string.</p>
</dd>
<dt id="term-NP">NP<a class="headerlink" href="#term-NP" title="Permalink to this term">¶</a></dt><dd><p>An abbreviation for
<a class="reference internal" href="#term-non-deterministic-polynomial-time-algorithm"><span class="xref std std-term">non-deterministic polynomial</span></a>.</p>
</dd>
<dt id="term-NP-Complete">NP-Complete<a class="headerlink" href="#term-NP-Complete" title="Permalink to this term">¶</a></dt><dd><p>A class of problems that are related to each other in this way:
If ever one such problem is proved to be solvable in
polynomial time, or proved to require exponential time,
then all other NP-Complete problems will cost likewise.
Since so many real-world problems have been proved to be
NP-Complete, it would be extremely useful to determine if they
have polynomial or exponential cost. But so far, nobody has
been able to determine the truth of the situation.
A more technical definition is that a problem is NP-Complete if
it is in NP and is NP-hard.</p>
</dd>
<dt id="term-NP-Completeness-proof">NP-Completeness proof<a class="headerlink" href="#term-NP-Completeness-proof" title="Permalink to this term">¶</a></dt><dd><p>A type of <a class="reference internal" href="#term-reduction"><span class="xref std std-term">reduction</span></a> used to demonstrate that a
particular <a class="reference internal" href="#term-problem"><span class="xref std std-term">problem</span></a> is <a class="reference internal" href="#term-NP-Complete"><span class="xref std std-term">NP-complete</span></a>.
Specifically, an NP-Completeness proof must first show that the
problem is in class <a class="reference internal" href="#term-NP"><span class="xref std std-term">NP</span></a>, and then show (by using a
reduction to another NP-Complete problem) that the problem is
<a class="reference internal" href="#term-NP-hard"><span class="xref std std-term">NP-hard</span></a>.</p>
</dd>
<dt id="term-NP-hard">NP-hard<a class="headerlink" href="#term-NP-hard" title="Permalink to this term">¶</a></dt><dd><p>A problem that is “as hard as” any other problem in <a class="reference internal" href="#term-NP"><span class="xref std std-term">NP</span></a>.
That is, Problem X is NP-hard if any algorithm in NP can be
<a class="reference internal" href="#term-reduction"><span class="xref std std-term">reduced</span></a> to X in polynomial time.</p>
</dd>
<dt id="term-nth-roots-of-unity">nth roots of unity<a class="headerlink" href="#term-nth-roots-of-unity" title="Permalink to this term">¶</a></dt><dd><p>All of the points along the unit circle in the complex plane
that represent multiples of the
<a class="reference internal" href="#term-primitive-nth-root-of-unity"><span class="xref std std-term">primitive nth root of unity</span></a>.</p>
</dd>
<dt id="term-object">object<a class="headerlink" href="#term-object" title="Permalink to this term">¶</a></dt><dd><p>An instance of a <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a>, that is, something that is created and
takes up storage during the execution of a computer program.
In the <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming paradigm</span></a>, objects
are the basic units of operation.
Objects have state in the form of <a class="reference internal" href="#term-data-member"><span class="xref std std-term">data members</span></a>,
and they know how to perform certain actions
(<a class="reference internal" href="#term-method"><span class="xref std std-term">methods</span></a>).</p>
</dd>
<dt id="term-object-oriented-programming-paradigm">object-oriented programming paradigm<a class="headerlink" href="#term-object-oriented-programming-paradigm" title="Permalink to this term">¶</a></dt><dd><p>An approach to problem-solving where all computations are
carried out using <a class="reference internal" href="#term-object"><span class="xref std std-term">objects</span></a>.</p>
</dd>
<dt id="term-object-space-decomposition">object-space decomposition<a class="headerlink" href="#term-object-space-decomposition" title="Permalink to this term">¶</a></dt><dd><p>A from of <a class="reference internal" href="#term-key-space-decomposition"><span class="xref std std-term">key-space decomposition</span></a> where the
<a class="reference internal" href="#term-key-space"><span class="xref std std-term">key space</span></a> is determined
by the actual values of keys that are found.
For example, a <a class="reference internal" href="#term-BST"><span class="xref std std-term">BST</span></a> stores a key value in its root,
and all other values in the tree with lesser value are in the
left <a class="reference internal" href="#term-subtree"><span class="xref std std-term">subtree</span></a>.
Thus, the root value has split (or decomposed) the
key space for that key based on its value into left
and right parts.
An object-space decomposition is in opposition to an
<a class="reference internal" href="#term-image-space-decomposition"><span class="xref std std-term">image-space decomposition</span></a>.</p>
</dd>
<dt id="term-octree">octree<a class="headerlink" href="#term-octree" title="Permalink to this term">¶</a></dt><dd><p>The three-dimensional equivalent of the <a class="reference internal" href="#term-quadtree"><span class="xref std std-term">quadtree</span></a> would
be a tree with <span class="math notranslate nohighlight">\(2^3\)</span> or eight branches.</p>
</dd>
<dt id="term-Omega-notation">Omega notation<a class="headerlink" href="#term-Omega-notation" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-algorithm-analysis"><span class="xref std std-term">algorithm analysis</span></a>,
<span class="math notranslate nohighlight">\(\Omega\)</span> notation is used to describe a <a class="reference internal" href="#term-lower-bound"><span class="xref std std-term">lower bound</span></a>.
Roughly (but not completely) analogous to
<a class="reference internal" href="#term-big-Oh-notation"><span class="xref std std-term">big-Oh notation</span></a> used to define an <a class="reference internal" href="#term-upper-bound"><span class="xref std std-term">upper bound</span></a>.</p>
</dd>
<dt id="term-one-way-list">one-way list<a class="headerlink" href="#term-one-way-list" title="Permalink to this term">¶</a></dt><dd><p>A synonym for a <a class="reference internal" href="#term-singly-linked-list"><span class="xref std std-term">singly linked list</span></a>.</p>
</dd>
<dt id="term-open-addressing">open addressing<a class="headerlink" href="#term-open-addressing" title="Permalink to this term">¶</a></dt><dd><p>A synonym for <a class="reference internal" href="#term-closed-hash-system"><span class="xref std std-term">closed hashing</span></a>.</p>
</dd>
<dt id="term-open-hash-system">open hash system<a class="headerlink" href="#term-open-hash-system" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-hash-system"><span class="xref std std-term">hash system</span></a> where multiple records might be associated
with the same slot of a <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>.
Typically this is done using a linked list to store the records.
This is in contrast to a <a class="reference internal" href="#term-closed-hash-system"><span class="xref std std-term">closed hash system</span></a>.</p>
</dd>
<dt id="term-operating-system">operating system<a class="headerlink" href="#term-operating-system" title="Permalink to this term">¶</a></dt><dd><p>The control program for a computer.
Its purpose is to control hardware, manage resources, and
present a standard interface to these to other software
components.</p>
</dd>
<dt id="term-optimal-static-ordering">optimal static ordering<a class="headerlink" href="#term-optimal-static-ordering" title="Permalink to this term">¶</a></dt><dd><p>A theoretical construct defining the best static (non-changing)
order in which to place a collection of records so as to
minimize the number of records <a class="reference internal" href="#term-visit"><span class="xref std std-term">visited</span></a> by a
series of sequential searches.
It is a useful concept for the purpose of defining a theoretical
optimum against which to compare the performance for a
<a class="reference internal" href="#term-self-organizing-list-heuristic"><span class="xref std std-term">self-organizing list heuristic</span></a>.</p>
</dd>
<dt id="term-optimization-problem">optimization problem<a class="headerlink" href="#term-optimization-problem" title="Permalink to this term">¶</a></dt><dd><p>Any problem where there are a (typically large) collection of
potential solutions, and the goal is to find the best solution.
An example is the Traveling Salesman Problem, where
visiting <span class="math notranslate nohighlight">\(n\)</span> cities in some order has a cost, and the goal
is to visit in the cheapest order.</p>
</dd>
<dt id="term-out-degree">out degree<a class="headerlink" href="#term-out-degree" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> terminology, the out degree for a <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertex</span></a> is
the number of edges directed out of the vertex.</p>
</dd>
<dt id="term-overflow">overflow<a class="headerlink" href="#term-overflow" title="Permalink to this term">¶</a></dt><dd><p>The condition where the amount of data stored in an entity has
exceeded its capacity.
For example, a node in a <a class="reference internal" href="#term-1"><span class="xref std std-term">B-tree</span></a> can store a certain
number of records.
If a record is attempted to be inserted into a node that is
full, then something has to be done to handle this case.</p>
</dd>
<dt id="term-overflow-bucket">overflow bucket<a class="headerlink" href="#term-overflow-bucket" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-bucket-hashing"><span class="xref std std-term">bucket hashing</span></a>, this is the <a class="reference internal" href="#term-bucket"><span class="xref std std-term">bucket</span></a> into which
a record is placed if the bucket containing the record’s
<a class="reference internal" href="#term-home-slot"><span class="xref std std-term">home slot</span></a> is full.
The overflow bucket is logically considered to have infinite
capacity, though in practice search and insert will become
relatively expensive if many records are stored in the overflow
bucket.</p>
</dd>
<dt id="term-overhead">overhead<a class="headerlink" href="#term-overhead" title="Permalink to this term">¶</a></dt><dd><p>All information stored by a data structure aside from the actual
data.
For example, the pointer fields in a <a class="reference internal" href="#term-linked-list"><span class="xref std std-term">linked list</span></a> or
<a class="reference internal" href="#term-BST"><span class="xref std std-term">BST</span></a>, or the unused positions in an
<a class="reference internal" href="#term-array-based-list"><span class="xref std std-term">array-based list</span></a>.</p>
</dd>
<dt id="term-page">page<a class="headerlink" href="#term-page" title="Permalink to this term">¶</a></dt><dd><p>A term often used to refer to the contents of a single
<a class="reference internal" href="#term-buffer"><span class="xref std std-term">buffer</span></a> within a <a class="reference internal" href="#term-buffer-pool"><span class="xref std std-term">buffer pool</span></a> or other
<a class="reference internal" href="#term-virtual-memory"><span class="xref std std-term">virtual memory</span></a>.
This corresponds to a single <a class="reference internal" href="#term-block"><span class="xref std std-term">block</span></a> or <a class="reference internal" href="#term-sector"><span class="xref std std-term">sector</span></a> of
data from <a class="reference internal" href="#term-backing-storage"><span class="xref std std-term">backing storage</span></a>, which is the fundamental unit
of I/O.</p>
</dd>
<dt id="term-parameter">parameter<a class="headerlink" href="#term-parameter" title="Permalink to this term">¶</a></dt><dd><p>The values making up an input to a <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a>.</p>
</dd>
<dt id="term-parent">parent<a class="headerlink" href="#term-parent" title="Permalink to this term">¶</a></dt><dd><p>In a tree, the <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> <span class="math notranslate nohighlight">\(P\)</span> that directly links to a
node <span class="math notranslate nohighlight">\(A\)</span> is the parent of <span class="math notranslate nohighlight">\(A\)</span>. <span class="math notranslate nohighlight">\(A\)</span> is the
<a class="reference internal" href="#term-child"><span class="xref std std-term">child</span></a> of <span class="math notranslate nohighlight">\(P\)</span>.</p>
</dd>
<dt id="term-parent-pointer-representation">parent pointer representation<a class="headerlink" href="#term-parent-pointer-representation" title="Permalink to this term">¶</a></dt><dd><p>For <a class="reference internal" href="#term-tree"><span class="xref std std-term">trees</span></a>, a <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> implementation where
each node stores only a pointer to its <a class="reference internal" href="#term-parent"><span class="xref std std-term">parent</span></a>, rather
than to its <a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a>.
This makes it easy to go up the tree toward the <a class="reference internal" href="#term-root"><span class="xref std std-term">root</span></a>,
but not down the tree toward the <a class="reference internal" href="#term-leaf-node"><span class="xref std std-term">leaves</span></a>.
This is most appropriate for solving the
<a class="reference internal" href="#term-UNION-FIND"><span class="xref std std-term">UNION/FIND</span></a> problem.</p>
</dd>
<dt id="term-parity">parity<a class="headerlink" href="#term-parity" title="Permalink to this term">¶</a></dt><dd><p>The concept of matching even-ness or odd-ness, the basic idea
behind using a <a class="reference internal" href="#term-parity-bit"><span class="xref std std-term">parity bit</span></a> for error detection.</p>
</dd>
<dt id="term-parity-bit">parity bit<a class="headerlink" href="#term-parity-bit" title="Permalink to this term">¶</a></dt><dd><p>A common method for checking if transmission of a
sequence of bits has been performed correctly.
The idea is to count the number of 1 bits in the sequence, and
set the parity bit to 1 if this number is odd, and 0 if it is
even.
Then, the transmitted sequence of bits can be checked to see if
its parity matches the value of the parity bit.
This will catch certain types of errors, in particular if the
value for a single bit has been reversed.
This was used, for example, in early versions of
<a class="reference internal" href="#term-ASCII-character-coding"><span class="xref std std-term">ASCII character coding</span></a>.</p>
</dd>
<dt id="term-parse-tree">parse tree<a class="headerlink" href="#term-parse-tree" title="Permalink to this term">¶</a></dt><dd><p>A tree that represents the syntactic structure of an input
string, making it easy to compare against a <a class="reference internal" href="#term-grammar"><span class="xref std std-term">grammar</span></a> to
see if it is syntactically correct.</p>
</dd>
<dt id="term-parser">parser<a class="headerlink" href="#term-parser" title="Permalink to this term">¶</a></dt><dd><p>A part of a <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a> that takes as input the program
text (or more typically, the tokens from the <a class="reference internal" href="#term-scanner"><span class="xref std std-term">scanner</span></a>),
and verifies that the program is syntactically correct.
Typically it will build a <a class="reference internal" href="#term-parse-tree"><span class="xref std std-term">parse tree</span></a> as part of the
process.</p>
</dd>
<dt id="term-partial-order">partial order<a class="headerlink" href="#term-partial-order" title="Permalink to this term">¶</a></dt><dd><p>In set notation, a binary relation is called a partial order if
it is <a class="reference internal" href="#term-antisymmetric"><span class="xref std std-term">antisymmetric</span></a> and <a class="reference internal" href="#term-transitive"><span class="xref std std-term">transitive</span></a>.
If the relation is also <a class="reference internal" href="#term-reflexive"><span class="xref std std-term">reflexive</span></a>, then it is a
<a class="reference internal" href="#term-non-strict-partial-order"><span class="xref std std-term">non-strict partial order</span></a>.
Alternatively, if the relation is also <a class="reference internal" href="#term-irreflexive"><span class="xref std std-term">irreflexive</span></a>, then
it is a <a class="reference internal" href="#term-strict-partial-order"><span class="xref std std-term">strict partial order</span></a>.</p>
</dd>
<dt id="term-partially-ordered-set">partially ordered set<a class="headerlink" href="#term-partially-ordered-set" title="Permalink to this term">¶</a></dt><dd><p>The set on which a <a class="reference internal" href="#term-partial-order"><span class="xref std std-term">partial order</span></a> is defined is called a
partially ordered set.</p>
</dd>
<dt id="term-partition">partition<a class="headerlink" href="#term-partition" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-Quicksort"><span class="xref std std-term">Quicksort</span></a>, the process of splitting a list into two
sublists, such that one sublist has values less than the
<a class="reference internal" href="#term-pivot"><span class="xref std std-term">pivot</span></a> value, and the other with values greater than the
pivot. This process takes <span class="math notranslate nohighlight">\(\Theta(i)\)</span> time on a sublist of
length <span class="math notranslate nohighlight">\(i\)</span>.</p>
</dd>
<dt id="term-pass-by-reference">pass by reference<a class="headerlink" href="#term-pass-by-reference" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-reference"><span class="xref std std-term">reference</span></a> to the variable is passed to the called
function. So, any modifications will affect the original
variable.</p>
</dd>
<dt id="term-pass-by-value">pass by value<a class="headerlink" href="#term-pass-by-value" title="Permalink to this term">¶</a></dt><dd><p>A copy of a variable is passed to the called function. So, any
modifications will not affect the original variable.</p>
</dd>
<dt id="term-path">path<a class="headerlink" href="#term-path" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a> or <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> terminology,
a sequence of <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertices</span></a>
<span class="math notranslate nohighlight">\(v_1, v_2, ..., v_n\)</span>
forms a path of length <span class="math notranslate nohighlight">\(n-1\)</span> if there exist edges from
<span class="math notranslate nohighlight">\(v_i\)</span> to <span class="math notranslate nohighlight">\(v_{i+1}\)</span> for <span class="math notranslate nohighlight">\(1 \leq i &lt; n\)</span>.</p>
</dd>
<dt id="term-path-compression">path compression<a class="headerlink" href="#term-path-compression" title="Permalink to this term">¶</a></dt><dd><p>When implementing the <a class="reference internal" href="#term-UNION-FIND"><span class="xref std std-term">UNION/FIND</span></a> algorithm, path
compression is a local optimization step that can be performed
during the FIND step.
Once the root of the tree for the current object has been found,
the path to the root can be traced a second time, with all
objects in the tree made to point directly to the root.
This reduces the depth of the tree from typically
<span class="math notranslate nohighlight">\(\Theta(\log n)\)</span> to nearly constant.</p>
</dd>
<dt id="term-peripheral-storage">peripheral storage<a class="headerlink" href="#term-peripheral-storage" title="Permalink to this term">¶</a></dt><dd><p>Any storage device that is not part of the core processing
of the computer (that is, <a class="reference internal" href="#term-RAM"><span class="xref std std-term">RAM</span></a>).
A typical example is a <a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a>.</p>
</dd>
<dt id="term-permutation">permutation<a class="headerlink" href="#term-permutation" title="Permalink to this term">¶</a></dt><dd><p>A permutation of a sequence <span class="math notranslate nohighlight">\(\mathbf{S}\)</span>
is the <a class="reference internal" href="#term-element"><span class="xref std std-term">elements</span></a> of <span class="math notranslate nohighlight">\(\mathbf{S}\)</span> arranged
in some order.</p>
</dd>
<dt id="term-persistent">persistent<a class="headerlink" href="#term-persistent" title="Permalink to this term">¶</a></dt><dd><p>In the context of computer memory, this refers to a memory that
does not lose its stored information when the power is turned
off.</p>
</dd>
<dt id="term-physical-file">physical file<a class="headerlink" href="#term-physical-file" title="Permalink to this term">¶</a></dt><dd><p>The collection of sectors that comprise a file on a
<a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a>.
This is in contrast to the <a class="reference internal" href="#term-logical-file"><span class="xref std std-term">logical file</span></a>.</p>
</dd>
<dt id="term-physical-form">physical form<a class="headerlink" href="#term-physical-form" title="Permalink to this term">¶</a></dt><dd><p>The implementation of a data type as a data structure.
Contrast to the <a class="reference internal" href="#term-physical-form"><span class="xref std std-term">physical form</span></a> for the data type.</p>
</dd>
<dt id="term-Pigeonhole-Principle">Pigeonhole Principle<a class="headerlink" href="#term-Pigeonhole-Principle" title="Permalink to this term">¶</a></dt><dd><p>A commonly used lemma in Mathematics. A typical variant states:
When <span class="math notranslate nohighlight">\(n+1\)</span> objects are stored in <span class="math notranslate nohighlight">\(n\)</span> locations, at
least one of the locations must store two or more of the objects.</p>
</dd>
<dt id="term-pivot">pivot<a class="headerlink" href="#term-pivot" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-Quicksort"><span class="xref std std-term">Quicksort</span></a>, the value that is used to split the list
into sublists, one with lesser values than the pivot, the other
with greater values than the pivot.</p>
</dd>
<dt id="term-platter">platter<a class="headerlink" href="#term-platter" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a>, one of a series of flat disks that
comprise the storage space for the drive.
Typically, each surface (top and bottom) of each platter stores
data, and each surface has its own <a class="reference internal" href="#term-I-O-head"><span class="xref std std-term">I/O head</span></a>.</p>
</dd>
<dt id="term-point-quadtree">point quadtree<a class="headerlink" href="#term-point-quadtree" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-spatial-data-structure"><span class="xref std std-term">spatial data structure</span></a> for storing point data.
It is similar to a <a class="reference internal" href="#term-PR-quadtree"><span class="xref std std-term">PR quadtree</span></a> in that it (in two
dimensions) splits the world into four parts.
However, it splits using an <a class="reference internal" href="#term-object-space-decomposition"><span class="xref std std-term">object-space decomposition</span></a>.
That is, quadrant containing the point is split into four parts
at the point.
It is similar to the <a class="reference internal" href="#term-kd-tree"><span class="xref std std-term">kd tree</span></a> which splits alternately in
each dimension, except that it splits in all dimensions at once.</p>
</dd>
<dt id="term-point-region-quadtree">point-region quadtree<a class="headerlink" href="#term-point-region-quadtree" title="Permalink to this term">¶</a></dt><dd><p>Formal name for what is commonly referred to as a
<a class="reference internal" href="#term-PR-quadtree"><span class="xref std std-term">PR quadtree</span></a>.</p>
</dd>
<dt id="term-pointee">pointee<a class="headerlink" href="#term-pointee" title="Permalink to this term">¶</a></dt><dd><p>The term pointee refers to anything that is pointed to by a
<a class="reference internal" href="#term-pointer"><span class="xref std std-term">pointer</span></a> or <a class="reference internal" href="#term-reference"><span class="xref std std-term">reference</span></a>.</p>
</dd>
<dt id="term-pointer">pointer<a class="headerlink" href="#term-pointer" title="Permalink to this term">¶</a></dt><dd><p>A variable whose value is the <a class="reference internal" href="#term-address"><span class="xref std std-term">address</span></a> of another variable; a link.</p>
</dd>
<dt id="term-pointer-based-implementation-for-binary-tree-nodes">pointer-based implementation for binary tree nodes<a class="headerlink" href="#term-pointer-based-implementation-for-binary-tree-nodes" title="Permalink to this term">¶</a></dt><dd><p>A common way to implement <a class="reference internal" href="#term-binary-tree"><span class="xref std std-term">binary tree</span></a> <a class="reference internal" href="#term-node"><span class="xref std std-term">nodes</span></a>.
Each node stores a data value (or a <a class="reference internal" href="#term-reference"><span class="xref std std-term">reference</span></a> to a data
value), and pointers to the left and right children.
If either or both of the children does not exist, then a null
pointer is stored.</p>
</dd>
<dt id="term-polymorphism">polymorphism<a class="headerlink" href="#term-polymorphism" title="Permalink to this term">¶</a></dt><dd><p>An <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming</span></a>
term meaning <em>one name, many forms</em>.
It describes the ability of software to change its behavior
dynamically.  Two basic forms exist:
<a class="reference internal" href="#term-run-time-polymorphism"><span class="xref std std-term">run-time polymorphism</span></a> and <a class="reference internal" href="#term-compile-time-polymorphism"><span class="xref std std-term">compile-time polymorphism</span></a>.</p>
</dd>
<dt id="term-pop">pop<a class="headerlink" href="#term-pop" title="Permalink to this term">¶</a></dt><dd><p>A specialized term used to indicate removing an <a class="reference internal" href="#term-element"><span class="xref std std-term">element</span></a>
from a <a class="reference internal" href="#term-stack"><span class="xref std std-term">stack</span></a>.</p>
</dd>
<dt id="term-poset">poset<a class="headerlink" href="#term-poset" title="Permalink to this term">¶</a></dt><dd><p>Another name for a <a class="reference internal" href="#term-partially-ordered-set"><span class="xref std std-term">partially ordered set</span></a>.</p>
</dd>
<dt id="term-position">position<a class="headerlink" href="#term-position" title="Permalink to this term">¶</a></dt><dd><p>The defining property of the list ADT, this is the concept that
list elements are in a position. Many list ADTs support access
by position.</p>
</dd>
<dt id="term-postorder-traversal">postorder traversal<a class="headerlink" href="#term-postorder-traversal" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-binary-tree"><span class="xref std std-term">binary tree</span></a>, a <a class="reference internal" href="#term-traversal"><span class="xref std std-term">traversal</span></a> that first
<a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursively</span></a> <a class="reference internal" href="#term-visit"><span class="xref std std-term">visits</span></a> the left
<a class="reference internal" href="#term-child"><span class="xref std std-term">child</span></a>,
then recursively visits the right child, and then visits the
<a class="reference internal" href="#term-root"><span class="xref std std-term">root</span></a>.</p>
</dd>
<dt id="term-potential">potential<a class="headerlink" href="#term-potential" title="Permalink to this term">¶</a></dt><dd><p>A concept related to <a class="reference internal" href="#term-amortized-analysis"><span class="xref std std-term">amortized analysis</span></a>.
Potential is the total or currently available amount of work
that can be done.</p>
</dd>
<dt id="term-powerset">powerset<a class="headerlink" href="#term-powerset" title="Permalink to this term">¶</a></dt><dd><p>For a <a class="reference internal" href="#term-set"><span class="xref std std-term">set</span></a> <span class="math notranslate nohighlight">\(\mathbf{S}\)</span>, the power set is the set
of all possible <a class="reference internal" href="#term-subset"><span class="xref std std-term">subsets</span></a> for <span class="math notranslate nohighlight">\(\mathbf{S}\)</span>.</p>
</dd>
<dt id="term-PR-quadtree">PR quadtree<a class="headerlink" href="#term-PR-quadtree" title="Permalink to this term">¶</a></dt><dd><p>A type of <a class="reference internal" href="#term-quadtree"><span class="xref std std-term">quadtree</span></a> that stores point data in two
dimensions.
The root of the PR quadtree represents some square region of 2d
space.
If that space stores more than one data point, then the region
is decomposed into four equal subquadrants, each represented
<a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursively</span></a> by a subtree of the PR quadtree.
Since many leaf nodes of the PR quadtree will contain no data
points, implementation often makes use of the <a class="reference internal" href="#term-flyweight"><span class="xref std std-term">Flyweight</span></a>
<a class="reference internal" href="#term-design-pattern"><span class="xref std std-term">design pattern</span></a>.
Related to the <a class="reference internal" href="#term-bintree"><span class="xref std std-term">bintree</span></a>.</p>
</dd>
<dt id="term-prefix-property">prefix property<a class="headerlink" href="#term-prefix-property" title="Permalink to this term">¶</a></dt><dd><p>Given a collection of strings, the collection has the prefix
property if no string in the collection is a prefix for another
string in the collection.
The significance is that, given a long string composed of
members of the collection, it can be uniquely decomposed into
the constituent members.
An example of such a collection of strings with the prefix
property is a set of <a class="reference internal" href="#term-Huffman-codes"><span class="xref std std-term">Huffman codes</span></a>.</p>
</dd>
<dt id="term-preorder-traversal">preorder traversal<a class="headerlink" href="#term-preorder-traversal" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-binary-tree"><span class="xref std std-term">binary tree</span></a>, a <a class="reference internal" href="#term-traversal"><span class="xref std std-term">traversal</span></a> that first
<a class="reference internal" href="#term-visit"><span class="xref std std-term">visits</span></a> the <a class="reference internal" href="#term-root"><span class="xref std std-term">root</span></a>, then
<a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursively</span></a> visits the left <a class="reference internal" href="#term-child"><span class="xref std std-term">child</span></a>,
then recursively visits the right child.</p>
</dd>
<dt id="term-Prim-s-algorithm">Prim’s algorithm<a class="headerlink" href="#term-Prim-s-algorithm" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-greedy-algorithm"><span class="xref std std-term">greedy algorithm</span></a> for computing the <a class="reference internal" href="#term-MCST"><span class="xref std std-term">MCST</span></a> of a
<a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a>.
It is nearly identical to <a class="reference internal" href="#term-Dijkstra-s-algorithm"><span class="xref std std-term">Dijkstra’s algorithm</span></a> for
solving the <a class="reference internal" href="#term-single-source-shortest-paths-problem"><span class="xref std std-term">single-source shortest paths problem</span></a>,
with the only difference being the calculation done to update
the best-known distance.</p>
</dd>
<dt id="term-primary-clustering">primary clustering<a class="headerlink" href="#term-primary-clustering" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, the tendency in certain
<a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a>
methods to create clustering in sections of the hash table.
The classic example is <a class="reference internal" href="#term-linear-probing"><span class="xref std std-term">linear probing</span></a>.
This tends to happen when a group of keys follow the same
<a class="reference internal" href="#term-probe-sequence"><span class="xref std std-term">probe sequence</span></a> during collision resolution.</p>
</dd>
<dt id="term-primary-index">primary index<a class="headerlink" href="#term-primary-index" title="Permalink to this term">¶</a></dt><dd><p>Synonym for <a class="reference internal" href="#term-primary-key-index"><span class="xref std std-term">primary key index</span></a>.</p>
</dd>
<dt id="term-primary-key">primary key<a class="headerlink" href="#term-primary-key" title="Permalink to this term">¶</a></dt><dd><p>A unique identifier for a <a class="reference internal" href="#term-record"><span class="xref std std-term">record</span></a>.</p>
</dd>
<dt id="term-primary-key-index">primary key index<a class="headerlink" href="#term-primary-key-index" title="Permalink to this term">¶</a></dt><dd><p>Relates each <a class="reference internal" href="#term-primary-key"><span class="xref std std-term">primary key</span></a> value with a pointer to the
actual record on disk.</p>
</dd>
<dt id="term-primary-storage">primary storage<a class="headerlink" href="#term-primary-storage" title="Permalink to this term">¶</a></dt><dd><p>The faster but more expensive memory in a computer, most often
<a class="reference internal" href="#term-RAM"><span class="xref std std-term">RAM</span></a> in modern computers.
This is in contrast to <a class="reference internal" href="#term-secondary-storage"><span class="xref std std-term">secondary storage</span></a>, which together
with primary storage devices make up the computer’s
<a class="reference internal" href="#term-memory-hierarchy"><span class="xref std std-term">memory hierarchy</span></a>.</p>
</dd>
<dt id="term-primitive-data-type">primitive data type<a class="headerlink" href="#term-primitive-data-type" title="Permalink to this term">¶</a></dt><dd><p>In Java, one of a particular group of
<a class="reference internal" href="#term-simple-type"><span class="xref std std-term">simple types</span></a> that are not implemented as
objects.
An example is an <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
</dd>
<dt id="term-primitive-element">primitive element<a class="headerlink" href="#term-primitive-element" title="Permalink to this term">¶</a></dt><dd><p>In set notation, this is a single element that is a member of
the base type for the set. This is as opposed to an element of
the set being another set.</p>
</dd>
<dt id="term-primitive-nth-root-of-unity">primitive nth root of unity<a class="headerlink" href="#term-primitive-nth-root-of-unity" title="Permalink to this term">¶</a></dt><dd><p>The <span class="math notranslate nohighlight">\(n\)</span> th root of 1. Normally a <a class="reference internal" href="#term-complex-number"><span class="xref std std-term">complex number</span></a>.
An intuitive way to view this is one <span class="math notranslate nohighlight">\(n\)</span> th of the unit
circle in the complex plain.</p>
</dd>
<dt id="term-priority">priority<a class="headerlink" href="#term-priority" title="Permalink to this term">¶</a></dt><dd><p>A quantity assigned to each of a collection of
<a class="reference internal" href="#term-job"><span class="xref std std-term">jobs</span></a> or tasks that indicate importance for order
of processing.
For example, in an operating system, there could be a collection
of processes (jobs) ready to run.
The operating system must select the next task to execute,
based on their priorities.</p>
</dd>
<dt id="term-priority-queue">priority queue<a class="headerlink" href="#term-priority-queue" title="Permalink to this term">¶</a></dt><dd><p>An ADT whose primary operations of insert of records, and
deletion of the greatest (or, in an alternative implementation,
the least) valued record.
Most often implemented using the <a class="reference internal" href="#term-heap"><span class="xref std std-term">heap</span></a> data structure.
The name comes from a common application where the records being
stored represent tasks, with the ordering values based on the
<a class="reference internal" href="#term-priority"><span class="xref std std-term">priorities</span></a> of the tasks.</p>
</dd>
<dt id="term-probabilistic-algorithm">probabilistic algorithm<a class="headerlink" href="#term-probabilistic-algorithm" title="Permalink to this term">¶</a></dt><dd><p>A form of <a class="reference internal" href="#term-randomized-algorithm"><span class="xref std std-term">randomized algorithm</span></a> that might yield an
incorrect result, or that might fail to produce a result.</p>
</dd>
<dt id="term-probabilistic-data-structure">probabilistic data structure<a class="headerlink" href="#term-probabilistic-data-structure" title="Permalink to this term">¶</a></dt><dd><p>Any data structure that uses
<a class="reference internal" href="#term-probabilistic-algorithm"><span class="xref std std-term">probabilistic algorithms</span></a> to
perform its operations.
A good example is the <a class="reference internal" href="#term-skip-list"><span class="xref std std-term">skip list</span></a>.</p>
</dd>
<dt id="term-probe-function">probe function<a class="headerlink" href="#term-probe-function" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, the function used by a
<a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a> method to calculate where to look
next in the <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>.</p>
</dd>
<dt id="term-probe-sequence">probe sequence<a class="headerlink" href="#term-probe-sequence" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, the series of <a class="reference internal" href="#term-slot"><span class="xref std std-term">slots</span></a> visited
by the <a class="reference internal" href="#term-probe-function"><span class="xref std std-term">probe function</span></a> during
<a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a>.</p>
</dd>
<dt id="term-problem">problem<a class="headerlink" href="#term-problem" title="Permalink to this term">¶</a></dt><dd><p>A task to be performed.
It is best thought of as a <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a> or a mapping of
inputs to outputs.</p>
</dd>
<dt id="term-problem-instance">problem instance<a class="headerlink" href="#term-problem-instance" title="Permalink to this term">¶</a></dt><dd><p>A specific selection of values for the parameters to a problem.
In other words, a specific set of inputs to a problem.
A given problem instance has a size under some
<a class="reference internal" href="#term-cost-model"><span class="xref std std-term">cost model</span></a>.</p>
</dd>
<dt id="term-problem-lower-bound">problem lower bound<a class="headerlink" href="#term-problem-lower-bound" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-algorithm-analysis"><span class="xref std std-term">algorithm analysis</span></a>, the tightest <a class="reference internal" href="#term-lower-bound"><span class="xref std std-term">lower bound</span></a>
that we can prove over all <a class="reference internal" href="#term-algorithm"><span class="xref std std-term">algorithms</span></a>
for that <a class="reference internal" href="#term-problem"><span class="xref std std-term">problem</span></a>.
This is often much harder to determine than the
<a class="reference internal" href="#term-problem-upper-bound"><span class="xref std std-term">problem upper bound</span></a>.
Since the lower bound for the algorithm can be very different
for different situations (such as the <a class="reference internal" href="#term-best-case"><span class="xref std std-term">best case</span></a> or
<a class="reference internal" href="#term-worst-case"><span class="xref std std-term">worst case</span></a>), we typically have to specify which
situation we are referring to.</p>
</dd>
<dt id="term-problem-upper-bound">problem upper bound<a class="headerlink" href="#term-problem-upper-bound" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-algorithm-analysis"><span class="xref std std-term">algorithm analysis</span></a>, the <a class="reference internal" href="#term-upper-bound"><span class="xref std std-term">upper bound</span></a> for the
best <a class="reference internal" href="#term-algorithm"><span class="xref std std-term">algorithm</span></a> that we know for the <a class="reference internal" href="#term-problem"><span class="xref std std-term">problem</span></a>.
Since the upper bound for the algorithm can be very different
for different situations (such as the <a class="reference internal" href="#term-best-case"><span class="xref std std-term">best case</span></a> or
<a class="reference internal" href="#term-worst-case"><span class="xref std std-term">worst case</span></a>), we typically have to specify which
situation we are referring to.</p>
</dd>
<dt id="term-procedural">procedural<a class="headerlink" href="#term-procedural" title="Permalink to this term">¶</a></dt><dd><p>Typically referring to the
<a class="reference internal" href="#term-procedural-programming-paradigm"><span class="xref std std-term">procedural programming paradigm</span></a>, in contrast to the
<a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming paradigm</span></a>.</p>
</dd>
<dt id="term-procedural-programming-paradigm">procedural programming paradigm<a class="headerlink" href="#term-procedural-programming-paradigm" title="Permalink to this term">¶</a></dt><dd><p>Procedural programming uses a list of instructions (and
procedure calls) that define a series of computational steps to
be carried out.
This is in contrast to the
<a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming paradigm</span></a>.</p>
</dd>
<dt id="term-production">production<a class="headerlink" href="#term-production" title="Permalink to this term">¶</a></dt><dt id="term-production-rule">production rule<a class="headerlink" href="#term-production-rule" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-grammar"><span class="xref std std-term">grammar</span></a> is comprised of production rules.
The production rules consist of <a class="reference internal" href="#term-terminal"><span class="xref std std-term">terminals</span></a> and
<a class="reference internal" href="#term-non-terminal"><span class="xref std std-term">non-terminals</span></a>, with one of the non-terminals
being the <a class="reference internal" href="#term-start-symbol"><span class="xref std std-term">start symbol</span></a>.
Each production rule replaces one or more non-terminals (perhaps
with associated terminals) with one or more terminals and
non-terminals.
Depending on the restrictions placed on the form of the rules,
there are classes of languages that can be represented by
specific types of grammars.
A <a class="reference internal" href="#term-derivation"><span class="xref std std-term">derivation</span></a> is a series of productions that results in
a string (that is, all non-terminals), and this derivation can
be represented as a <a class="reference internal" href="#term-parse-tree"><span class="xref std std-term">parse tree</span></a>.</p>
</dd>
<dt id="term-program">program<a class="headerlink" href="#term-program" title="Permalink to this term">¶</a></dt><dd><p>An instance, or concrete representation, of an algorithm in some
programming language.</p>
</dd>
<dt id="term-promotion">promotion<a class="headerlink" href="#term-promotion" title="Permalink to this term">¶</a></dt><dd><p>In the context of certain <a class="reference internal" href="#term-balanced-tree"><span class="xref std std-term">balanced tree</span></a> structures such
as the <a class="reference internal" href="#term-2-3-tree"><span class="xref std std-term">2-3 tree</span></a>, a promotion takes place when an
insertion causes the node to <a class="reference internal" href="#term-overflow"><span class="xref std std-term">overflow</span></a>.
In the case of the 2-3 tree, the <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> with the middlemost
value is sent to be stored in the parent.</p>
</dd>
<dt id="term-proof">proof<a class="headerlink" href="#term-proof" title="Permalink to this term">¶</a></dt><dd><p>The establishment of the truth of anything, a demonstration.</p>
</dd>
<dt id="term-proof-by-contradiction">proof by contradiction<a class="headerlink" href="#term-proof-by-contradiction" title="Permalink to this term">¶</a></dt><dd><p>A mathematical proof technique that proves a theorem by first
assuming that the theorem is false, and then uses a chain of
reasoning to reach a logical contradiction.
Since when the theorem is false a logical contradiction arises,
the conclusion is that the theorem must be true.</p>
</dd>
<dt id="term-proof-by-induction">proof by induction<a class="headerlink" href="#term-proof-by-induction" title="Permalink to this term">¶</a></dt><dd><p>A mathematical proof technique similar to <a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursion</span></a>.
It is used to prove a parameterized theorem $S(n)$, that is,
a theorem where there is a <a class="reference internal" href="#term-induction-variable"><span class="xref std std-term">induction variable</span></a> involved
(such as the sum of the numbers from 1 to $n$).
One first proves that the theorem holds true for a
<a class="reference internal" href="#term-base-case"><span class="xref std std-term">base case</span></a>, then one proves the implication that
whenever $S(n)$ is true then $S(n+1)$ is also true.
Another variation is <a class="reference internal" href="#term-strong-induction"><span class="xref std std-term">strong induction</span></a>.</p>
</dd>
<dt id="term-proving-the-contrapositive">proving the contrapositive<a class="headerlink" href="#term-proving-the-contrapositive" title="Permalink to this term">¶</a></dt><dd><p>We can prove that <span class="math notranslate nohighlight">\(P \Rightarrow Q\)</span> by proving
<span class="math notranslate nohighlight">\((\mathrm{not}\ Q) \Rightarrow (\mathrm{not}\ P)\)</span>.</p>
</dd>
<dt id="term-pseudo-polynomial">pseudo polynomial<a class="headerlink" href="#term-pseudo-polynomial" title="Permalink to this term">¶</a></dt><dd><p>In complexity analysis, refers to the time requirements of an
algorithm for an <a class="reference internal" href="#term-NP-Complete"><span class="xref std std-term">NP-Complete</span></a> problem that still runs
acceptably fast for practical application.
An example is the standard <a class="reference internal" href="#term-dynamic-programming"><span class="xref std std-term">dynamic programming</span></a> algorithm
for the <a class="reference internal" href="#term-knapsack-problem"><span class="xref std std-term">knapsack problem</span></a>.</p>
</dd>
<dt id="term-pseudo-random">pseudo random<a class="headerlink" href="#term-pseudo-random" title="Permalink to this term">¶</a></dt><dd><p>In random number theory this means that, given all past terms in
the series, no future term of the series can be accurately
predicted in polynomial time.</p>
</dd>
<dt id="term-pseudo-random-probing">pseudo-random probing<a class="headerlink" href="#term-pseudo-random-probing" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, this is a <a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a>
method that stores a random permutation of the values 1 through
the size of the <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>.
Term <span class="math notranslate nohighlight">\(i\)</span> of the <a class="reference internal" href="#term-probe-sequence"><span class="xref std std-term">probe sequence</span></a> is simply the value
of position <span class="math notranslate nohighlight">\(i\)</span> in the permuation.</p>
</dd>
<dt id="term-push">push<a class="headerlink" href="#term-push" title="Permalink to this term">¶</a></dt><dd><p>A specialized term used to indicate inserting an <a class="reference internal" href="#term-element"><span class="xref std std-term">element</span></a>
onto a <a class="reference internal" href="#term-stack"><span class="xref std std-term">stack</span></a>.</p>
</dd>
<dt id="term-pushdown-automata">pushdown automata<a class="headerlink" href="#term-pushdown-automata" title="Permalink to this term">¶</a></dt><dt id="term-PDA">PDA<a class="headerlink" href="#term-PDA" title="Permalink to this term">¶</a></dt><dd><p>A type of <a class="reference internal" href="#term-Finite-State-Automata"><span class="xref std std-term">Finite State Automata</span></a> that adds a stack memory
to the basic <a class="reference internal" href="#term-Deterministic-Finite-Automata"><span class="xref std std-term">Deterministic Finite Automata</span></a> machine.
This extends the set of languages that can be recognize to the
<a class="reference internal" href="#term-context-free-language"><span class="xref std std-term">context-free languages</span></a>.</p>
</dd>
<dt id="term-quadratic-growth-rate">quadratic growth rate<a class="headerlink" href="#term-quadratic-growth-rate" title="Permalink to this term">¶</a></dt><dd><p>A growth rate function of the form <span class="math notranslate nohighlight">\(cn^2\)</span> where <span class="math notranslate nohighlight">\(n\)</span>
is the input size and <span class="math notranslate nohighlight">\(c\)</span> is a constant.</p>
</dd>
<dt id="term-quadratic-probing">quadratic probing<a class="headerlink" href="#term-quadratic-probing" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, this is a <a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a>
method that computes term <span class="math notranslate nohighlight">\(i\)</span> of the
<a class="reference internal" href="#term-probe-sequence"><span class="xref std std-term">probe sequence</span></a> using some quadratic equation
<span class="math notranslate nohighlight">\(ai^2 _ bi + c\)</span> for suitable constants <span class="math notranslate nohighlight">\(a, b, c\)</span>.
The simplest form is simply to use <span class="math notranslate nohighlight">\(i^2\)</span> as term <span class="math notranslate nohighlight">\(i\)</span>
of the probe sequence.</p>
</dd>
<dt id="term-quadtree">quadtree<a class="headerlink" href="#term-quadtree" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-full-tree"><span class="xref std std-term">full tree</span></a> where each internal node has four children.
Most typically used to store two dimensional
<a class="reference internal" href="#term-spatial-data"><span class="xref std std-term">spatial data</span></a>.
Related to the <a class="reference internal" href="#term-bintree"><span class="xref std std-term">bintree</span></a>.
The difference is that the quadtree splits all dimensions
simultaneously, while the bintree splits one dimension at each
level.
Thus, to extend the quadtree concept to more dimensions requires
a rapid increase in the number of splits (for example, 8 in
three dimensions).</p>
</dd>
<dt id="term-queue">queue<a class="headerlink" href="#term-queue" title="Permalink to this term">¶</a></dt><dd><p>A list-like structure in which elements are inserted only at one
end, and removed only from the other one end.</p>
</dd>
<dt id="term-Quicksort">Quicksort<a class="headerlink" href="#term-Quicksort" title="Permalink to this term">¶</a></dt><dd><p>A sort that is <span class="math notranslate nohighlight">\(\Theta(n \log n)\)</span> in the
<a class="reference internal" href="#term-best-case"><span class="xref std std-term">best</span></a> and <a class="reference internal" href="#term-average-case"><span class="xref std std-term">average</span></a>
cases, though <span class="math notranslate nohighlight">\(\Theta(n^2)\)</span> in the <a class="reference internal" href="#term-worst-case"><span class="xref std std-term">worst case</span></a>.
However, a reasonable implmentation will make the worst case
occur under exceedingly rare circumstances.
Due to its tight inner loop, it tends to run better than any
other known sort in general cases.
Thus, it is a popular sort to use in code libraries.
It works by divide and conquer, by selecting a <a class="reference internal" href="#term-pivot"><span class="xref std std-term">pivot</span></a>
value,
splitting the list into parts that are either less than or
greater than the pivot, and then sorting the two parts.</p>
</dd>
<dt id="term-radix">radix<a class="headerlink" href="#term-radix" title="Permalink to this term">¶</a></dt><dd><p>Synonym for <a class="reference internal" href="#term-base"><span class="xref std std-term">base</span></a>. The number of digits in a number
representation. For example, we typically represent numbers in
base (or radix) 10. Hexidecimal is base (or radix) 16.</p>
</dd>
<dt id="term-radix-sort">radix sort<a class="headerlink" href="#term-radix-sort" title="Permalink to this term">¶</a></dt><dd><p>A sorting algorithm that works by processing records with
<span class="math notranslate nohighlight">\(k\)</span> digit keys in <span class="math notranslate nohighlight">\(k\)</span> passes, where each pass sorts
the records according to the current digit. At the end of the
process, the records will be sorted. This can be efficient if
the number of digits is small compared to the number of
records. However, if the <span class="math notranslate nohighlight">\(n\)</span> records all have unique key
values, than at least <span class="math notranslate nohighlight">\(\Omega(\log n)\)</span> digits are required,
leading to an <span class="math notranslate nohighlight">\(\Omega(n \log n)\)</span> sorting algorithm that
tends to be much slower than other sorting algorithms like
<a class="reference internal" href="#term-Quicksort"><span class="xref std std-term">Quicksort</span></a> or <a class="reference internal" href="#term-Mergesort"><span class="xref std std-term">mergesort</span></a>.</p>
</dd>
<dt id="term-RAM">RAM<a class="headerlink" href="#term-RAM" title="Permalink to this term">¶</a></dt><dd><p>Abbreviation for <a class="reference internal" href="#term-random-access-memory"><span class="xref std std-term">Random Access Memory</span></a>.</p>
</dd>
<dt id="term-random-access">random access<a class="headerlink" href="#term-random-access" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-file-processing"><span class="xref std std-term">file processing</span></a> terminology, a <a class="reference internal" href="#term-disk-access"><span class="xref std std-term">disk access</span></a> to
a random position within the file.
More generally, the ability to access an arbitrary record in the
file.</p>
</dd>
<dt id="term-random-access-memory">random access memory<a class="headerlink" href="#term-random-access-memory" title="Permalink to this term">¶</a></dt><dd><p>Abbreviated <a class="reference internal" href="#term-RAM"><span class="xref std std-term">RAM</span></a>, this is the principle example of
<a class="reference internal" href="#term-primary-storage"><span class="xref std std-term">primary storage</span></a> in a modern computer.
Data access times are typically measured in billionths of a
second (microseconds), which is roughly a million times faster
than data access from a disk drive.
RAM is where data are held for immediate processing, since
access times are so much faster than for
<a class="reference internal" href="#term-secondary-storage"><span class="xref std std-term">secondary storage</span></a>.
RAM is a typical part of a computer’s <a class="reference internal" href="#term-memory-hierarchy"><span class="xref std std-term">memory hierarchy</span></a>.</p>
</dd>
<dt id="term-random-permutation">random permutation<a class="headerlink" href="#term-random-permutation" title="Permalink to this term">¶</a></dt><dd><p>One of the <span class="math notranslate nohighlight">\(n!\)</span> possible permutations for a set of
<span class="math notranslate nohighlight">\(n\)</span> element is selected in such a way that each
permutation has equal probability of being selected.</p>
</dd>
<dt id="term-randomized-algorithm">randomized algorithm<a class="headerlink" href="#term-randomized-algorithm" title="Permalink to this term">¶</a></dt><dd><p>An algorithm that involves some form of randomness to control
its behavior.
The ultimate goal of a randomized algorithm is to improve
performance over a deterministic algorithm to solve the same
problem.
There are a number of variations on this theme.
A “Las Vegas algorithm” returns a correct result,
but the amount of time required might or might not improve over
a <a class="reference internal" href="#term-deterministic-algorithm"><span class="xref std std-term">deterministic algorithm</span></a>.
A “Monte Carlo algorithm” is a form of
<a class="reference internal" href="#term-probabilistic-algorithm"><span class="xref std std-term">probabilistic algorithm</span></a> that is not guarenteed to return
a correct result, but will return a result relatively quickly.</p>
</dd>
<dt id="term-range">range<a class="headerlink" href="#term-range" title="Permalink to this term">¶</a></dt><dd><p>The set of possible outputs for a function.</p>
</dd>
<dt id="term-range-query">range query<a class="headerlink" href="#term-range-query" title="Permalink to this term">¶</a></dt><dd><p>Records are returned if their relevant key value falls with a
specified range.</p>
</dd>
<dt id="term-read-write-head">read/write head<a class="headerlink" href="#term-read-write-head" title="Permalink to this term">¶</a></dt><dd><p>Synonym for <a class="reference internal" href="#term-I-O-head"><span class="xref std std-term">I/O head</span></a>.</p>
</dd>
<dt id="term-rebalancing-operation">rebalancing operation<a class="headerlink" href="#term-rebalancing-operation" title="Permalink to this term">¶</a></dt><dd><p>An operation performed on balanced search trees, such as the
<a class="reference internal" href="#term-AVL-Tree"><span class="xref std std-term">AVL Tree</span></a> or <a class="reference internal" href="#term-Splay-Tree"><span class="xref std std-term">Splay Tree</span></a>, for the purpose of
keeping the tree <a class="reference internal" href="#term-height-balanced"><span class="xref std std-term">height balanced</span></a>.</p>
</dd>
<dt id="term-recognize">recognize<a class="headerlink" href="#term-recognize" title="Permalink to this term">¶</a></dt><dd><p>In the study of formal languages, the ability to reliably
determine whether some string is in a given language or not.</p>
</dd>
<dt id="term-record">record<a class="headerlink" href="#term-record" title="Permalink to this term">¶</a></dt><dd><p>A collection of information, typically implemented as an
<a class="reference internal" href="#term-object"><span class="xref std std-term">object</span></a> in an
<a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming language</span></a>.
Many data structures are organized containers for a collection
of records.</p>
</dd>
<dt id="term-recurrence-relation">recurrence relation<a class="headerlink" href="#term-recurrence-relation" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-recurrence-relation"><span class="xref std std-term">recurrence relation</span></a> (or less formally,
recurrence) defines a function by means of an
expression that includes one or more (smaller) instances of
itself.
A classic example is the <a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursive</span></a>
definition for the
factorial function, <span class="math notranslate nohighlight">\(F(n) = n*F(n-1)\)</span>.</p>
</dd>
<dt id="term-recurrence-with-full-history">recurrence with full history<a class="headerlink" href="#term-recurrence-with-full-history" title="Permalink to this term">¶</a></dt><dd><p>A special form of <a class="reference internal" href="#term-recurrence-relation"><span class="xref std std-term">recurrence relation</span></a> that includes a
summation with a copy of the recurrence inside.
The recurrence that represents the average case cost for
<a class="reference internal" href="#term-Quicksort"><span class="xref std std-term">Quicksort</span></a> is an example.
This internal summation can typically be removed with simple
techniques to simplify solving the recurrence.</p>
</dd>
<dt id="term-recursion">recursion<a class="headerlink" href="#term-recursion" title="Permalink to this term">¶</a></dt><dd><p>The process of using recursive calls.
An algorithm is recursive if it calls itself to do part of
its work.
See <a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursion</span></a>.</p>
</dd>
<dt id="term-recursive-call">recursive call<a class="headerlink" href="#term-recursive-call" title="Permalink to this term">¶</a></dt><dd><p>Within a <a class="reference internal" href="#term-recursive-function"><span class="xref std std-term">recursive function</span></a>, it is a call that the
function makes to itself.</p>
</dd>
<dt id="term-recursive-data-structure">recursive data structure<a class="headerlink" href="#term-recursive-data-structure" title="Permalink to this term">¶</a></dt><dd><p>A data structure that is partially
composed of smaller or simpler instances of the same data structure.
For example, <a class="reference internal" href="#term-linked-list"><span class="xref std std-term">linked lists</span></a> and
<a class="reference internal" href="#term-binary-tree"><span class="xref std std-term">binary trees</span></a> can be viewed as recursive
data structures.</p>
</dd>
<dt id="term-recursive-function">recursive function<a class="headerlink" href="#term-recursive-function" title="Permalink to this term">¶</a></dt><dd><p>A function that includes a <a class="reference internal" href="#term-recursive-call"><span class="xref std std-term">recursive call</span></a>.</p>
</dd>
<dt id="term-recursively-enumerable">recursively enumerable<a class="headerlink" href="#term-recursively-enumerable" title="Permalink to this term">¶</a></dt><dd><p>A language <span class="math notranslate nohighlight">\(L\)</span> is recursively enumerable
if there exists a <a class="reference internal" href="#term-Turing-machine"><span class="xref std std-term">Turing machine</span></a> <span class="math notranslate nohighlight">\(M\)</span> such that
<span class="math notranslate nohighlight">\(L = L(M)\)</span>.</p>
</dd>
<dt id="term-Red-Black-Tree">Red-Black Tree<a class="headerlink" href="#term-Red-Black-Tree" title="Permalink to this term">¶</a></dt><dd><p>A balanced variation on a <a class="reference internal" href="#term-BST"><span class="xref std std-term">BST</span></a>.</p>
</dd>
<dt id="term-reduction">reduction<a class="headerlink" href="#term-reduction" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-algorithm-analysis"><span class="xref std std-term">algorithm analysis</span></a>, the process of deriving
<a class="reference internal" href="#term-asymptotic-analysis"><span class="xref std std-term">asymptotic bounds</span></a>
for one <a class="reference internal" href="#term-problem"><span class="xref std std-term">problem</span></a> from the asymptotic bounds of another.
In particular, if problem A can be used to solve problem B, and
problem A is proved to be in <span class="math notranslate nohighlight">\(O(f(n))\)</span>, then problem B
must also be in <span class="math notranslate nohighlight">\(O(f(n))\)</span>.
Reductions are often used to show that certain problems are at
least as expensive as sorting, or that certain problems are
<a class="reference internal" href="#term-NP-Complete"><span class="xref std std-term">NP-Complete</span></a>.</p>
</dd>
<dt id="term-reference">reference<a class="headerlink" href="#term-reference" title="Permalink to this term">¶</a></dt><dd><p>A value that enables a program to directly access some
particular <a class="reference internal" href="#term-data-item"><span class="xref std std-term">data item</span></a>.
An example might be a byte position within a file where the
record is stored, or a pointer to a record in memory.
(Note that Java makes a distinction between a reference and the
concept of a pointer, since it does not define a reference to
necessarily be a byte position in memory.)</p>
</dd>
<dt id="term-reference-count-algorithm">reference count algorithm<a class="headerlink" href="#term-reference-count-algorithm" title="Permalink to this term">¶</a></dt><dd><p>An algorithm for <a class="reference internal" href="#term-garbage-collection"><span class="xref std std-term">garbage collection</span></a>.
Whenever a reference is made from a variable to some memory
location, a counter associated with that memory location is
incremented.
Whenever the reference is changed or deleted, the reference
count is decremented.
If this count goes to zero, then the memory is considered free
for reuse.
This approach can fail if there is a cycle in the chain of
references.</p>
</dd>
<dt id="term-reference-parameter">reference parameter<a class="headerlink" href="#term-reference-parameter" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-parameter"><span class="xref std std-term">parameter</span></a> that has been
<a class="reference internal" href="#term-pass-by-reference"><span class="xref std std-term">passed by reference</span></a>.
Such a parameter can be modified inside the function or method.</p>
</dd>
<dt id="term-reflexive">reflexive<a class="headerlink" href="#term-reflexive" title="Permalink to this term">¶</a></dt><dd><p>In set notation, binary relation <span class="math notranslate nohighlight">\(R\)</span> on set <span class="math notranslate nohighlight">\(S\)</span> is
reflexive if <span class="math notranslate nohighlight">\(aRa\)</span> for all <span class="math notranslate nohighlight">\(a \in \mathbf{S}\)</span>.</p>
</dd>
<dt id="term-Region-Quadtree">Region Quadtree<a class="headerlink" href="#term-Region-Quadtree" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-spatial-data-structure"><span class="xref std std-term">spatial data structure</span></a> for storing 2D pixel data. The
idea is that the root of the tree represents the entire image,
and it is recursively divided into four equal subquadrants
if not all pixels associated with the current node have the
same value. This is structurally equivalent to a
<a class="reference internal" href="#term-PR-quadtree"><span class="xref std std-term">PR quadtree</span></a>, only the decomposition rule is changed.</p>
</dd>
<dt id="term-regular-expression">regular expression<a class="headerlink" href="#term-regular-expression" title="Permalink to this term">¶</a></dt><dd><p>A way to specify a set of strings that define a language using
the operators of union, contatenation, and star-closure.
A regular expression defines some <a class="reference internal" href="#term-regular-language"><span class="xref std std-term">regular language</span></a>.</p>
</dd>
<dt id="term-regular-grammar">regular grammar<a class="headerlink" href="#term-regular-grammar" title="Permalink to this term">¶</a></dt><dd><p>And grammar that is either right-regular or left-regular.
Every regular grammar describes a regular language.</p>
</dd>
<dt id="term-regular-language">regular language<a class="headerlink" href="#term-regular-language" title="Permalink to this term">¶</a></dt><dd><p>A language <span class="math notranslate nohighlight">\(L\)</span> is a regular language if and only if
there exists a <a class="reference internal" href="#term-Deterministic-Finite-Automata"><span class="xref std std-term">Deterministic Finite Automata</span></a> <span class="math notranslate nohighlight">\(M\)</span>
such that <span class="math notranslate nohighlight">\(L = L(M)\)</span>.</p>
</dd>
<dt id="term-relation">relation<a class="headerlink" href="#term-relation" title="Permalink to this term">¶</a></dt><dd><p>In set notation, a relation <span class="math notranslate nohighlight">\(R\)</span> over set
<span class="math notranslate nohighlight">\(\mathbf{S}\)</span> is a set of <a class="reference internal" href="#term-tuple"><span class="xref std std-term">tuples</span></a> from
<span class="math notranslate nohighlight">\(\mathbf{S}\)</span>.</p>
</dd>
<dt id="term-replacement-selection">replacement selection<a class="headerlink" href="#term-replacement-selection" title="Permalink to this term">¶</a></dt><dd><p>A variant of <a class="reference internal" href="#term-heapsort"><span class="xref std std-term">heapsort</span></a> most often used as one phase of an
<a class="reference internal" href="#term-external-sort"><span class="xref std std-term">external sort</span></a>.
Given a collection of records stored in an <a class="reference internal" href="#term-array"><span class="xref std std-term">array</span></a>, and a stream
of additional records too large to fit into
<a class="reference internal" href="#term-working-memory"><span class="xref std std-term">working memory</span></a>, replacement selection will unload the
<a class="reference internal" href="#term-heap"><span class="xref std std-term">heap</span></a> by sending records to an output stream, and seek to
bring new records into the heap from the input stream in
preference to shrinking the heap size whenever possible.</p>
</dd>
<dt id="term-reserved-block">reserved block<a class="headerlink" href="#term-reserved-block" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-memory-manager"><span class="xref std std-term">memory manager</span></a>, this refers to space in the
<a class="reference internal" href="#term-memory-pool"><span class="xref std std-term">memory pool</span></a> that has been allocated to store data
received from the <a class="reference internal" href="#term-client"><span class="xref std std-term">client</span></a>.
This is in contrast to the <a class="reference internal" href="#term-free-block"><span class="xref std std-term">free blocks</span></a> that
represent space in the memory pool that is not allocated to
storing client data.</p>
</dd>
<dt id="term-resource-constraints">resource constraints<a class="headerlink" href="#term-resource-constraints" title="Permalink to this term">¶</a></dt><dd><p>Examples of resource constraints include the total space
available to store the data (possibly divided into separate
main memory and disk space constraints) and the time
allowed to perform each subtask.</p>
</dd>
<dt id="term-root">root<a class="headerlink" href="#term-root" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a>, the topmost <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> of the tree.
All other nodes in the tree are <a class="reference internal" href="#term-descendant"><span class="xref std std-term">descendants</span></a>
of the root.</p>
</dd>
<dt id="term-rotation">rotation<a class="headerlink" href="#term-rotation" title="Permalink to this term">¶</a></dt><dd><p>In the <a class="reference internal" href="#term-AVL-Tree"><span class="xref std std-term">AVL Tree</span></a> and <a class="reference internal" href="#term-Splay-Tree"><span class="xref std std-term">Splay Tree</span></a>, a rotation is a
local operation performed on a node, its children, and its
grandchildren that can result in reordering their relationship.
The goal of performing a rotation is to make the tree more
<a class="reference internal" href="#term-balanced-tree"><span class="xref std std-term">balanced</span></a>.</p>
</dd>
<dt id="term-rotational-delay">rotational delay<a class="headerlink" href="#term-rotational-delay" title="Permalink to this term">¶</a></dt><dd><p>When processing a <a class="reference internal" href="#term-disk-access"><span class="xref std std-term">disk access</span></a>, the time that it takes
for the first byte of the desired data to move to under the
<a class="reference internal" href="#term-I-O-head"><span class="xref std std-term">I/O head</span></a>.
On average, this will take one half of a disk rotation, and so
constitutes a substantial portion of the time required for the
disk access.</p>
</dd>
<dt id="term-rotational-latency">rotational latency<a class="headerlink" href="#term-rotational-latency" title="Permalink to this term">¶</a></dt><dd><p>A synonym for <a class="reference internal" href="#term-rotational-delay"><span class="xref std std-term">rotational delay</span></a>.</p>
</dd>
<dt id="term-run">run<a class="headerlink" href="#term-run" title="Permalink to this term">¶</a></dt><dd><p>A series of sorted records.
Most often this refers to a (sorted) subset of records that are
being sorted by means of an <a class="reference internal" href="#term-external-sort"><span class="xref std std-term">external sort</span></a>.</p>
</dd>
<dt id="term-run-file">run file<a class="headerlink" href="#term-run-file" title="Permalink to this term">¶</a></dt><dd><p>A temporary file that is created during the operation of an
<a class="reference internal" href="#term-external-sort"><span class="xref std std-term">external sort</span></a>, the run file contains a collection of
<a class="reference internal" href="#term-run"><span class="xref std std-term">runs</span></a>.
A common structure for an external sort is to first create a
series of runs (stored in a run file), followed by merging the
runs together.</p>
</dd>
<dt id="term-run-time-polymorphism">run-time polymorphism<a class="headerlink" href="#term-run-time-polymorphism" title="Permalink to this term">¶</a></dt><dd><p>A form of <a class="reference internal" href="#term-polymorphism"><span class="xref std std-term">polymorphism</span></a> known as Overriding.
Overridden methods are those which implement a new method
with the same signature as a method inherited from its
<a class="reference internal" href="#term-base-class"><span class="xref std std-term">base class</span></a>.
Compare to <a class="reference internal" href="#term-compile-time-polymorphism"><span class="xref std std-term">compile-time polymorphism</span></a>.</p>
</dd>
<dt id="term-runtime-environment">runtime environment<a class="headerlink" href="#term-runtime-environment" title="Permalink to this term">¶</a></dt><dd><p>The environment in which a program (of a particular programming
language) executes.
The runtime environment handles such activities as managing the
<a class="reference internal" href="#term-runtime-stack"><span class="xref std std-term">runtime stack</span></a>, the <a class="reference internal" href="#term-free-store"><span class="xref std std-term">free store</span></a>, and the
<a class="reference internal" href="#term-garbage-collection"><span class="xref std std-term">garbage collector</span></a>,
and it conducts the execution of the program.</p>
</dd>
<dt id="term-runtime-stack">runtime stack<a class="headerlink" href="#term-runtime-stack" title="Permalink to this term">¶</a></dt><dd><p>The place where an <a class="reference internal" href="#term-activation-record"><span class="xref std std-term">activation record</span></a> is stored when a
subroutine is called during a program’s runtime.</p>
</dd>
<dt id="term-scanner">scanner<a class="headerlink" href="#term-scanner" title="Permalink to this term">¶</a></dt><dd><p>The part of a <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a> that is responsible for doing
<a class="reference internal" href="#term-lexical-analysis"><span class="xref std std-term">lexical analysis</span></a>.</p>
</dd>
<dt id="term-scope">scope<a class="headerlink" href="#term-scope" title="Permalink to this term">¶</a></dt><dd><p>The parts of a program that can see and access a variable.</p>
</dd>
<dt id="term-search-key">search key<a class="headerlink" href="#term-search-key" title="Permalink to this term">¶</a></dt><dd><p>A field or part of a record that is used to represent the record
when searching. For example, in a database of customer records,
we might want to search by name.
In this case the name field is used as the search key.</p>
</dd>
<dt id="term-search-lower-bound">search lower bound<a class="headerlink" href="#term-search-lower-bound" title="Permalink to this term">¶</a></dt><dd><p>The problem of searching in an <a class="reference internal" href="#term-array"><span class="xref std std-term">array</span></a> has provable lower bounds
for specific variations of the problem.
For an unsorted array, it is <span class="math notranslate nohighlight">\(\Omega(n)\)</span>
<a class="reference internal" href="#term-comparison"><span class="xref std std-term">comparisons</span></a> in the <a class="reference internal" href="#term-worst-case"><span class="xref std std-term">worst case</span></a>,
typically proved using an <a class="reference internal" href="#term-adversary-argument"><span class="xref std std-term">adversary argument</span></a>.
For a sorted array, it is <span class="math notranslate nohighlight">\(\Omega(\log n)\)</span> in the worst
case, typically proved using an argument similar to the
<a class="reference internal" href="#term-sorting-lower-bound"><span class="xref std std-term">sorting lower bound</span></a> proof.
However, it is possible to search a sorted array in the average
case in <span class="math notranslate nohighlight">\(O(\log \log n)\)</span> time.</p>
</dd>
<dt id="term-search-problem">search problem<a class="headerlink" href="#term-search-problem" title="Permalink to this term">¶</a></dt><dd><p>Given a particular key value <span class="math notranslate nohighlight">\(K\)</span>, the search problem is to
locate a <a class="reference internal" href="#term-record"><span class="xref std std-term">record</span></a> <span class="math notranslate nohighlight">\((k_j, I_j)\)</span> in some collection of
records <strong>L</strong> such that <span class="math notranslate nohighlight">\(k_j = K\)</span> (if one exists).
<a class="reference internal" href="#term-searching"><span class="xref std std-term">Searching</span></a> is a systematic method for
locating the record (or records) with key value <span class="math notranslate nohighlight">\(k_j = K\)</span>.</p>
</dd>
<dt id="term-search-tree">search tree<a class="headerlink" href="#term-search-tree" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a> data structure that makes search by <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a>
value more efficient.
A type of <a class="reference internal" href="#term-container"><span class="xref std std-term">container</span></a>, it is common to implement an
<a class="reference internal" href="#term-indexing"><span class="xref std std-term">index</span></a> using a search tree.
A good search tree implementation will guarentee that insertion,
deletion, and search operations are all <span class="math notranslate nohighlight">\(\Theta(\log n)\)</span>.</p>
</dd>
<dt id="term-search-trie">search trie<a class="headerlink" href="#term-search-trie" title="Permalink to this term">¶</a></dt><dd><p>Any <a class="reference internal" href="#term-search-tree"><span class="xref std std-term">search tree</span></a> that is a <a class="reference internal" href="#term-trie"><span class="xref std std-term">trie</span></a>.</p>
</dd>
<dt id="term-searching">searching<a class="headerlink" href="#term-searching" title="Permalink to this term">¶</a></dt><dd><p>Given a <a class="reference internal" href="#term-search-key"><span class="xref std std-term">search key</span></a> <span class="math notranslate nohighlight">\(K\)</span> and some collection of
records <strong>L</strong>, searching is a systematic method for locating the
record (or records) in <strong>L</strong> with key value <span class="math notranslate nohighlight">\(k_j = K\)</span>.</p>
</dd>
<dt id="term-secondary-clustering">secondary clustering<a class="headerlink" href="#term-secondary-clustering" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, the tendency in certain
<a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a>
methods to create clustering in sections of the hash table.
In <a class="reference internal" href="#term-primary-clustering"><span class="xref std std-term">primary clustering</span></a>, this is caused by a cluster of
keys that don’t necessarily hash to the same slot but which
following significant portions of the same
<a class="reference internal" href="#term-probe-sequence"><span class="xref std std-term">probe sequence</span></a> during collision resolution.
Secondary clustering results from the keys hashing to the same
slot of the table (and so a collision resolution method that is
not affected by the key value must use the same probe sequence
for all such keys).
This problem can be resolved by <a class="reference internal" href="#term-double-hashing"><span class="xref std std-term">double hashing</span></a> since its
probe sequence is determined in part by a second hash function.</p>
</dd>
<dt id="term-secondary-index">secondary index<a class="headerlink" href="#term-secondary-index" title="Permalink to this term">¶</a></dt><dd><p>Synonym for <a class="reference internal" href="#term-secondary-key-index"><span class="xref std std-term">secondary key index</span></a>.</p>
</dd>
<dt id="term-secondary-key">secondary key<a class="headerlink" href="#term-secondary-key" title="Permalink to this term">¶</a></dt><dd><p>A key field in a record such as salary, where a particular key
value might be duplicated in multiple records. A secondary key
is more likely to be used by a user as a search key than is the
record’s <a class="reference internal" href="#term-primary-key"><span class="xref std std-term">primary key</span></a>.</p>
</dd>
<dt id="term-secondary-key-index">secondary key index<a class="headerlink" href="#term-secondary-key-index" title="Permalink to this term">¶</a></dt><dd><p>Associates a <a class="reference internal" href="#term-secondary-key"><span class="xref std std-term">secondary key</span></a> value with the
<a class="reference internal" href="#term-primary-key"><span class="xref std std-term">primary key</span></a> of each record having that secondary key
value.</p>
</dd>
<dt id="term-secondary-storage">secondary storage<a class="headerlink" href="#term-secondary-storage" title="Permalink to this term">¶</a></dt><dd><p>Refers to slower but cheaper means of storing data.
Typical examples include a <a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a>, a USB memory
stick, or a solid state drive.</p>
</dd>
<dt id="term-sector">sector<a class="headerlink" href="#term-sector" title="Permalink to this term">¶</a></dt><dd><p>A unit of space on a <a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a> that is the amount of
data that will be read or written at one time by the disk drive
hardware.
This is typically 512 bytes.</p>
</dd>
<dt id="term-sector-header">sector header<a class="headerlink" href="#term-sector-header" title="Permalink to this term">¶</a></dt><dd><p>On a disk drive, a piece of information at the start of a
<a class="reference internal" href="#term-sector"><span class="xref std std-term">sector</span></a> that allows the <a class="reference internal" href="#term-I-O-head"><span class="xref std std-term">I/O head</span></a> to recognize the
identity (or equivalently, the address) of the current sector.</p>
</dd>
<dt id="term-seed">seed<a class="headerlink" href="#term-seed" title="Permalink to this term">¶</a></dt><dd><p>In random number theory, the starting value for a random number
series.
Typically used with any <a class="reference internal" href="#term-linear-congruential-method"><span class="xref std std-term">linear congruential method</span></a>.</p>
</dd>
<dt id="term-seek">seek<a class="headerlink" href="#term-seek" title="Permalink to this term">¶</a></dt><dd><p>On a <a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a>, the act of moving the <a class="reference internal" href="#term-I-O-head"><span class="xref std std-term">I/O head</span></a>
from one <a class="reference internal" href="#term-track"><span class="xref std std-term">track</span></a> to another.
This is usually considered the most expensive step during a
<a class="reference internal" href="#term-disk-access"><span class="xref std std-term">disk access</span></a>.</p>
</dd>
<dt id="term-selection-sort">selection sort<a class="headerlink" href="#term-selection-sort" title="Permalink to this term">¶</a></dt><dd><p>While this sort requires <span class="math notranslate nohighlight">\(\Theta(n^2)\)</span> time in the
<a class="reference internal" href="#term-best-case"><span class="xref std std-term">best</span></a>, <a class="reference internal" href="#term-average-case"><span class="xref std std-term">average</span></a>,
and <a class="reference internal" href="#term-worst-case"><span class="xref std std-term">worst</span></a> cases, it requires only
<span class="math notranslate nohighlight">\(\Theta(n)\)</span> swap operations.
Thus, it does relatively well in applications where swaps are
expensive.
It can be viewed as an optimization on <a class="reference internal" href="#term-bubble-sort"><span class="xref std std-term">bubble sort</span></a>,
where a swap is deferred until the end of each iteration.</p>
</dd>
<dt id="term-self-organizing-list">self-organizing list<a class="headerlink" href="#term-self-organizing-list" title="Permalink to this term">¶</a></dt><dd><p>A list that, over a series of search operations, will make
use of some <a class="reference internal" href="#term-heuristic"><span class="xref std std-term">heuristic</span></a> to re-order its elements in an
effort to improve search times.
Generally speaking, search is done sequentially from the
beginning, but the self-organizing heuristic will attempt to put
the records that are most likely to be searched for at or near
the front of the list.
While typically not as efficient as <a class="reference internal" href="#term-binary-search"><span class="xref std std-term">binary search</span></a> on a
sorted list, self-organizing lists do not require that the list
be sorted (and so do not pay the cost of doing the sorting
operation).</p>
</dd>
<dt id="term-self-organizing-list-heuristic">self-organizing list heuristic<a class="headerlink" href="#term-self-organizing-list-heuristic" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-heuristic"><span class="xref std std-term">heuristic</span></a> to use for the purpose of maintaining a
<a class="reference internal" href="#term-self-organizing-list"><span class="xref std std-term">self-organizing list</span></a>.
Commonly used heuristics include
<a class="reference internal" href="#term-move-to-front"><span class="xref std std-term">move-to-front</span></a> and <a class="reference internal" href="#term-transpose"><span class="xref std std-term">transpose</span></a>.</p>
</dd>
<dt id="term-separate-chaining">separate chaining<a class="headerlink" href="#term-separate-chaining" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, a synonym for
<a class="reference internal" href="#term-open-hash-system"><span class="xref std std-term">open hashing</span></a></p>
</dd>
<dt id="term-sequence">sequence<a class="headerlink" href="#term-sequence" title="Permalink to this term">¶</a></dt><dd><p>In set notation, a collection of elements with an order, and
which may contain duplicate-valued elements.
A sequence is also sometimes called a <a class="reference internal" href="#term-tuple"><span class="xref std std-term">tuple</span></a> or a
<a class="reference internal" href="#term-vector"><span class="xref std std-term">vector</span></a>.</p>
</dd>
<dt id="term-sequential-access">sequential access<a class="headerlink" href="#term-sequential-access" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-file-processing"><span class="xref std std-term">file processing</span></a> terminology, the requirement that all
records in a file are accessed in sequential order.
Alternatively, a storage device that can only access data
sequentially, such as a tape drive.</p>
</dd>
<dt id="term-sequential-fit">sequential fit<a class="headerlink" href="#term-sequential-fit" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-memory-manager"><span class="xref std std-term">memory manager</span></a>, the process of searching the
<a class="reference internal" href="#term-memory-pool"><span class="xref std std-term">memory pool</span></a> for a <a class="reference internal" href="#term-free-block"><span class="xref std std-term">free block</span></a> large enough to
service a <a class="reference internal" href="#term-memory-request"><span class="xref std std-term">memory request</span></a>, possibly reserving the
remaining space as a free block.
Examples are <a class="reference internal" href="#term-first-fit"><span class="xref std std-term">first fit</span></a>, <a class="reference internal" href="#term-circular-first-fit"><span class="xref std std-term">circular first fit</span></a>,
<a class="reference internal" href="#term-best-fit"><span class="xref std std-term">best fit</span></a>, and <a class="reference internal" href="#term-worst-fit"><span class="xref std std-term">worst fit</span></a>.</p>
</dd>
<dt id="term-sequential-search">sequential search<a class="headerlink" href="#term-sequential-search" title="Permalink to this term">¶</a></dt><dd><p>The simplest search algorithm: In an <a class="reference internal" href="#term-array"><span class="xref std std-term">array</span></a>, simply look at the
array elements in the order that they appear.</p>
</dd>
<dt id="term-sequential-tree-representation">sequential tree representation<a class="headerlink" href="#term-sequential-tree-representation" title="Permalink to this term">¶</a></dt><dd><p>A representation that stores a series of node values with the
minimum information needed to reconstruct the tree structure.
This is a technique for <a class="reference internal" href="#term-serialization"><span class="xref std std-term">serializing</span></a> a
tree.</p>
</dd>
<dt id="term-serialization">serialization<a class="headerlink" href="#term-serialization" title="Permalink to this term">¶</a></dt><dd><p>The process of taking a data structure in memory and
representing it as a sequence of bytes.
This is sometimes done in order to transmit the data structure
across a network or store the data structure in a
<a class="reference internal" href="#term-stream"><span class="xref std std-term">stream</span></a>, such as on disk.
<a class="reference internal" href="#term-deserialization"><span class="xref std std-term">Deserialization</span></a> reconstructs the
original data structure from the serialized representation.</p>
</dd>
<dt id="term-set">set<a class="headerlink" href="#term-set" title="Permalink to this term">¶</a></dt><dd><p>A collection of distinguishable <a class="reference internal" href="#term-member"><span class="xref std std-term">members</span></a> or
<a class="reference internal" href="#term-element"><span class="xref std std-term">elements</span></a>.</p>
</dd>
<dt id="term-set-former">set former<a class="headerlink" href="#term-set-former" title="Permalink to this term">¶</a></dt><dd><p>A way to define the membership of a set, by using a text
description. Example: <span class="math notranslate nohighlight">\(\{x\ |\ x\ \mbox{is a positive integer}\}\)</span>.</p>
</dd>
<dt id="term-set-product">set product<a class="headerlink" href="#term-set-product" title="Permalink to this term">¶</a></dt><dd><p>Written <span class="math notranslate nohighlight">\(\mathbf{Q} \times \mathbf{P}\)</span>, the set product is
a set of ordered pairs such that ordered pair <span class="math notranslate nohighlight">\((a, b)\)</span> is
in the product whenever <span class="math notranslate nohighlight">\(a \in \mathbf{P}\)</span> and
<span class="math notranslate nohighlight">\(b \in \mathbf{Q}\)</span>.
For example, when <span class="math notranslate nohighlight">\(\mathbf{P} = \{2, 3, 5\}\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{Q} = \{5, 10\}\)</span>,
<span class="math notranslate nohighlight">\(\mathbf{Q} \times \mathbf{P} =
\{(2, 5),\ (2, 10),\ (3, 5),\ (3, 10),\ (5, 5),\ (5, 10)\}\)</span>.</p>
</dd>
<dt id="term-shallow-copy">shallow copy<a class="headerlink" href="#term-shallow-copy" title="Permalink to this term">¶</a></dt><dd><p>Copying the <a class="reference internal" href="#term-reference"><span class="xref std std-term">reference</span></a> or <a class="reference internal" href="#term-pointer"><span class="xref std std-term">pointer</span></a>
value without copying the actual content.</p>
</dd>
<dt id="term-Shellsort">Shellsort<a class="headerlink" href="#term-Shellsort" title="Permalink to this term">¶</a></dt><dd><p>A sort that relies on the best-case cost of
<a class="reference internal" href="#term-Insertion-Sort"><span class="xref std std-term">insertion sort</span></a> to improve over <span class="math notranslate nohighlight">\(\Theta(n^2)\)</span>
<a class="reference internal" href="#term-worst-case"><span class="xref std std-term">worst case</span></a> cost.</p>
</dd>
<dt id="term-shifting-method">shifting method<a class="headerlink" href="#term-shifting-method" title="Permalink to this term">¶</a></dt><dd><p>A technique for finding a <a class="reference internal" href="#term-closed-form-solution"><span class="xref std std-term">closed-form solution</span></a> to a
<a class="reference internal" href="#term-summation"><span class="xref std std-term">summation</span></a> or <a class="reference internal" href="#term-recurrence-relation"><span class="xref std std-term">recurrence relation</span></a>.</p>
</dd>
<dt id="term-shortest-path">shortest path<a class="headerlink" href="#term-shortest-path" title="Permalink to this term">¶</a></dt><dd><p>Given a <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> with distances or <a class="reference internal" href="#term-weight"><span class="xref std std-term">weights</span></a>
on the <a class="reference internal" href="#term-edge"><span class="xref std std-term">edges</span></a>, the shortest path between two nodes
is the path with least total distance or weight.
Examples of the shortest paths problems are the
<a class="reference internal" href="#term-single-source-shortest-paths-problem"><span class="xref std std-term">single-source shortest paths problem</span></a> and the
<a class="reference internal" href="#term-all-pairs-shortest-paths-problem"><span class="xref std std-term">all-pairs shortest paths problem</span></a>.</p>
</dd>
<dt id="term-sibling">sibling<a class="headerlink" href="#term-sibling" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a>, a sibling of <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> <span class="math notranslate nohighlight">\(A\)</span> is any
other node with the same <a class="reference internal" href="#term-parent"><span class="xref std std-term">parent</span></a> as <span class="math notranslate nohighlight">\(A\)</span>.</p>
</dd>
<dt id="term-signature">signature<a class="headerlink" href="#term-signature" title="Permalink to this term">¶</a></dt><dd><p>In a programming language, the signature for a function is its
return type and its list of parameters and their types.</p>
</dd>
<dt id="term-signature-file">signature file<a class="headerlink" href="#term-signature-file" title="Permalink to this term">¶</a></dt><dd><p>In document processing, a signature file is a type of
<a class="reference internal" href="#term-bitmap"><span class="xref std std-term">bitmap</span></a> used to indicate which documents in a collection
contain a given keyword, such that there is a <a class="reference internal" href="#term-bitmap"><span class="xref std std-term">bitmap</span></a> for
each keyword.</p>
</dd>
<dt id="term-simple-cycle">simple cycle<a class="headerlink" href="#term-simple-cycle" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> terminology, a <a class="reference internal" href="#term-cycle"><span class="xref std std-term">cycle</span></a> is simple if its
corresponding <a class="reference internal" href="#term-path"><span class="xref std std-term">path</span></a> is simple, except that the first and
last <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertices</span></a> of the cycle are the same.</p>
</dd>
<dt id="term-simple-path">simple path<a class="headerlink" href="#term-simple-path" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> terminology, a <a class="reference internal" href="#term-path"><span class="xref std std-term">path</span></a> is simple if all
vertices on the path are distinct.</p>
</dd>
<dt id="term-simple-type">simple type<a class="headerlink" href="#term-simple-type" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-data-type"><span class="xref std std-term">data type</span></a> whose values contain no subparts.
An example is the integers.</p>
</dd>
<dt id="term-simulating-recursion">simulating recursion<a class="headerlink" href="#term-simulating-recursion" title="Permalink to this term">¶</a></dt><dd><p>If a programming language does not support <a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursion</span></a>,
or if you want to implement the effects of recursion more
efficiently, you can use a <a class="reference internal" href="#term-stack"><span class="xref std std-term">stack</span></a> to maintain the
collection of subproblems that
would be waiting for completion during the recursive process.
Using a loop, whenever a recursive call would have been made,
simply add the necessary program state to the stack.
When a return would have been made from the recursive call, pop
the previous program state off of the stack.</p>
</dd>
<dt id="term-single-rotation">single rotation<a class="headerlink" href="#term-single-rotation" title="Permalink to this term">¶</a></dt><dd><p>A type of <a class="reference internal" href="#term-rebalancing-operation"><span class="xref std std-term">rebalancing operation</span></a> used by the
<a class="reference internal" href="#term-Splay-Tree"><span class="xref std std-term">Splay Tree</span></a> and <a class="reference internal" href="#term-AVL-Tree"><span class="xref std std-term">AVL Tree</span></a>.</p>
</dd>
<dt id="term-single-source-shortest-paths-problem">single-source shortest paths problem<a class="headerlink" href="#term-single-source-shortest-paths-problem" title="Permalink to this term">¶</a></dt><dd><p>Given a <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> with <a class="reference internal" href="#term-weight"><span class="xref std std-term">weights</span></a> or
distances on the <a class="reference internal" href="#term-edge"><span class="xref std std-term">edges</span></a>, and a designated start
<a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertex</span></a> <span class="math notranslate nohighlight">\(s\)</span>, find the shortest path from <span class="math notranslate nohighlight">\(s\)</span>
to every other vertex in the graph.
One algorithm to solve this problem is <a class="reference internal" href="#term-Dijkstra-s-algorithm"><span class="xref std std-term">Dijkstra’s algorithm</span></a>.</p>
</dd>
<dt id="term-singly-linked-list">singly linked list<a class="headerlink" href="#term-singly-linked-list" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-linked-list"><span class="xref std std-term">linked list</span></a> implementation variant where each list
node contains access an pointer only to the next element in the list.</p>
</dd>
<dt id="term-skip-list">skip list<a class="headerlink" href="#term-skip-list" title="Permalink to this term">¶</a></dt><dd><p>A form of <a class="reference internal" href="#term-linked-list"><span class="xref std std-term">linked list</span></a> that adds additional links to
improve the cost of fundamental operations like insert, delete,
and search.
It is a <a class="reference internal" href="#term-probabilistic-data-structure"><span class="xref std std-term">probabilistic data structure</span></a> since it adds the
additional links using a <a class="reference internal" href="#term-probabilistic-algorithm"><span class="xref std std-term">probabilistic algorithm</span></a>.
It can implement a <a class="reference internal" href="#term-dictionary"><span class="xref std std-term">dictionary</span></a> more efficiently than a
<a class="reference internal" href="#term-BST"><span class="xref std std-term">BST</span></a>, and is roughly as difficult to implement.</p>
</dd>
<dt id="term-slot">slot<a class="headerlink" href="#term-slot" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, a position in a <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a>.</p>
</dd>
<dt id="term-snowplow-argument">snowplow argument<a class="headerlink" href="#term-snowplow-argument" title="Permalink to this term">¶</a></dt><dd><p>An analogy used to give intuition for why <a class="reference internal" href="#term-replacement-selection"><span class="xref std std-term">replacement
selection</span></a> will generate <a class="reference internal" href="#term-run"><span class="xref std std-term">runs</span></a> that are on average
twice the size of working memory.
Records coming from the input stream have key values that might
be of any size, whose size is related to the position of a
falling snowflake.
The replacement selection process is analogous to a snowplow
that moves around a circular track picking up snow.
In steady state, given a certain amount of snow equivalent to
<a class="reference internal" href="#term-working-memory"><span class="xref std std-term">working memory</span></a> size <span class="math notranslate nohighlight">\(M\)</span>, an amount of snow
(incoming records from the input stream) is expected to fall
ahead of the plow as the size of the working memory during one
cycle of the plow (analogously, one run of the replacement
selection algorithm).
Thus, the snowplow is expected in one pass (one run of
replacement selection) to pick up <span class="math notranslate nohighlight">\(2M\)</span> snow.</p>
</dd>
<dt id="term-software-engineering">software engineering<a class="headerlink" href="#term-software-engineering" title="Permalink to this term">¶</a></dt><dd><p>The study and application of engineering to the design,
development, and maintenance of software.</p>
</dd>
<dt id="term-software-reuse">software reuse<a class="headerlink" href="#term-software-reuse" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-software-engineering"><span class="xref std std-term">software engineering</span></a>, the concept of reusing a piece
of software.
In particular, using an existing piece of software (such as a
function or library) when creating new software.</p>
</dd>
<dt id="term-solution-space">solution space<a class="headerlink" href="#term-solution-space" title="Permalink to this term">¶</a></dt><dd><p>The possible solutions to a problem.
This typically refers to an <a class="reference internal" href="#term-optimization-problem"><span class="xref std std-term">optimization problem</span></a>, where
some solutions are more desireable than others.</p>
</dd>
<dt id="term-solution-tree">solution tree<a class="headerlink" href="#term-solution-tree" title="Permalink to this term">¶</a></dt><dd><p>An ordering imposed on the set of solutions within a
<a class="reference internal" href="#term-solution-space"><span class="xref std std-term">solution space</span></a> in the form of a  tree, typically derived
from the order that some algorithm would visit the solutions.</p>
</dd>
<dt id="term-sorted-list">sorted list<a class="headerlink" href="#term-sorted-list" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-list"><span class="xref std std-term">list</span></a> where the records stored in the list are arranged
so that their <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> values are in ascending order.
If the list uses an <a class="reference internal" href="#term-array-based-list"><span class="xref std std-term">array-based list</span></a> implementation,
then it can use <a class="reference internal" href="#term-binary-search"><span class="xref std std-term">binary search</span></a> for a cost of
<span class="math notranslate nohighlight">\(\Theta(\log n)\)</span>.
But both insertion and deletion will be require
<span class="math notranslate nohighlight">\(\Theta(n)\)</span> time.</p>
</dd>
<dt id="term-sorting-lower-bound">sorting lower bound<a class="headerlink" href="#term-sorting-lower-bound" title="Permalink to this term">¶</a></dt><dd><p>The lower bound for the <a class="reference internal" href="#term-problem"><span class="xref std std-term">problem</span></a> of
<a class="reference internal" href="#term-sorting-problem"><span class="xref std std-term">sorting</span></a> is <span class="math notranslate nohighlight">\(\Omega(n \log n)\)</span>.
This is traditionally proved using a <a class="reference internal" href="#term-decision-tree"><span class="xref std std-term">decision tree</span></a> model
for sorting algorithms, and recognizing that the minimum depth
of the decision tree for any sorting algorithm is
<span class="math notranslate nohighlight">\(\Omega(n \log n)\)</span> since there are <span class="math notranslate nohighlight">\(n!\)</span> permutations
of the <span class="math notranslate nohighlight">\(n\)</span> input records to distinguish between during the
sorting process.</p>
</dd>
<dt id="term-sorting-problem">sorting problem<a class="headerlink" href="#term-sorting-problem" title="Permalink to this term">¶</a></dt><dd><p>Given a set of records <span class="math notranslate nohighlight">\(r_1\)</span>, <span class="math notranslate nohighlight">\(r_2\)</span>, …, <span class="math notranslate nohighlight">\(r_n\)</span>
with <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> values <span class="math notranslate nohighlight">\(k_1\)</span>, <span class="math notranslate nohighlight">\(k_2\)</span>, …, <span class="math notranslate nohighlight">\(k_n\)</span>,
the sorting problem is to arrange the records into any order
<span class="math notranslate nohighlight">\(s\)</span> such that records
<span class="math notranslate nohighlight">\(r_{s_1}\)</span>, <span class="math notranslate nohighlight">\(r_{s_2}\)</span>, …, <span class="math notranslate nohighlight">\(r_{s_n}\)</span>
have keys obeying the property
<span class="math notranslate nohighlight">\(k_{s_1} \leq k_{s_2} \leq ... \leq k_{s_n}\)</span>.
In other words, the sorting problem is to arrange a set of
records so that the values of their key fields are in
non-decreasing order.</p>
</dd>
<dt id="term-space-time-tradeoff">space/time tradeoff<a class="headerlink" href="#term-space-time-tradeoff" title="Permalink to this term">¶</a></dt><dd><p>Many programs can be designed to either speed processing at the
cost of additional storage, or reduce storage at the cost of
additional processing time.</p>
</dd>
<dt id="term-sparse-graph">sparse graph<a class="headerlink" href="#term-sparse-graph" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> where the actual number of <a class="reference internal" href="#term-edge"><span class="xref std std-term">edges</span></a>
is much less than the possible number of edges.
Generally, this is interpreted to mean that the <a class="reference internal" href="#term-degree"><span class="xref std std-term">degree</span></a>
for any <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertex</span></a> in the graph is relatively low.</p>
</dd>
<dt id="term-sparse-matrix">sparse matrix<a class="headerlink" href="#term-sparse-matrix" title="Permalink to this term">¶</a></dt><dd><p>A matrix whose values are mostly zero.
There are a number of data structures that have been developed
to store sparse matrices, with the goal of reducing the amount
of space required to represent it as compared to simply using a
regular matrix representation that stores a value for every
matrix position.</p>
</dd>
<dt id="term-spatial">spatial<a class="headerlink" href="#term-spatial" title="Permalink to this term">¶</a></dt><dd><p>Referring to a position in space.</p>
</dd>
<dt id="term-spatial-application">spatial application<a class="headerlink" href="#term-spatial-application" title="Permalink to this term">¶</a></dt><dd><p>An application what has spatial aspects.
In particular, an application that stores records that need to
be searched by location.</p>
</dd>
<dt id="term-spatial-attribute">spatial attribute<a class="headerlink" href="#term-spatial-attribute" title="Permalink to this term">¶</a></dt><dd><p>An attribute of a record that has a position in space, such as
the coordinate.
This is typically in two or more dimensions.</p>
</dd>
<dt id="term-spatial-data">spatial data<a class="headerlink" href="#term-spatial-data" title="Permalink to this term">¶</a></dt><dd><p>Any object or record that has a position (in space).</p>
</dd>
<dt id="term-spatial-data-structure">spatial data structure<a class="headerlink" href="#term-spatial-data-structure" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-data-structure"><span class="xref std std-term">data structure</span></a> designed to support efficient
processing when a
<a class="reference internal" href="#term-spatial-attribute"><span class="xref std std-term">spatial attribute</span></a> is used as the key.
In particular, a data structure that supports efficient search
by location, or finds all records within a given region in two
or more dimensions.
Examples of spatial data structures to store point data include
the <a class="reference internal" href="#term-bintree"><span class="xref std std-term">bintree</span></a>, the <a class="reference internal" href="#term-PR-quadtree"><span class="xref std std-term">PR quadtree</span></a> and the
<a class="reference internal" href="#term-kd-tree"><span class="xref std std-term">kd tree</span></a>.</p>
</dd>
<dt id="term-spindle">spindle<a class="headerlink" href="#term-spindle" title="Permalink to this term">¶</a></dt><dd><p>The center of a <a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a> that holds the
<a class="reference internal" href="#term-platter"><span class="xref std std-term">platters</span></a> in place.</p>
</dd>
<dt id="term-Splay-Tree">Splay Tree<a class="headerlink" href="#term-Splay-Tree" title="Permalink to this term">¶</a></dt><dd><p>A variant implementation for the <a class="reference internal" href="#term-BST"><span class="xref std std-term">BST</span></a>, which differs from
the standard BST in that it uses modified insert and remove
methods in order to keep the tree
<a class="reference internal" href="#term-balanced-tree"><span class="xref std std-term">balanced</span></a>.
Similar to an <a class="reference internal" href="#term-AVL-Tree"><span class="xref std std-term">AVL Tree</span></a> in that it uses the concept of
<a class="reference internal" href="#term-rotation"><span class="xref std std-term">rotations</span></a> in the insert and remove operations.
While a Splay Tree does not guarentee that the tree is balanced,
it does guarentee that a series of <span class="math notranslate nohighlight">\(n\)</span> operations on the
tree will have a total cost of <span class="math notranslate nohighlight">\(\Theta(n \log n)\)</span> cost,
meaning that any given operation can be viewed as having
<a class="reference internal" href="#term-amortized-cost"><span class="xref std std-term">amortized cost</span></a> of <span class="math notranslate nohighlight">\(\Theta(\log n)\)</span>.</p>
</dd>
<dt id="term-splaying">splaying<a class="headerlink" href="#term-splaying" title="Permalink to this term">¶</a></dt><dd><p>The act of performing an <a class="reference internal" href="#term-rebalancing-operation"><span class="xref std std-term">rebalancing operation</span></a> on a
<a class="reference internal" href="#term-Splay-Tree"><span class="xref std std-term">Splay Tree</span></a>.</p>
</dd>
<dt id="term-stable">stable<a class="headerlink" href="#term-stable" title="Permalink to this term">¶</a></dt><dd><p>A sorting algorithm is said to be stable if it does not
change the relative ordering of records with identical
<a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> values.</p>
</dd>
<dt id="term-stack">stack<a class="headerlink" href="#term-stack" title="Permalink to this term">¶</a></dt><dd><p>A list-like structure in which elements may be inserted or
removed from only one end.</p>
</dd>
<dt id="term-stack-frame">stack frame<a class="headerlink" href="#term-stack-frame" title="Permalink to this term">¶</a></dt><dd><p>Frame of data that pushed into and poped from call stack</p>
</dd>
<dt id="term-stack-variable">stack variable<a class="headerlink" href="#term-stack-variable" title="Permalink to this term">¶</a></dt><dd><p>Another name for a <a class="reference internal" href="#term-local-variable"><span class="xref std std-term">local variable</span></a>.</p>
</dd>
<dt id="term-stale-pointer">stale pointer<a class="headerlink" href="#term-stale-pointer" title="Permalink to this term">¶</a></dt><dd><p>Within the context of a <a class="reference internal" href="#term-buffer-pool"><span class="xref std std-term">buffer pool</span></a> or
<a class="reference internal" href="#term-memory-manager"><span class="xref std std-term">memory manager</span></a>, this means a <a class="reference internal" href="#term-reference"><span class="xref std std-term">reference</span></a> to a
<a class="reference internal" href="#term-buffer"><span class="xref std std-term">buffer</span></a> or memory location that is no longer valid.
For example, a program might make a memory request to a buffer
pool, and be given a reference to the buffer holding the
requested data.
Over time, due to inactivity, the contents of this buffer might
be flushed.
If the program holding the buffer reference then tries to access
the contents of that buffer again, then the data contents will
have changed.
The possibility for this to occur depends on the design of the
interface to the buffer pool system.
Some designs make this impossible to occur.
Other designs make it possible in an attempt to deliver greater
performance.</p>
</dd>
<dt id="term-start-state">start state<a class="headerlink" href="#term-start-state" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-Finite-Automata"><span class="xref std std-term">finite automata</span></a>, the designated state in which the
machine will always begin a computation.</p>
</dd>
<dt id="term-start-symbol">start symbol<a class="headerlink" href="#term-start-symbol" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-grammar"><span class="xref std std-term">grammar</span></a>, the designated <a class="reference internal" href="#term-non-terminal"><span class="xref std std-term">non-terminal</span></a> that
is the intial point for <a class="reference internal" href="#term-derivation"><span class="xref std std-term">deriving</span></a> a string
in the langauge.</p>
</dd>
<dt id="term-state">state<a class="headerlink" href="#term-state" title="Permalink to this term">¶</a></dt><dd><p>The condition that something is in at some point in time.
In computing, this typically means the collective values of any
existing variables at some point in time.
In an <a class="reference internal" href="#term-automata"><span class="xref std std-term">automata</span></a>, a state is an abstract condition,
possibly with associated information, that is primarily defined
in terms of the conditions that the automata may transition from
its present state to another state.
This type of state is generally represented by a node in the
graph that represents the automata.</p>
</dd>
<dt id="term-State-Machine">State Machine<a class="headerlink" href="#term-State-Machine" title="Permalink to this term">¶</a></dt><dd><p>Synonym for <a class="reference internal" href="#term-Finite-Automata"><span class="xref std std-term">finite automata</span></a>.</p>
</dd>
<dt id="term-static">static<a class="headerlink" href="#term-static" title="Permalink to this term">¶</a></dt><dd><p>Something that is not changing (in contrast to <a class="reference internal" href="#term-dynamic"><span class="xref std std-term">dynamic</span></a>).
In computer programming, static normally refers to something
that happens at compile time.
For example, static analysis is analysis of the program’s text
or structure, as opposed to its run-time behavior.
Static binding or static memory allocation occurs at compile time.</p>
</dd>
<dt id="term-static-scoping">static scoping<a class="headerlink" href="#term-static-scoping" title="Permalink to this term">¶</a></dt><dd><p>A synonym for <a class="reference internal" href="#term-lexical-scoping"><span class="xref std std-term">lexical scoping</span></a>.</p>
</dd>
<dt id="term-Strassen-s-algorithm">Strassen’s algorithm<a class="headerlink" href="#term-Strassen-s-algorithm" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-recursion"><span class="xref std std-term">recursive</span></a> algorithm for matrix
multiplication.
When multiplying two <span class="math notranslate nohighlight">\(n \times n\)</span> matrices,
this algorithm runs faster than the <span class="math notranslate nohighlight">\(\Theta(n^3)\)</span> time
required by the standard matrix multiplication algorithm.
Specifically, Strassen’s algorithm requires time
<span class="math notranslate nohighlight">\(Theta(n^{\log_2 7})\)</span> time.
This is achieved by refactoring the sub-matrix multiplication
and addition operations so as to need only 7 sub-matrix
multiplications instead of 8, at a cost of additional sub-matrix
addition operations.
Thus, while the asymptotic cost is lower, the constant factor in
the growth rate equation is higher.
This makes Strassen’s algorithm inefficient in practice unless
the arrays being multiplied are rather large.
Variations on Strassen’s algorithm exist that reduce the number
of sub-matrix multiplications even futher at a cost of even more
sub-matrix additions.</p>
</dd>
<dt id="term-strategy">strategy<a class="headerlink" href="#term-strategy" title="Permalink to this term">¶</a></dt><dd><p>An approach to accomplish a task, often encapsulated as an
algorithm.
Also the name for a <a class="reference internal" href="#term-design-pattern"><span class="xref std std-term">design pattern</span></a> that separates the
algorithm for performing a task from the control for applying
that task to each member of a collection.
A good example is a generic sorting function that takes a
collection of records (such as an <a class="reference internal" href="#term-array"><span class="xref std std-term">array</span></a>) and a “strategy” in the
form of an algorithm that knows how to extract the key from a
record in the array.
Only subtly different from the <a class="reference internal" href="#term-visitor"><span class="xref std std-term">visitor</span></a> design pattern,
where the difference is primarily one of intent rather than
syntax.
The strategy design pattern is focused on encapsulating an
activity that is part of a larger process, so that different
ways of performing that activity can be substituted.
The visitor design pattern is focused on encapsulating an
activity that will be performed on all members of a collection
so that completely different activities can be substituted
within a generic method that accesses all of the collection
members.</p>
</dd>
<dt id="term-stream">stream<a class="headerlink" href="#term-stream" title="Permalink to this term">¶</a></dt><dd><p>The process of delivering content in a
<a class="reference internal" href="#term-serialization"><span class="xref std std-term">serialized</span></a> form.</p>
</dd>
<dt id="term-strict-partial-order">strict partial order<a class="headerlink" href="#term-strict-partial-order" title="Permalink to this term">¶</a></dt><dd><p>In set notation, a relation that is <a class="reference internal" href="#term-irreflexive"><span class="xref std std-term">irreflexive</span></a>,
<a class="reference internal" href="#term-antisymmetric"><span class="xref std std-term">antisymmetric</span></a>, and <a class="reference internal" href="#term-transitive"><span class="xref std std-term">transitive</span></a>.</p>
</dd>
<dt id="term-strong-induction">strong induction<a class="headerlink" href="#term-strong-induction" title="Permalink to this term">¶</a></dt><dd><p>An alternative formulation for the <a class="reference internal" href="#term-induction-step"><span class="xref std std-term">induction step</span></a> in a
<a class="reference internal" href="#term-proof-by-induction"><span class="xref std std-term">proof by induction</span></a>.
The induction step for strong induction is:
If <strong>Thrm</strong> holds for all <span class="math notranslate nohighlight">\(k, c \leq k &lt; n\)</span>, then
<strong>Thrm</strong> holds for <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd>
<dt id="term-subclass">subclass<a class="headerlink" href="#term-subclass" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><span class="xref std std-term">object-oriented programming</span></a>,
any class within a <a class="reference internal" href="#term-class-hierarchy"><span class="xref std std-term">class hierarchy</span></a> that
<a class="reference internal" href="#term-inherit"><span class="xref std std-term">inherits</span></a> from some other class.</p>
</dd>
<dt id="term-subgraph">subgraph<a class="headerlink" href="#term-subgraph" title="Permalink to this term">¶</a></dt><dd><p>A subgraph <span class="math notranslate nohighlight">\(\mathbf{S}\)</span> is formed from <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a>
<span class="math notranslate nohighlight">\(\mathbf{G}\)</span> by selecting a <a class="reference internal" href="#term-subset"><span class="xref std std-term">subset</span></a>
<span class="math notranslate nohighlight">\(\mathbf{V}_s\)</span> of <span class="math notranslate nohighlight">\(\mathbf{G}\)</span>’s <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertices</span></a> and a subset <span class="math notranslate nohighlight">\(\mathbf{E}_s\)</span> of
<span class="math notranslate nohighlight">\(\mathbf{G}\)</span>’s <a class="reference internal" href="#term-edge"><span class="xref std std-term">edges</span></a> such that for every
edge <span class="math notranslate nohighlight">\(e \in \mathbf{E}_s\)</span>,
both vertices of <span class="math notranslate nohighlight">\(e\)</span> are in <span class="math notranslate nohighlight">\(\mathbf{V}_s\)</span>.</p>
</dd>
<dt id="term-subset">subset<a class="headerlink" href="#term-subset" title="Permalink to this term">¶</a></dt><dd><p>In set theory, a set <span class="math notranslate nohighlight">\(A\)</span> is a subset of a set
<span class="math notranslate nohighlight">\(B\)</span>, or equivalently <span class="math notranslate nohighlight">\(B\)</span> is a <a class="reference internal" href="#term-superset"><span class="xref std std-term">superset</span></a> of
<span class="math notranslate nohighlight">\(A\)</span>, if all elements of <span class="math notranslate nohighlight">\(A\)</span> are also elements of
<span class="math notranslate nohighlight">\(B\)</span>.</p>
</dd>
<dt id="term-subtract-and-guess">subtract-and-guess<a class="headerlink" href="#term-subtract-and-guess" title="Permalink to this term">¶</a></dt><dd><p>A technique for finding a <a class="reference internal" href="#term-closed-form-solution"><span class="xref std std-term">closed-form solution</span></a> to a
<a class="reference internal" href="#term-summation"><span class="xref std std-term">summation</span></a> or <a class="reference internal" href="#term-recurrence-relation"><span class="xref std std-term">recurrence relation</span></a>.</p>
</dd>
<dt id="term-subtree">subtree<a class="headerlink" href="#term-subtree" title="Permalink to this term">¶</a></dt><dd><p>A subtree is a <a class="reference internal" href="#term-subset"><span class="xref std std-term">subset</span></a> of the nodes of a binary tree that
includes some node <span class="math notranslate nohighlight">\(R\)</span> of the tree as the subtree
<a class="reference internal" href="#term-root"><span class="xref std std-term">root</span></a> along with all the <a class="reference internal" href="#term-descendant"><span class="xref std std-term">descendants</span></a>
of <span class="math notranslate nohighlight">\(R\)</span>.</p>
</dd>
<dt id="term-successful-search">successful search<a class="headerlink" href="#term-successful-search" title="Permalink to this term">¶</a></dt><dd><p>When searching for a <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> value in a collection of
records, we might find it.
If so, we call this a successful search.
The alternative is an <a class="reference internal" href="#term-unsuccessful-search"><span class="xref std std-term">unsuccessful search</span></a>.</p>
</dd>
<dt id="term-summation">summation<a class="headerlink" href="#term-summation" title="Permalink to this term">¶</a></dt><dd><p>The sum of costs for some <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a> applied to a
range of parameter values.
Often written using Sigma notation.
For example, the sum of the integers from 1 to <span class="math notranslate nohighlight">\(n\)</span> can be
written as <span class="math notranslate nohighlight">\(\sum_{i=1}^{n} i\)</span>.</p>
</dd>
<dt id="term-superset">superset<a class="headerlink" href="#term-superset" title="Permalink to this term">¶</a></dt><dd><p>In set theory, a set <span class="math notranslate nohighlight">\(A\)</span> is a <a class="reference internal" href="#term-subset"><span class="xref std std-term">subset</span></a> of a
<a class="reference internal" href="#term-set"><span class="xref std std-term">set</span></a> <span class="math notranslate nohighlight">\(B\)</span>, or equivalently <span class="math notranslate nohighlight">\(B\)</span> is a
<a class="reference internal" href="#term-superset"><span class="xref std std-term">superset</span></a> of <span class="math notranslate nohighlight">\(A\)</span>, if all <a class="reference internal" href="#term-element"><span class="xref std std-term">elements</span></a>
of <span class="math notranslate nohighlight">\(A\)</span> are also elements of <span class="math notranslate nohighlight">\(B\)</span>.</p>
</dd>
<dt id="term-symbol-table">symbol table<a class="headerlink" href="#term-symbol-table" title="Permalink to this term">¶</a></dt><dd><p>As part of a <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a>, the symbol table stores all of
the identifiers in the program, along with any necessary
information needed about the identifier to allow the compiler to
do its job.</p>
</dd>
<dt id="term-symmetric">symmetric<a class="headerlink" href="#term-symmetric" title="Permalink to this term">¶</a></dt><dd><p>In set notation, relation <span class="math notranslate nohighlight">\(R\)</span> is symmetric if whenever
<span class="math notranslate nohighlight">\(aRb\)</span>, then <span class="math notranslate nohighlight">\(bRa\)</span>, for all <span class="math notranslate nohighlight">\(a, b \in \mathbf{S}\)</span>.</p>
</dd>
<dt id="term-symmetric-matrix">symmetric matrix<a class="headerlink" href="#term-symmetric-matrix" title="Permalink to this term">¶</a></dt><dd><p>A square matrix that is equal to its <a class="reference internal" href="#term-transpose"><span class="xref std std-term">transpose</span></a>.
Equivalently, for a <span class="math notranslate nohighlight">\(n \times n\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span>,
for all <span class="math notranslate nohighlight">\(i,j &lt; n\)</span>, <span class="math notranslate nohighlight">\(A[i, j] = A[j, i]\)</span>.</p>
</dd>
<dt id="term-syntax-analysis">syntax analysis<a class="headerlink" href="#term-syntax-analysis" title="Permalink to this term">¶</a></dt><dd><p>A phase of <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compilation</span></a> that accepts
<a class="reference internal" href="#term-token"><span class="xref std std-term">tokens</span></a>, checks if program is syntactically
correct, and then generates a <a class="reference internal" href="#term-parse-tree"><span class="xref std std-term">parse tree</span></a>.</p>
</dd>
<dt id="term-tail">tail<a class="headerlink" href="#term-tail" title="Permalink to this term">¶</a></dt><dd><p>The end of a <a class="reference internal" href="#term-list"><span class="xref std std-term">list</span></a>.</p>
</dd>
<dt id="term-terminal">terminal<a class="headerlink" href="#term-terminal" title="Permalink to this term">¶</a></dt><dd><p>A specific character or string that appears in a
<a class="reference internal" href="#term-production-rule"><span class="xref std std-term">production rule</span></a>.
In contrast to a <a class="reference internal" href="#term-non-terminal"><span class="xref std std-term">non-terminal</span></a>, which represents an
abstract state in the production.
Similar to a <a class="reference internal" href="#term-literal"><span class="xref std std-term">literal</span></a>, but this is the term more
typically used in the context of a <a class="reference internal" href="#term-compiler"><span class="xref std std-term">compiler</span></a>.</p>
</dd>
<dt id="term-testing">testing<a class="headerlink" href="#term-testing" title="Permalink to this term">¶</a></dt><dd><p>Determining whether a program operates as we intend.
This is in contrast to <a class="reference internal" href="#term-debugging"><span class="xref std std-term">debugging</span></a>.</p>
</dd>
<dt id="term-Theta-notation">Theta notation<a class="headerlink" href="#term-Theta-notation" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-algorithm-analysis"><span class="xref std std-term">algorithm analysis</span></a>, <span class="math notranslate nohighlight">\(\Theta\)</span> notation is used
to indicate that the
<a class="reference internal" href="#term-upper-bound"><span class="xref std std-term">upper bound</span></a> and <a class="reference internal" href="#term-lower-bound"><span class="xref std std-term">lower bound</span></a> for an
<a class="reference internal" href="#term-algorithm"><span class="xref std std-term">algorithm</span></a> or <a class="reference internal" href="#term-problem"><span class="xref std std-term">problem</span></a> match.</p>
</dd>
<dt id="term-token">token<a class="headerlink" href="#term-token" title="Permalink to this term">¶</a></dt><dd><p>The basic logical units of a program, as deterimined by
<a class="reference internal" href="#term-lexical-analysis"><span class="xref std std-term">lexical analysis</span></a>.
These are things like arithmetic operators, language keywords,
variable or function names, or numbers.</p>
</dd>
<dt id="term-tombstone">tombstone<a class="headerlink" href="#term-tombstone" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-hashing"><span class="xref std std-term">hashing</span></a>, a tombstone is used to mark a <a class="reference internal" href="#term-slot"><span class="xref std std-term">slot</span></a>
in the <a class="reference internal" href="#term-hash-table"><span class="xref std std-term">hash table</span></a> where a record has been deleted.
Its purpose is to allow the <a class="reference internal" href="#term-collision-resolution"><span class="xref std std-term">collision resolution</span></a> process
to probe through that slot (so that records further down the
<a class="reference internal" href="#term-probe-sequence"><span class="xref std std-term">probe sequence</span></a> are not unreachable after deleting the
record), while also allowing the slot to be reused by a future
insert operation.</p>
</dd>
<dt id="term-topological-sort">topological sort<a class="headerlink" href="#term-topological-sort" title="Permalink to this term">¶</a></dt><dd><p>The process of laying out the <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertices</span></a> of a
<a class="reference internal" href="#term-DAG"><span class="xref std std-term">DAG</span></a> in a <a class="reference internal" href="#term-linear-order"><span class="xref std std-term">linear order</span></a> such that no vertex
<span class="math notranslate nohighlight">\(A\)</span> in the order is preceded by a vertex that can be
reached by a (directed) <a class="reference internal" href="#term-path"><span class="xref std std-term">path</span></a> from <span class="math notranslate nohighlight">\(A\)</span>.
Usually the (directed) edges in the graph define a
prerequisite system, and the goal of the topological sort is
to list the vertices in an order such that no prerequisites are
violated.</p>
</dd>
<dt id="term-total-order">total order<a class="headerlink" href="#term-total-order" title="Permalink to this term">¶</a></dt><dd><p>A binary relation on a set where every pair of distinct elements
in the set are <a class="reference internal" href="#term-comparable"><span class="xref std std-term">comparable</span></a> (that is, one can determine
which of the pair is greater than the other).</p>
</dd>
<dt id="term-total-path-length">total path length<a class="headerlink" href="#term-total-path-length" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a>, the sum of the <a class="reference internal" href="#term-level"><span class="xref std std-term">levels</span></a> for
each <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a>.</p>
</dd>
<dt id="term-Towers-of-Hanoi-problem">Towers of Hanoi problem<a class="headerlink" href="#term-Towers-of-Hanoi-problem" title="Permalink to this term">¶</a></dt><dd><p>A standard example of a recursive algorithm.
The problem starts with a stack of disks (each with unique size)
stacked decreasing order on the left pole, and two additional
poles.
The problem is to move the disks to the right pole, with the
constraints that only one disk can be moved at a time and a
disk may never be on top of a smaller disk.
For <span class="math notranslate nohighlight">\(n\)</span> disks, this problem requires <span class="math notranslate nohighlight">\(\Theta(2^n)\)</span>
moves.
The standard solution is to move <span class="math notranslate nohighlight">\(n-1\)</span> disks to the middle
pole, move the bottom disk to the right pole, and then move the
<span class="math notranslate nohighlight">\(n-1\)</span> disks on the middle pole to the right pole.</p>
</dd>
<dt id="term-track">track<a class="headerlink" href="#term-track" title="Permalink to this term">¶</a></dt><dd><p>On a <a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a>, a concentric circle representing all of
the <a class="reference internal" href="#term-sector"><span class="xref std std-term">sectors</span></a> that can be viewed by the
<a class="reference internal" href="#term-I-O-head"><span class="xref std std-term">I/O head</span></a> as the disk rotates.
The significance is that, for a given placement of the I/O head,
the sectors on the track can be read without performing a
(relatively expensive) <a class="reference internal" href="#term-seek"><span class="xref std std-term">seek</span></a> operation.</p>
</dd>
<dt id="term-track-to-track-seek-time">track-to-track seek time<a class="headerlink" href="#term-track-to-track-seek-time" title="Permalink to this term">¶</a></dt><dd><p>Expected (average) time to perform a <a class="reference internal" href="#term-seek"><span class="xref std std-term">seek</span></a> operation from
a random <a class="reference internal" href="#term-track"><span class="xref std std-term">track</span></a> to an adjacent track.
Thus, this can be viewed as the minimum possible seek time for the
<a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a>.
This is one of two metrics commonly provided by disk drive
vendors for disk drive performance, with the other being
<a class="reference internal" href="#term-average-seek-time"><span class="xref std std-term">average seek time</span></a>.</p>
</dd>
<dt id="term-trailer-node">trailer node<a class="headerlink" href="#term-trailer-node" title="Permalink to this term">¶</a></dt><dd><p>Commonly used in implementations for a <a class="reference internal" href="#term-linked-list"><span class="xref std std-term">linked list</span></a> or
related structure, this <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> follows the last element
of the list.
Its purpose is to simplify the code implementation by
reducing the number of special cases that must be programmed
for.</p>
</dd>
<dt id="term-transducer">transducer<a class="headerlink" href="#term-transducer" title="Permalink to this term">¶</a></dt><dd><p>A machine that takes an input and creates an output.
A <a class="reference internal" href="#term-Turing-machine"><span class="xref std std-term">Turing Machine</span></a> is an example of a transducer.</p>
</dd>
<dt id="term-transitive">transitive<a class="headerlink" href="#term-transitive" title="Permalink to this term">¶</a></dt><dd><p>In set notation, relation <span class="math notranslate nohighlight">\(R\)</span> is transitive if whenever
<span class="math notranslate nohighlight">\(aRb\)</span> and <span class="math notranslate nohighlight">\(bRc\)</span>, then <span class="math notranslate nohighlight">\(aRc\)</span>, for all
<span class="math notranslate nohighlight">\(a, b, c \in \mathbf{S}\)</span>.</p>
</dd>
<dt id="term-transpose">transpose<a class="headerlink" href="#term-transpose" title="Permalink to this term">¶</a></dt><dd><p>In the context of linear algebra,
the transpose of a matrix <span class="math notranslate nohighlight">\(A\)</span> is
another matrix <span class="math notranslate nohighlight">\(A^T\)</span> created by writing the rows of
<span class="math notranslate nohighlight">\(A\)</span> as the columns of <span class="math notranslate nohighlight">\(A^T\)</span>.
In the context of a <a class="reference internal" href="#term-self-organizing-list"><span class="xref std std-term">self-organizing list</span></a>,
transpose is a <a class="reference internal" href="#term-heuristic"><span class="xref std std-term">heuristic</span></a> used to maintain the list.
Under this heuristic, whenever a record is accessed it is moved
one position closer to the front of the list.</p>
</dd>
<dt id="term-trap-state">trap state<a class="headerlink" href="#term-trap-state" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-FSA"><span class="xref std std-term">FSA</span></a>, any state that has all transitions cycle back
to itself.
Such a state might be <a class="reference internal" href="#term-final-state"><span class="xref std std-term">final</span></a>.</p>
</dd>
<dt id="term-traversal">traversal<a class="headerlink" href="#term-traversal" title="Permalink to this term">¶</a></dt><dd><p>Any process for visiting all of the objects in a collection
(such as a <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a> or <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a>) in some order.</p>
</dd>
<dt id="term-tree">tree<a class="headerlink" href="#term-tree" title="Permalink to this term">¶</a></dt><dd><p>A tree <span class="math notranslate nohighlight">\(\mathbf{T}\)</span> is a finite set of one or more
<a class="reference internal" href="#term-node"><span class="xref std std-term">nodes</span></a> such that there is one designated node
<span class="math notranslate nohighlight">\(R\)</span>, called the <a class="reference internal" href="#term-root"><span class="xref std std-term">root</span></a> of <span class="math notranslate nohighlight">\(\mathbf{T}\)</span>.
If the set <span class="math notranslate nohighlight">\((\mathbf{T} -\{R\})\)</span> is not empty, these
nodes are partitioned into <span class="math notranslate nohighlight">\(n &gt; 0\)</span>
<a class="reference internal" href="#term-disjoint-sets"><span class="xref std std-term">disjoint sets</span></a> <span class="math notranslate nohighlight">\(\mathbf{T}_0\)</span>,
<span class="math notranslate nohighlight">\(\mathbf{T}_1\)</span>, …, <span class="math notranslate nohighlight">\(\mathbf{T}_{n-1}\)</span>,
each of which is a tree, and whose <a class="reference internal" href="#term-root"><span class="xref std std-term">roots</span></a>
<span class="math notranslate nohighlight">\(R_1, R_2, ..., R_n\)</span>,
respectively, are <a class="reference internal" href="#term-child"><span class="xref std std-term">children</span></a> of <span class="math notranslate nohighlight">\(R\)</span>.</p>
</dd>
<dt id="term-tree-traversal">tree traversal<a class="headerlink" href="#term-tree-traversal" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-traversal"><span class="xref std std-term">traversal</span></a> performed on a tree.
Traditional tree traversals include
<a class="reference internal" href="#term-preorder-traversal"><span class="xref std std-term">preorder</span></a> and
<a class="reference internal" href="#term-postorder-traversal"><span class="xref std std-term">postorder</span></a> traversals for both
<a class="reference internal" href="#term-binary-tree"><span class="xref std std-term">binary</span></a> and <a class="reference internal" href="#term-general-tree"><span class="xref std std-term">general</span></a>
trees, and <a class="reference internal" href="#term-inorder-traversal"><span class="xref std std-term">inorder traversal</span></a> that is most
appropriate for a <a class="reference internal" href="#term-BST"><span class="xref std std-term">BST</span></a>.</p>
</dd>
<dt id="term-trie">trie<a class="headerlink" href="#term-trie" title="Permalink to this term">¶</a></dt><dd><p>A form of <a class="reference internal" href="#term-search-tree"><span class="xref std std-term">search tree</span></a> where an internal node represents
a split in the <a class="reference internal" href="#term-key-space"><span class="xref std std-term">key space</span></a> at a predetermined location,
rather than split based on the actual <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> values seen.
For example, a simple binary search trie for key values in the
range 0 to 1023 would store all records with key values less
than 512 on the left side of the tree, and all records with key
values equal to or greater than 512 on the right side of the
tree.
A trie is always a <a class="reference internal" href="#term-full-tree"><span class="xref std std-term">full tree</span></a>.
Folklore has it that the term comes from “retrieval”, and should
be pronounced as “try” (in contrast to “tree”, to distinguish
the differences in the space decomposition method of a search
tree versus a search trie).
The term “trie” is also sometimes used as a synonym for the
<a class="reference internal" href="#term-alphabet-trie"><span class="xref std std-term">alphabet trie</span></a>.</p>
</dd>
<dt id="term-truth-table">truth table<a class="headerlink" href="#term-truth-table" title="Permalink to this term">¶</a></dt><dd><p>In symbolic logic, a table that contains as rows all possible
combinations of the boolean variables, with a column that shows
the outcome (true or false) for the expression when given that
row’s truth assignment for the boolean variables.</p>
</dd>
<dt id="term-tuple">tuple<a class="headerlink" href="#term-tuple" title="Permalink to this term">¶</a></dt><dd><p>In set notation, another term for a <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a>.</p>
</dd>
<dt id="term-Turing-machine">Turing machine<a class="headerlink" href="#term-Turing-machine" title="Permalink to this term">¶</a></dt><dd><p>A type of <a class="reference internal" href="#term-Finite-Automata"><span class="xref std std-term">finite automata</span></a> that, while simple to define
completely, is capable of performing any computation that can be
performed by any known computer.</p>
</dd>
<dt id="term-Turing-acceptable">Turing-acceptable<a class="headerlink" href="#term-Turing-acceptable" title="Permalink to this term">¶</a></dt><dd><p>A language is <span class="math notranslate nohighlight">\(Turing-acceptable\)</span> if there is some
<a class="reference internal" href="#term-Turing-machine"><span class="xref std std-term">Turing machine</span></a> that <a class="reference internal" href="#term-accept"><span class="xref std std-term">accepts</span></a> it.
That is, the machine will halt in an accepting configuration if
the string is in the language, and go into a
<a class="reference internal" href="#term-hanging-configuration"><span class="xref std std-term">hanging configuration</span></a> if the string is not in the language.</p>
</dd>
<dt id="term-Turing-computable-function">Turing-computable function<a class="headerlink" href="#term-Turing-computable-function" title="Permalink to this term">¶</a></dt><dd><p>Any function for which there exists a Turing machine that can
perform the necessary work to compute the function.</p>
</dd>
<dt id="term-Turing-decidable">Turing-decidable<a class="headerlink" href="#term-Turing-decidable" title="Permalink to this term">¶</a></dt><dd><p>A language is Turing-decideable if there exists a Turing machine
that can clearly indicate for every string whether that string
is in the language or not.
Every Turing-decidable language is also Turing-acceptable,
because the Turing machine that can decide if the string is in
the language can be modified to go into a
<a class="reference internal" href="#term-hanging-configuration"><span class="xref std std-term">hanging configuration</span></a> if the string is not in the language.</p>
</dd>
<dt id="term-two-coloring">two-coloring<a class="headerlink" href="#term-two-coloring" title="Permalink to this term">¶</a></dt><dd><p>An assignment from two colors to regions in an image
such that no two regions sharing a side have the same color.</p>
</dd>
<dt id="term-type">type<a class="headerlink" href="#term-type" title="Permalink to this term">¶</a></dt><dd><p>A collection of values.</p>
</dd>
<dt id="term-unary-notation">unary notation<a class="headerlink" href="#term-unary-notation" title="Permalink to this term">¶</a></dt><dd><p>A way to represent <a class="reference internal" href="#term-natural-numbers"><span class="xref std std-term">natural numbers</span></a>, where the value of
zero is represented by the empty string, and the value <span class="math notranslate nohighlight">\(n\)</span>
is represented by a series of <span class="math notranslate nohighlight">\(n\)</span> marks.</p>
</dd>
<dt id="term-uncountably-infinite">uncountably infinite<a class="headerlink" href="#term-uncountably-infinite" title="Permalink to this term">¶</a></dt><dt id="term-uncountable">uncountable<a class="headerlink" href="#term-uncountable" title="Permalink to this term">¶</a></dt><dd><p>An infinite set is uncountably infinite if there does not exist
any mapping from it to the set of integers.
This is often proved using a <a class="reference internal" href="#term-diagonalization-argument"><span class="xref std std-term">diagonalization argument</span></a>.
The real numbers is an example of an uncountably infinite set.</p>
</dd>
<dt id="term-underflow">underflow<a class="headerlink" href="#term-underflow" title="Permalink to this term">¶</a></dt><dd><p>The condition where the amount of data stored in an entity has
dropped below some minimum threshold.
For example, a node in a <a class="reference internal" href="#term-1"><span class="xref std std-term">B-tree</span></a> is required to be at
least half full.
If a record deletion causes the node to be less than half full,
then it is in a condition of underflow, and something has to be
done to correct this.</p>
</dd>
<dt id="term-undirected-edge">undirected edge<a class="headerlink" href="#term-undirected-edge" title="Permalink to this term">¶</a></dt><dd><p>An <a class="reference internal" href="#term-edge"><span class="xref std std-term">edge</span></a> that connects two <a class="reference internal" href="#term-vertex"><span class="xref std std-term">vertices</span></a> with
no direction between them.
Many graph representations will represent such an edge
with two <a class="reference internal" href="#term-directed-edge"><span class="xref std std-term">directed edges</span></a>.</p>
</dd>
<dt id="term-undirected-graph">undirected graph<a class="headerlink" href="#term-undirected-graph" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> whose <a class="reference internal" href="#term-edge"><span class="xref std std-term">edges</span></a> do not have a direction.</p>
</dd>
<dt id="term-uninitialized">uninitialized<a class="headerlink" href="#term-uninitialized" title="Permalink to this term">¶</a></dt><dd><p>Uninitialized variable means it has no initial value.</p>
</dd>
<dt id="term-UNION">UNION<a class="headerlink" href="#term-UNION" title="Permalink to this term">¶</a></dt><dd><p>One half of the <a class="reference internal" href="#term-UNION-FIND"><span class="xref std std-term">UNION/FIND</span></a> algorithm for managing
<a class="reference internal" href="#term-disjoint-sets"><span class="xref std std-term">disjoint sets</span></a>. It is the process of merging two trees
that are represented using the
<a class="reference internal" href="#term-parent-pointer-representation"><span class="xref std std-term">parent pointer representation</span></a> by making the root for one
of the trees set its parent pointer to the root of the other
tree.</p>
</dd>
<dt id="term-UNION-FIND">UNION/FIND<a class="headerlink" href="#term-UNION-FIND" title="Permalink to this term">¶</a></dt><dd><p>A process for mainining a collection of disjoint sets.
The <a class="reference internal" href="#term-FIND"><span class="xref std std-term">FIND</span></a> operation determines which disjoint set a given
object resides in, and the <a class="reference internal" href="#term-UNION"><span class="xref std std-term">UNION</span></a> operation combines two
disjoint sets when it is determined that they are members of the
same <a class="reference internal" href="#term-equivalence-class"><span class="xref std std-term">equivalence class</span></a> under some
<a class="reference internal" href="#term-equivalence-relation"><span class="xref std std-term">equivalence relation</span></a>.</p>
</dd>
<dt id="term-unit-production">unit production<a class="headerlink" href="#term-unit-production" title="Permalink to this term">¶</a></dt><dd><p>A unit production is a <a class="reference internal" href="#term-production"><span class="xref std std-term">production</span></a> in a <a class="reference internal" href="#term-grammar"><span class="xref std std-term">grammar</span></a>
of the form <span class="math notranslate nohighlight">\(A \rightarrow B\)</span>, where <span class="math notranslate nohighlight">\(A, B \in\)</span> the
set of <a class="reference internal" href="#term-non-terminal"><span class="xref std std-term">non-terminals</span></a> for the grammar.
Any grammar with unit productions can be rewritten to remove
them.</p>
</dd>
<dt id="term-unsolveable-problem">unsolveable problem<a class="headerlink" href="#term-unsolveable-problem" title="Permalink to this term">¶</a></dt><dd><p>A problem that can proved impossible to solve on a computer.
The classic example is the <a class="reference internal" href="#term-halting-problem"><span class="xref std std-term">halting problem</span></a>.</p>
</dd>
<dt id="term-unsorted-list">unsorted list<a class="headerlink" href="#term-unsorted-list" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-list"><span class="xref std std-term">list</span></a> where the records stored in the list can appear
in any order (as opposed to a <a class="reference internal" href="#term-sorted-list"><span class="xref std std-term">sorted list</span></a>).
An unsorted list can support efficient (<span class="math notranslate nohighlight">\(\Theta(1)\)</span>)
insertion time (since you can put the record anywhere
convenient), but requires <span class="math notranslate nohighlight">\(\Theta(n)\)</span> time for both search
and and deletion.</p>
</dd>
<dt id="term-unsuccessful-search">unsuccessful search<a class="headerlink" href="#term-unsuccessful-search" title="Permalink to this term">¶</a></dt><dd><p>When searching for a <a class="reference internal" href="#term-key"><span class="xref std std-term">key</span></a> value in a collection of
records, we might not find it.
If so, we call this an unsuccessful search.
Usually we require that this means that no record in the
collection actually has that key value
(though a <a class="reference internal" href="#term-probabilistic-algorithm"><span class="xref std std-term">probabilistic algorithm</span></a> for search might not
require this to be true).
The alternative to an unsuccessful search is a
<a class="reference internal" href="#term-successful-search"><span class="xref std std-term">successful search</span></a>.</p>
</dd>
<dt id="term-unvisited">unvisited<a class="headerlink" href="#term-unvisited" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> algorithms, this refers to a node that has not
been processed at the current point in the algorithm.
This information is typically maintained by using a
<a class="reference internal" href="#term-mark-array"><span class="xref std std-term">mark array</span></a>.</p>
</dd>
<dt id="term-upper-bound">upper bound<a class="headerlink" href="#term-upper-bound" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-algorithm-analysis"><span class="xref std std-term">algorithm analysis</span></a>, a <a class="reference internal" href="#term-growth-rate"><span class="xref std std-term">growth rate</span></a> that is
always greater than or equal to the growth rate of the
<a class="reference internal" href="#term-algorithm"><span class="xref std std-term">algorithm</span></a> in question.
In practice, this is the slowest-growing function that we know
grows at least as fast as all but a constant number of inputs.
It could be a gross over-estimate of the truth.
Since the upper bound for the algorithm can be very different
for different situations (such as the <a class="reference internal" href="#term-best-case"><span class="xref std std-term">best case</span></a> or
<a class="reference internal" href="#term-worst-case"><span class="xref std std-term">worst case</span></a>), we typically have to specify which
situation we are referring to.</p>
</dd>
<dt id="term-value-parameter">value parameter<a class="headerlink" href="#term-value-parameter" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-parameter"><span class="xref std std-term">parameter</span></a> that has been
<a class="reference internal" href="#term-pass-by-value"><span class="xref std std-term">passed by value</span></a>.
Changing such a parameter inside the function or method will not
affect the value of the calling parameter.</p>
</dd>
<dt id="term-variable-length-coding">variable-length coding<a class="headerlink" href="#term-variable-length-coding" title="Permalink to this term">¶</a></dt><dd><p>Given a collection of objects, a variable-length coding scheme
assigns a code to each object in the collection using codes that
can be of different lengths.
Typically this is done in a way such that the objects that are
most likely to be used have the shortest codes, with the goal of
minimizing the total space needed to represent a sequence of
objects, such as when representing the characters in a document.
<a class="reference internal" href="#term-Huffman-codes"><span class="xref std std-term">Huffman coding</span></a> is an example of a
variable-length coding scheme.
This is in contrast to <a class="reference internal" href="#term-fixed-length-coding"><span class="xref std std-term">fixed-length coding</span></a>.</p>
</dd>
<dt id="term-vector">vector<a class="headerlink" href="#term-vector" title="Permalink to this term">¶</a></dt><dd><p>In set notation, another term for a <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a>.
As a data structure, the term vector usually used as a snyonym
for a <a class="reference internal" href="#term-dynamic-array"><span class="xref std std-term">dynamic array</span></a>.</p>
</dd>
<dt id="term-vertex">vertex<a class="headerlink" href="#term-vertex" title="Permalink to this term">¶</a></dt><dd><p>Another name for a <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a> in a <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a>.</p>
</dd>
<dt id="term-virtual-memory">virtual memory<a class="headerlink" href="#term-virtual-memory" title="Permalink to this term">¶</a></dt><dd><p>A memory management technique for making relatively fast but
small memory appear larger to the program.
The large “virtual” data space is actually stored on a
relatively slow but large <a class="reference internal" href="#term-backing-storage"><span class="xref std std-term">backing storage</span></a> device, and
portions of the data are copied into the smaller, faster memory
as needed by use of a <a class="reference internal" href="#term-buffer-pool"><span class="xref std std-term">buffer pool</span></a>.
A common example is to use <a class="reference internal" href="#term-RAM"><span class="xref std std-term">RAM</span></a> to manage access to a
large virtual space that is actually stored on a
<a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a>.
The programmer can implement a program as though the entire
data content were stored in RAM, even if that is larger than the
physical RAM available making it easier to implement.</p>
</dd>
<dt id="term-visit">visit<a class="headerlink" href="#term-visit" title="Permalink to this term">¶</a></dt><dd><p>During the process of a <a class="reference internal" href="#term-traversal"><span class="xref std std-term">traversal</span></a> on a <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> or
<a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a> the action that takes place on each <a class="reference internal" href="#term-node"><span class="xref std std-term">node</span></a>.</p>
</dd>
<dt id="term-visited">visited<a class="headerlink" href="#term-visited" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> algorithms, this refers to a node that has
previously been processed at the current point in the
algorithm.
This information is typically maintained by using a
<a class="reference internal" href="#term-mark-array"><span class="xref std std-term">mark array</span></a>.</p>
</dd>
<dt id="term-visitor">visitor<a class="headerlink" href="#term-visitor" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-design-pattern"><span class="xref std std-term">design pattern</span></a> where a <a class="reference internal" href="#term-traversal"><span class="xref std std-term">traversal</span></a> process is
given a function (known as the visitor) that is applied to every
object in the collection being traversed.
For example, a generic tree or graph traversal might be
designed such that it takes a function parameter,
where that function is applied to each node.</p>
</dd>
<dt id="term-volatile">volatile<a class="headerlink" href="#term-volatile" title="Permalink to this term">¶</a></dt><dd><p>In the context of computer memory, this refers to a memory that
loses all stored information when the power is turned off.</p>
</dd>
<dt id="term-weight">weight<a class="headerlink" href="#term-weight" title="Permalink to this term">¶</a></dt><dd><p>A cost or distance most often associated with an <a class="reference internal" href="#term-edge"><span class="xref std std-term">edge</span></a> in
a <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a>.</p>
</dd>
<dt id="term-weighted-graph">weighted graph<a class="headerlink" href="#term-weighted-graph" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> whose <a class="reference internal" href="#term-edge"><span class="xref std std-term">edges</span></a> each have an
associated <a class="reference internal" href="#term-weight"><span class="xref std std-term">weight</span></a> or cost.</p>
</dd>
<dt id="term-weighted-path-length">weighted path length<a class="headerlink" href="#term-weighted-path-length" title="Permalink to this term">¶</a></dt><dd><p>Given a tree, and given a <a class="reference internal" href="#term-weight"><span class="xref std std-term">weight</span></a> for each leaf in the
tree, the weighted path length for a leaf is its weight
times its <a class="reference internal" href="#term-depth"><span class="xref std std-term">depth</span></a>.</p>
</dd>
<dt id="term-weighted-union-rule">weighted union rule<a class="headerlink" href="#term-weighted-union-rule" title="Permalink to this term">¶</a></dt><dd><p>When merging two disjoint sets using the <a class="reference internal" href="#term-UNION-FIND"><span class="xref std std-term">UNION/FIND</span></a>
algorithm, the weighted union rule is used to determine which
subtree’s root points to the other.
The root of the subtree with fewer nodes will be set to point to
the root of the subtree with more nodes.
In this way, the average depth of nodes in the resulting tree
will be less than if the assignment had been made in the other
direction.</p>
</dd>
<dt id="term-working-memory">working memory<a class="headerlink" href="#term-working-memory" title="Permalink to this term">¶</a></dt><dd><p>The portion of <a class="reference internal" href="#term-main-memory"><span class="xref std std-term">main memory</span></a> available to an algorithm for
its use.
Typically refers to main memory made available to an algorithm
that is operating on large amounts of data stored in
<a class="reference internal" href="#term-peripheral-storage"><span class="xref std std-term">peripheral storage</span></a>, the working memory represents space
that can hold some subset of the total data being processed.</p>
</dd>
<dt id="term-worst-case">worst case<a class="headerlink" href="#term-worst-case" title="Permalink to this term">¶</a></dt><dd><p>In algorithm analysis, the <a class="reference internal" href="#term-problem-instance"><span class="xref std std-term">problem instance</span></a> from among
all problem instances for a given input size <span class="math notranslate nohighlight">\(n\)</span> that has
the greatest cost. Note that the worst case is <strong>not</strong> when
<span class="math notranslate nohighlight">\(n\)</span> is big, since we are referring to the wrost from a
class of inputs (i.e, we want the worst of those inputs of size
<span class="math notranslate nohighlight">\(n\)</span>).</p>
</dd>
<dt id="term-worst-fit">worst fit<a class="headerlink" href="#term-worst-fit" title="Permalink to this term">¶</a></dt><dd><p>In a <a class="reference internal" href="#term-memory-manager"><span class="xref std std-term">memory manager</span></a>, worst fit is a <a class="reference internal" href="#term-heuristic"><span class="xref std std-term">heuristic</span></a>
for deciding which <a class="reference internal" href="#term-free-block"><span class="xref std std-term">free block</span></a> to use when allocating
memory from a <a class="reference internal" href="#term-memory-pool"><span class="xref std std-term">memory pool</span></a>.
Worst fit will always allocate from the largest free block.
The rationale is that this will be the method least likely to
cause <a class="reference internal" href="#term-external-fragmentation"><span class="xref std std-term">external fragmentation</span></a> in the form of small,
unuseable memory blocks.
The disadvantage is that it tends to eliminate the availability
of large freeblocks needed for unusually large requests.</p>
</dd>
<dt id="term-zigzig">zigzig<a class="headerlink" href="#term-zigzig" title="Permalink to this term">¶</a></dt><dd><p>A type of <a class="reference internal" href="#term-rebalancing-operation"><span class="xref std std-term">rebalancing operation</span></a> used by
<a class="reference internal" href="#term-Splay-Tree"><span class="xref std std-term">splay trees</span></a>.</p>
</dd>
<dt id="term-Zipf-distribution">Zipf distribution<a class="headerlink" href="#term-Zipf-distribution" title="Permalink to this term">¶</a></dt><dd><p>A data distribution that follows Zipf’s law, an emprical
observation that many types of data studied in the physical and
social sciences follow a power law probability distribution.
That is, the frequency of any record in the data collection is
inversely proportional to its rank when the collection is sorted
by frequency.
Thus, the most frequently appearing record has a frequency much
higher than the next most frequently appearing record, which in
turn has a frequency much higher than the third (but with ratio
slightly lower than that for the first two records) and so on.
The <a class="reference internal" href="#term-80-20-rule"><span class="xref std std-term">80/20 rule</span></a> is a casual characterization of a Zipf
distribution.
Adherence to a Zipf distribution is important to the successful
operation of a <a class="reference internal" href="#term-caching"><span class="xref std std-term">cache</span></a> or
<a class="reference internal" href="#term-self-organizing-list"><span class="xref std std-term">self-organizing list</span></a>.</p>
</dd>
<dt id="term-zone">zone<a class="headerlink" href="#term-zone" title="Permalink to this term">¶</a></dt><dd><p>In <a class="reference internal" href="#term-memory-manager"><span class="xref std std-term">memory management</span></a>, the concept that
different parts of the <a class="reference internal" href="#term-memory-pool"><span class="xref std std-term">memory pool</span></a> are handled in
different ways.
For example, some of the memory might be handled by a simple
<a class="reference internal" href="#term-freelist"><span class="xref std std-term">freelist</span></a>, while other portions of the memory pool might
be handled by a <a class="reference internal" href="#term-sequential-fit"><span class="xref std std-term">sequential fit</span></a> memory manager.
On a <a class="reference internal" href="#term-disk-drive"><span class="xref std std-term">disk drive</span></a> the concept of a zone relates to the
fact that there are limits to the maximum data density, combined
with the fact that the need for the same angular distance to be
used for a sector in each track means that tracks further from
the center of the disk will become progressively less dense.
A zone in this case is a series of adjacent tracks whose data
density is set by the maximum density of the innermost track of
that zone.
The next zone can then reset the data density for its innermost
track, thereby gaining more total storage space while preserving
angular distance for each sector.</p>
</dd>
</dl>
</div>


      </div>
      <div class="bottomnav">
      <p><span class="email_div" style="display:inline;"><a id="contact_us" class="contact" style="float:left;color:blue;" rel="nofollow" href="mailto:">Contact Us |</a><a style="float:left;color:blue;" rel="nofollow" href="../../../lib/Privacy.html" target="_blank">| Privacy |</a> <a style="float:left;color:blue;" rel="nofollow" href="../../../lib/license.html" target="_blank">| License</a></span>&#160;&#160;
      
        «&#160;&#160;<a id="prevmod1" href="NPCoping.html">7.<span class="section-number">6. </span>Coping with NP-Complete Problems</a>
        &#160;&#160;::&#160;&#160;
        <a  class="uplink" href="index.html">Contents</a>

</p>
      </div>
      <img style="float:right;" src="_static/nsf1.gif" height="62" width="62" alt="nsf"/>


    <div class="footer">
      <p>
        <span class="email_div" style="display:inline;">
          <a id="contact_us" class="contact" style="float:left;color:blue;" rel="nofollow" href="mailto:">Contact Us |</a>
          <a id="bugreport-link" style="float:left;color:blue;" class="bugreport-link" href="#">| Report a bug</a>
        </span>
      </p>
        &copy; Copyright 2011-2023 by OpenDSA Project Contributors and distributed under an MIT license.
      Last updated on Aug 13, 2024.
      Created using <a target="_blank" href="http://sphinx.pocoo.org/">Sphinx</a> 4.4.0.
    </div>
    
<div id="bugreport-box" class="bugreport-popup ">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close Window" /></a>
  <form method="post" class="report" action="https://#">
    <fieldset class="textbox">
      <div id="bug_error" class="error"></div>
      <label>
        <span>Summary*:</span>
        <input type="text" id="b_title" placeholder="Summary" />
      </label>

      <label class="os">
        <span>Operating system*:</span>
        <select id="b_os">
          <option value="windows">Windows</option>
          <option value="macos">Mac OS</option>
          <option value="linux">Linux</option>
          <option value="ios">iOS</option>
          <option value="android">Android</option>
          <option value="other">Other</option>
        </select>
      </label>

      <label class="browser">
        <span>Browser*:</span>
        <select id="b_browser">
          <option value="chrome">Chrome</option>
          <option value="safari">Safari</option>
          <option value="internetexplorer">Internet Explorer</option>
          <option value="opera">Opera</option>
          <option value="other">Other</option>
        </select>
      </label>

      <label class="description">
        <span>Description*:</span><br>
        <textarea id="b_description" rows="5" cols="25" placeholder="***BUG** Please enter: (1) a consice description of the problem. (2) steps to reproduce bug. (3) the version of your browser and operating system."></textarea>
      </label>

      <label class="screenshot">
        <span>Attach a screenshot (optional):</span>
        <input type="file" id="b_screenshot" accept="image/*" placeholder="Attach a screenshot (optional)">
      </label>

      <p>
        <input type="submit" id="bug-submit-button" value="Submit &rarr;"/>
      </p>
    </fieldset>
  </form>
</div>

  </body>
</html>